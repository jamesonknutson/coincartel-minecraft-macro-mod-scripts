//! @mkb-import-begin
    // string/index/convertENote
        // Converts a Number formatted in Exponential Notation (e.g. "3.172E10") to standard string decimal form.
            // Params:
                // {string} <&enote_string>    The E. Notation Number string to convert.
                //
            // Returns the Number coerced into a valid decimal float value. If a non-e-notation string is passed,
            // the input string is returned as-is.
        function convertENote(&convert_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:172
            debug              = true;
            &script_debug_name = "&9convertENote&7";
            &convert_string    = replace(&convert_string,",");
            &return_string     = %&convert_string%;
            ifmatches(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$");
                match(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$",{&m_sign_num,&m_leading_num,&m_trailing_num,&m_sign_exponent,&m_exponent_num});
                output_negative   = %&m_sign_num% == "-";
                exponent_negative = %&m_sign_exponent% == "-";
                
                // Convert Scientific Notation to a Real Number
                // Multiply the decimal number by 10 raised to the power indicated.
                // 3.456 x 10^4  = 3.456 x 10,000 = 34560
                // 3.456 x 10^-4 = 3.456 x .0001  = 0.0003456
                //
                
                //    Convert Scientific Notation without a Calculator
                //    We’ve shown you how to convert a number expressed in scientific notation to a decimal by solving,
                //    but this would get more difficult to do manually as the exponent gets larger. There’s an alternate
                //    way to convert to decimal without solving the equation.
                //
                //    If the exponent is positive, move the decimal point in the coefficient to the right one space for each
                //    value in the exponent.
                //
                //    For instance, if the exponent is two, then move the decimal point to the right two spaces. If the exponent
                //    is negative, then move the decimal point to the left.
                //
                //    For example, let’s convert 1.5 × 10^2 to a decimal using this method.
                //
                //    1.5 × 10^2 = 15.0  × 10^1
                //    1.5 × 10^2 = 150.0 × 10^0
                //    1.5 × 10^2 = 150.0
                
                //    For a Positive Exponent (moving decimal point to the right)
                    //    1.396       x    10^6    =    13.96        x 10^5
                    //    13.96       x    10^5    =    139.6        x 10^4
                    //    139.6       x    10^4    =    1396.0       x 10^3
                    //    1396.0      x    10^3    =    13960.0      x 10^2
                    //    13960.0     x    10^2    =    139600.0     x 10^1
                    //    139600.0    x    10^1    =    1396000.0    x 10^0
                    //    1.396       x    10^6    =    1396000.0
                //    For a Negative Exponent (moving decimal point to the left)
                    //    1.396          x    10^-6    = 0.1396         x    10^-5
                    //    0.1396         x    10^-5    = 0.01396        x    10^-4
                    //    0.01396        x    10^-4    = 0.001396       x    10^-3
                    //    0.001396       x    10^-3    = 0.0001396      x    10^-2
                    //    0.0001396      x    10^-2    = 0.00001396     x    10^-1
                    //    0.00001396     x    10^-1    = 0.000001396    x    10^ 0
                    //    0.000001396    x    10^-6    = 0.000001396
                
                #m_exponent_num  := %&m_exponent_num%;
                &m_joint_chars    = "%&m_leading_num%.%&m_trailing_num%";
                &m_joint_chars[]  = split("",%&m_joint_chars%);
                do(%#m_exponent_num%);
                    #m_joint_chars_sz   = arraysize(&m_joint_chars[]);
                    #m_joint_chars_len  = %#m_joint_chars_sz% - 1;
                    #curr_decimal_idx   = indexof(&m_joint_chars[],,".");
                    if(!%exponent_negative%);
                        #next_decimal_idx = %#curr_decimal_idx% + 1;
                        if(%#next_decimal_idx% <= %#m_joint_chars_len%);
                            &m_joint_chars[%#curr_decimal_idx%] = %&m_joint_chars[%#next_decimal_idx%]%;
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        else;
                            &m_joint_chars[%#curr_decimal_idx%] = "0";
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        endif;
                    else;
                        #next_decimal_idx = %#curr_decimal_idx% - 1;
                        if(%#next_decimal_idx% >= 0);
                            &m_joint_chars[%#curr_decimal_idx%] = %&m_joint_chars[%#next_decimal_idx%]%;
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        else;
                            unset(&tmp_joint_chars[]);
                            &m_joint_chars[%#curr_decimal_idx%] = "0";
                            push(&tmp_joint_chars[],".",&m_joint_chars[*]);
                            unset(&m_joint_chars[]);
                            push(&m_joint_chars[],&tmp_joint_chars[*]);
                        endif;
                    endif;
                loop;
                &return_string = join("",&m_joint_chars[]);
                &return_string = regexreplace(&return_string,"\.0*$");
                &return_string = regexreplace(&return_string,"^\.","0.");
                &return_string = "%&m_sign_num%%&return_string%";
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/xFormatNumber
        // Identical to original `formatnumber`, but passes the input_string through `convertENote` before passing it into `formatnumber`.
            // Params:
                // {string} <&input_string>          The Number or String to Format into a Number. If this Number includes Commas, they will be stripped
                //                                   from the string passed to `formatnumber`.
                // {string} [&decimal_precision]     The desired level of precision following the decimal. If omitted or an empty string, will
                //                                   include the amount of decimals included in the <&input_string>. If provided, should be an integer >= 0.
                //                                   If set to 0, will not include a decimal character or trail at all. Providing a value that is incoherent
                //                                   to the level of decimal precision present in the <&input_string> will result in the output being rounded
                //                                   to the desired level of precision.
                // {boolean} [strip_commas=false]    Whether or not to strip commas when formatting the Number. If set to True, and [&decimal_precision]
                //                                   is set to "0", this Function will return a valid Integer.
            // Returns the result of the `formatnumber` expression.
            // Examples:
                // Converting a formatted string Number to a valid Integer:
                    //    &input_string      = "1009.0131";
                    //    &decimal_precision = "0";
                    //    strip_commas       = true;
                    //    #output_integer    = xFormatNumber(%&input_string%,%&decimal_precision%,%strip_commas%);
                // Converting a valid Integer to a formatted (comma split) string:
                    //    &input_string      = "10000";
                    //    &decimal_precision = "";
                    //    strip_commas       = false;
                    //    &output_string     = xFormatNumber(%&input_string%,%&decimal_precision%,%strip_commas%);
        function xFormatNumber(&input_string,&decimal_precision,strip_commas=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:315
            &return_string = replace(&input_string,",");
            &return_string = convertENote(%&return_string%);
            &return_string = formatnumber(%&return_string%,%&decimal_precision%,%strip_commas%);
            return(%&return_string%);
        endfunction;
    // debug/index/debug_log
        // Logs a message to chat if debug is enabled.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_log(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:30
            // &matcher     = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement = "&$1";
            // &string      = regexreplace(&string,%&matcher%,%&replacement%);
            &out_string  = "&7%&script_debug_name%&7: %&string%";
            if(%debug_enabled%);
                log(%&out_string%);
            endif;
            return(%&out_string%);
        endfunction;
    // string/index/xEval
        // Identical to original `eval`, but passes the result of the function along to `convertENote` to ensure decimal values are conserved.
            // Params:
                // {string} <&expression>              The arithmetic expression to evaluate with `eval`.
                // {boolean} [coerce_integer=false]    If true, will attempt to coerce the result of the evaluation from a decimal value into an integer.
            // Returns the result of `eval` passed through `convertENote`, and optionally coerced into an Integer if [coerce_integer] is True.
        function xEval(&expression,coerce_integer=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:276
            debug              = false;
            &script_debug_name = "&9xEval&7";
            debug_log(%debug%,%&script_debug_name%,"evaluating '%&expression%', coerce_integer: %coerce_integer%.");
            &return_string     = eval(%&expression%);
            debug_log(%debug%,%&script_debug_name%,"got result: '&d%&return_string%&7', passing thru convertENote");
            &return_string     = convertENote(%&return_string%);
            debug_log(%debug%,%&script_debug_name%,"convertENote returned: '&d%&return_string%&7'");
            if(%coerce_integer%);
                debug_log(%debug%,%&script_debug_name%,"coercing '&d%&return_string%&7' to a number");
                &return_string = formatnumber(%&return_string%,0,true);
            endif;
            debug_log(%debug%,%&script_debug_name%,"returning '&d%&return_string%&7'");
            return(%&return_string%);
        endfunction;
    // string/index/convertToMetric
        // Takes an input of a Number String and formats it into a Metric String (K, M, B, or T as suffix).
            // Params:
                // {string} <&convert_string>         The Number String to convert.
                // {number} [#decimal_precision=1]    Amount of sig. figs to round the conversion off to. If set to <= -1, will just
                //                                    format the number as-is (it will keep as many decimal places as it had in the first place).
            // Returns a String.
            // Example:
                //    &metric_string = convertToMetric("151091.501",1);
                //    log(%&metric_string%); // 151.1 K
        function convertToMetric(&convert_string,#decimal_precision=1);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:566
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9convertToMetric&7";
                debug_log(%debug%,%&script_debug_name%,"called, args are &&convert_string='&e%&convert_string%&7', #decimal_precision=&e%#decimal_precision%");
            endif;
            &metric_chars[] = split(", ","K, M, B, T");
            &metric_ratio[] = split(", ","1000, 1000000, 1000000000, 1000000000000");
            &return_string  = %&convert_string%;
            ifmatches(%&convert_string%,"^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)",&integer_portion,2);
                log("&7matched expression '&d^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)&7' against string ")
                #component_a_len = strlen(%&integer_portion%);
                debug_log(%debug%,%&script_debug_name%,"matched expression '&d^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)&7' against &&convert_string='&e%&convert_string%&7', extracted &&integer_portion='&e%&integer_portion%&7' with length=&e%#component_a_len%&7.");
                #metric_index    = -1;
                foreach(&metric_ratio[],&metric_ratio,#mr);
                    #metric_ratio_len = strlen(%&metric_ratio%);
                    if(%#component_a_len% >= %#metric_ratio_len%);
                        debug_log(%debug%,%&script_debug_name%,"metric_ratio_len=&e%#metric_ratio_len%&7 >= #component_a_len=&e%#component_a_len%&7, setting metric_index=&e%#mr%");
                        #metric_index = %#mr%;
                    endif;
                next;
                
                if(%#metric_index% >= 0);
                    &metric_char   = %&metric_chars[%#metric_index%]%;
                    &metric_ratio  = %&metric_ratio[%#metric_index%]%;
                    &return_string = xEval("%&convert_string% / %&metric_ratio%");
                    if(%#decimal_precision% <= -1);
                        &return_string = xFormatNumber(%&return_string%);
                    else;
                        &return_string = xFormatNumber(%&return_string%,%#decimal_precision%);
                    endif;
                    &return_string = "%&return_string% %&metric_char%";
                endif;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/convertMetricString
        // Takes an input of a string with metric numbers in it (e.g. '10K, '10.5M', etc) and parses out the metric character
        // then converts the input into a number and returns it. Supports K, M, B, T suffixes.
            // Params:
                // {string} <&metric_string>               The String to Parse
                // {number} [#decimal_precision=-1]        Amount of sig. figs to round the conversion off to. If set to <= -1, will just
                //                                         format the number as-is (it will keep as many decimal places as it had in the first place).
                // {boolean} [format_with_commas=false]    Whether or not to format the conversion with commas every 3 characters.
            // Returns an Empty String if no conversion were able to be done, or a (possibly formatted) Number otherwise.
            // Example:
                //    #converted_units = convertMetricString("10K",2,true);
                //    log(%#converted_units%); // 10,000.00
        function convertMetricString(&metric_string,#decimal_precision=-1,format_with_commas=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:529
            &base_expression = "([\d,.-]+)(?:.*?\b|\B)";
            &metric_chars[]  = split(", ","K, M, B, T");
            &metric_ratio[]  = split(", ","1000, 1000000, 1000000000, 1000000000000");
            &return_string   = "0";
            match_found      = false;
            foreach(&metric_chars[],&metric_char,#mc);
                &metric_expr = "%&base_expression%%&metric_char%";
                ifmatches(%&metric_string%,%&metric_expr%,&amount_units,1);
                    match_found    = true
                    &amount_units  = replace(&amount_units,",");
                    &return_string = xEval("%&return_string% + (%&amount_units% * %&metric_ratio[%#mc%]%)");
                endif;
            next;
            
            if(%match_found%);
                strip_commas = !%format_with_commas%;
                if(%#decimal_precision% <= -1);
                    &return_string = xFormatNumber(%&return_string%,"",%strip_commas%);
                else;
                    &return_string = xFormatNumber(%&return_string%,%#decimal_precision%,%strip_commas%);
                endif;
                return(%&return_string%);
            else;
                return("");
            endif;
        endfunction;
    // string/index/isMetricString
        // Checks if a String is a Metric String
            // Params:
                // {string} <&metric_string>    The String to check for a Metric Suffix (and/or Metric Suffixes)
                //
            // Returns a Boolean indicating whether or not the String is a Metric String
            // Example:
                //    is_metric = isMetricString(%&metric_string%);
        function isMetricString(&metric_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:510
            &base_expression = "([\d,.-]+)(?:.*?\b|\B)(K|M|B|T)";
            ifmatches(%&metric_string%,%&base_expression%);
                return_boolean = true;
            endif;
            return(%return_boolean%);
        endfunction;
    // array/index/miscComparator
        // Evaluates whether <&left> is <&operator> to <&right> (executes a variable comparison). Returns a boolean.
            // Params:
            //        {string} <&left>        The Left Hand side of the Comparison.
            //        {string} <&operator>    The Operator to apply the Condition against each Element with. Has to be one of:
            //                                '==', '!=', '>', '<', '>=', '<=', 'eq', 'ne', 'gte', 'lte', 'gt', or 'lt'. If a
            //                                number comparison operator is used, the values in the Array will be coerced to a
            //                                number so long as the condition is an integer. If the condition is a float value,
            //                                they will be evaluated using float math (eval).
            //        {string} <&right>       The Right Hand side of the Comparison
            //
            // Returns a boolean indicating the outcome of the evaluation.
        function miscComparator(&left,&operator,&right);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:88
            &sign_operators[] = split(", ","==, !=, >=, <=, >, <");
            #sign_op_index    = indexof(&sign_operators[],,%&operator%);
            if(%#sign_op_index% == -1);
                &char_operators[] =    split(", ","eq, ne, gte, lte, gt, lt");
                #char_op_index    = indexof(&char_operators[],,%&operator%);
                if(%#char_op_index% == -1);
                    return(&return_array[]);
                endif;
                
                &operator = %&sign_operators[%#char_op_index%]%;
            endif;
        
            if(%&operator% == "==");
                if(%&left% == %&right%);
                    return_boolean = true;
                endif;
            elseif(&operator% == "!=");
                if(%&left% != %&right%);
                    return_boolean = true;
                endif;
            else;
                ifmatches(%&right%,"^(\d+)$",#right,1);
                    // Doing Integer Evaluation
                    #left := %&left%;
                    if((%&operator% == ">=") && (%#left% >= %#right%));
                        return_boolean = true;
                    elseif((%&operator% == ">") && (%#left% > %#right%));
                        return_boolean = true;
                    elseif((%&operator% == "<=") && (%#left% <= %#right%));
                        return_boolean = true;
                    elseif((%&operator% == "<") && (%#left% < %#right%));
                        return_boolean = true;
                    endif;
                elseifmatches(%&right%,"^[0-9.-]+");
                    // Doing Float Evaluation
                    &float_diff = eval("%&left% - %&right%");
                    ifmatches(%&float_diff%,"^-");
                        // <left> - <right> = negative number, left was less than right
                        if((%&operator% == "<=") || (%&operator% == "<"));
                            return_boolean = true;
                        endif;
                    else;
                        // <left> - <right> = positive or 0, left was greater than or equal to right
                        ifmatches(%&float_diff%,"[0.]+");
                            // <left> - <right> = 0, left was equal to right
                            if((%&operator% == ">=") || (%&operator% == "<="));
                                return_boolean = true;
                            endif;
                        elseif((%&operator% == ">=") || (%&operator% == ">"));
                            // <left> - <right> = greater than 0, left was greater than right
                            return_boolean = true;
                        endif;
                    endif;
                endif;
            endif;
            return(%return_boolean%);
        endfunction;
    // math/index/number
        // Normalizes any type of input Number into the Type.
            // Params:
                // {string} <&number>             The Number to Format. Can be integer, decimal, negative, positive, metric, e-notation, whatever.
                // {string} [...&formatting[]]    The Formatting Options to apply. Settings are provided in '<KEY>: <VALUE>' notation. Valid Options:
                                                //    ['F'|'T'|'S'|'TYPE'|'STYLE'|'FORMAT']:
                                                //        - ['I'|'N'|'INT'|'INTEGER'|'NUM'|'NUMBER']           : Formats the output as an Integer.
                                                //        - ['D'|'F'|'L'|'DECIMAL'|'FLOAT'|'LONG'|'DOUBLE']    : Formats the output as a Decimal Number.
                                                //        - ['E'|'ENOTE'|'EXP'|'EXPONENT']                     : Formats the output in Exponentional Notation.
                                                //        - ['M'|'METRIC']                                     : Formats the output as a Metric Suffixed Number.
                                                //    ['P'|'PLACE'|'PLACES'|'PRECISION'] (Only available if Type is Decimal or Metric or equivalent):
                                                //        - ['S'|'SIG'|'SIGFIG'|'SIGNIFICANT']    : Applies the default amount of Decimal Places (the Sig. Figs in the converted value).
                                                //        - <NUMBER >= 0>                         : Applies <NUMBER> amount of Decimal Places (setting this to 0 is the same as using F: INT, R: ROUND).
                                                //    ['R'|'ROUND'|'ROUNDING'] (Only available if Precision is not 'SIG' or equivalent):
                                                //        - ['R'|'ROUND'|'D'|'DEFAULT'|'STD'|'STANDARD'|'NEAR'|'NEAREST'|'INT'|'NUM'|'INTEGER'|'NUMBER']    : Round using 'ROUND' (towards nearest integer).
                                                //        - ['F'|'FLOOR'|'DOWN'|'D'|'<'|'LESSER'|'LT']                                                      : Round using 'FLOOR' (towards negative infinity).
                                                //        - ['C'|'CEIL'|'CEILING'|'UP'|'>'|'GREATER'|'GT']                                                  : Round using 'CEIL' (towards positive infinity).
                                                //        - ['T'|'TRUNCATE'|'TRUNC']                                                                        : Rounds up or down towards 0
                                                //        - ['N'|'NONE']                                                                                    : Does not round the output.
                                                //    ['C'|'COMMA'|'COMMAS'|'DELIMIT'|'DELIMITER'|'SPACE'|'SPACER']:
                                                //        - <BOOLEAN>          : Enables (or disables) formatting the output with Commas every 3 sig. figs (e.g. 100000 -> 100,000)
                                                //        - <STRING>           : Enables formatting the output with <STRING> as the delimiter every 3 sig. figs
                                                //        - ['N'|'NONE'|'']    : Disables formatting the output with delimiters.
                                                //    The Default Values for each Setting are as follows:
                                                //        FORMAT       : FLOAT
                                                //        PRECISION    : SIGNIFICANT
                                                //        ROUNDING     : NONE
                                                //        DELIMITER    : FALSE
            // Returns the Number specified formatted according to the Rules specified in [...&formatting[]].
            // Example:
                //    &number = number("100,000,000.192");
                //    log("number: %&number%"); // 'number: 100000000.192' (default formatting rules were applied)
        function number(&number="0",...&formatting[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:198
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6mathNumber&7";
                exponent_ready     = false;
                
                // Parse Formatting Options
                if(true);
                    // Wrap Formatting Keys, Valid Values and Default Values
                    if(true);
                        if(true); // Wrap '&opt_format' Formatting Option
                            &valid_formatting_vars[]        = "&opt_format";
                            &valid_formatting_keys[]        = "F|T|S|TYPE|STYLE|FORMAT";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            if(%exponent_ready%);
                                &valid_formatting_vals[] = "INTEGER|I|N|INT|NUM|NUMBER~FLOAT|D|F|L|DECIMAL|LONG|DOUBLE~EXPONENT|E|ENOTE|EXP~METRIC|M";
                                &valid_formatting_expr[] = "INTEGER|r$^[\d]+$~FLOAT|r$^[\d]*\.\d+$~EXPONENT|r$(?:e|\^)";
                            else;
                                &valid_formatting_vals[] = "INTEGER|I|N|INT|NUM|NUMBER~FLOAT|D|F|L|DECIMAL|LONG|DOUBLE~METRIC|M";
                                &valid_formatting_expr[] = "INTEGER|r$^[\d]+$~FLOAT|r$^[\d]*\.\d+$";
                            endif;
                            &opt_format = "FLOAT";
                        endif;
                        
                        if(true); // Wrap '&opt_precision' Formatting Option
                            &valid_formatting_vars[]        = "&opt_precision";
                            &valid_formatting_keys[]        = "P|PLACE|PLACES|PRECISION";
                            &valid_formatting_vals[]        = "SIGNIFICANT|SIGFIG|SIG|S";
                            &valid_formatting_expr[]        = "CUSTOM|r$^\d+$";
                            &valid_formatting_validation[]  = ">= 0";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_precision                  = "SIGNIFICANT";
                        endif;
                        
                        if(true); // Wrap '&opt_rounding' Formatting Option
                            &valid_formatting_vars[]        = "&opt_rounding";
                            &valid_formatting_keys[]        = "ROUNDING|ROUND|R";
                            &valid_formatting_vals[]        = "ROUND|INT|NUM|NUMBER|NEAREST|NEAR|STD|STANDARD|DEFAULT|D|INTEGER|R~FLOOR|F|DOWN|D|<|LESSER|LT~CEIL|CEILING|C|UP|>|GREATER|GT~NONE|N~TRUNCATE|TRUNC|T";
                            &valid_formatting_expr[]        = "";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_rounding                   = "NONE";
                        endif;
                        
                        if(true); // Wrap '&opt_delimiter' Formatting Option
                            &valid_formatting_vars[]        = "&opt_delimiter";
                            &valid_formatting_keys[]        = "DELIMITER|C|COMMA|COMMAS|DELIMIT|SPACE|SPACER|SPACES|SPACERS|DELIMITERS";
                            &valid_formatting_vals[]        = "TRUE|1~FALSE|0~NONE|N"
                            &valid_formatting_expr[]        = "CUSTOM|r$^.+$";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_delimiter                  = "false";
                        endif;
                    endif;
                    
                    // Parse Options
                    if(true);
                        #formatting_sz = arraysize(&formatting[]);
                        if(%#formatting_sz% >= 1);
                            foreach(&formatting[],&formatting,#f);
                                ifmatches(%&formatting%,"^(.*?):\s*?(.*)$");
                                    match(%&formatting%,"^(.*?):\s*?(.*)$",{&custom_key,&custom_val});
                                    &check_key_index_for = ucase(%&custom_key%);
                                    &check_val_index_for = ucase(%&custom_val%);
                                    foreach(&valid_formatting_keys[],&valid_formatting_keys_str,#vfk);
                                        if(!%valid_formatting_def_override[%#vfk%]%);
                                            &valid_formatting_keys_arr[] = split("|",%&valid_formatting_keys_str%);
                                            #check_key_index_for         = indexof(&valid_formatting_keys_arr[],,%&check_key_index_for%);
                                            debug_log(%debug%,%&script_debug_name%,"checking key for '&d%&check_key_index_for%&7' index is '&e%#check_key_index_for%&7'.");
                                            if(%#check_key_index_for% != -1);
                                                &valid_formatting_val_types_arrs[] = split("~",%&valid_formatting_vals[%#vfk%]%);
                                                foreach(&valid_formatting_val_types_arrs[],&valid_formatting_val_type_str,#vfvt);
                                                    &valid_formatting_val_types_arr[] = split("|",%&valid_formatting_val_type_str%);
                                                    #check_val_index_for              = indexof(&valid_formatting_val_types_arr[],,%&check_val_index_for%);
                                                    debug_log(%debug%,%&script_debug_name%,"checking val index for '&d%&check_val_index_for%&7' index is '&e%#check_val_index_for%&7'.");
                                                    if(%#check_val_index_for% != -1);
                                                        &set_var = %&valid_formatting_vars[%#vfk%]%;
                                                        &set_val = %&valid_formatting_val_types_arr[0]%;
                                                        debug_log(%debug%,%&script_debug_name%,"setting value of &%&set_var%='&e%&set_val%&7'");
                                                        set(%&set_var%,%&set_val%);
                                                        set(valid_formatting_def_override[%#vfk%],true);
                                                        break;
                                                    endif;
                                                next;
                                                
                                                // If we found a match for the Key, but not for the Value, check to see if this Option allows Custom Input.
                                                // If it does, check if the provided Value passes the Regular Expression Validation, and then if this Option
                                                // also has a further Validation Check, ensure it passes that further Validation Check as well.
                                                if((!%valid_formatting_def_override[%#vfk%]%) && (%&valid_formatting_expr[%#vfk%]% != ""));
                                                    &input_validation_expr_groups[]      = split("~",%&valid_formatting_expr[%#vfk%]%);
                                                    &input_validation_expr_validations[] = split("~",%&valid_formatting_validation[%#vfk%]%);
                                                    input_passes_validation              = false;
                                                    foreach(&input_validation_tests[],&input_validation_test_string,#ivt);
                                                        ifmatches(%&input_validation_test_string%,"^(.+?)\|r\$(.+)$");
                                                            match(%&input_validation_test_string%,"^(.+?)\|r\$(.+)$",{&matched_value,&matched_expr});
                                                            ifmatches(%&custom_val%,%&matched_expr%);
                                                                input_passes_validation = true;
                                                                if(%&input_validation_expr_validations[%#ivt%]% != "");
                                                                    &validation_params[]    = split(" ",%&input_validation_expr_validations[%#ivt%]%);
                                                                    &validation_op          = %&validation_params[0]%;
                                                                    &validation_rhs         = %&validation_params[1]%;
                                                                    input_passes_validation = miscComparator(%&custom_val%,%&validation_op%,%&validation_rhs%);
                                                                endif;
                                                                
                                                                if(%input_passes_validation%);
                                                                    &set_var = %&valid_formatting_vars[%#vfk%]%;
                                                                    &set_val = ucase(%&matched_value%);
                                                                    if(%&set_val% == "CUSTOM");
                                                                        &set_val = %&custom_val%;
                                                                        set(valid_formatting_custom_input[%#vfk%],true);
                                                                    endif;
                                                                    set(%&set_var%,%&set_val%);
                                                                    set(valid_formatting_def_override[%#vfk%],true);
                                                                    debug_log(%debug%,%&script_debug_name%,"set value of &%&set_var%='&e%&set_val%&7'");
                                                                    break;
                                                                endif;
                                                            endif;
                                                        endif;
                                                    next;
                                                endif;
                                                
                                                if(%valid_formatting_def_override[%#vfk%]%);
                                                    break;
                                                endif;
                                            endif;
                                        endif;
                                    next;
                                endif;
                                
                                #non_overriden_index = indexof(valid_formatting_def_override[],,false);
                                if(%#non_overriden_index% == -1);
                                    break;
                                endif;
                            next;
                        endif;
                    endif;
                endif;
            endif;
            
            // Parse the Number into Standardized Format.
            if(true);
                ifnotmatches(%&number%,"\d");
                    &number = "0";
                endif;
                
                &read_number = replace(&number,",");
                ifmatches(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$");
                    &read_number = convertENote(%&number%);
                else;
                    &read_number = %&number%;
                endif;
                debug_log(%debug%,%&script_debug_name%,"Conversion of &&number (&5'%&number%&7') from Exp. Notation to Decimal returned &&read_number ('&d%&read_number%&7').");
                
                is_metric = isMetricString(%&read_number%);
                if(%is_metric%);
                    &before_metric = %&read_number%;
                    &read_number   = convertMetricString(%&read_number%,"-1");
                    ifmatches(%&read_number%,"^([\d.-]+)\.0*$",&first_portion,1);
                        debug_log(%debug%,%&script_debug_name%,"Conversion of &&read_number ('&5%&before_metric%&7') from Metric returned insignificant digits, cutting off (setting &&read_number to: '&e%&first_portion%&7' from '&d%&read_number%&7').");
                        &read_number = %&first_portion%;
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"Conversion of &&read_number ('&5%&before_metric%&7') from Metric returned '&d%&read_number%&7'.");
                elseif(%debug%);
                    debug_log(%debug%,%&script_debug_name%,"&&read_number ('&5%&read_number%&7') was not classified as being a Metric String.");
                endif;
                
                if(%debug%);
                    debug_log(%debug%,%&script_debug_name%,"Formatting Input Number '&d%&number%&7' (standardized: '&d%&read_number%&7')...");
                    &vars[] = split(" ","&number &read_number &opt_format &opt_precision &opt_rounding &opt_delimiter");
                    foreach(&vars[],&var,#v);
                        &val    = "%%&var%%";
                        &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                        &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                        debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
                    next;
                endif;
                
                // Apply the specified Rounding Option as defined in '&opt_rounding'
                if(true);
                    &before_round = %&read_number%;
                    if(%&opt_rounding% == "TRUNCATE");
                        debug_log(%debug%,%&script_debug_name%,"Truncating &&read_number ('&5%&before_round%&7') by cutting off all decimals.");
                        ifmatches(%&read_number%,"^([\d-]+)\.",&truncated_number,1);
                            &read_number = %&truncated_number%;
                            debug_log(%debug%,%&script_debug_name%,"Truncated &&read_number ('&5%&before_round%&7') to: '&d%&read_number%&7'.");
                        else;
                            debug_log(%debug%,%&script_debug_name%,"No decimal points to truncate in &&read_number ('&5%&before_round%&7').");
                        endif;
                    elseif(%&opt_rounding% != "NONE");
                        &read_number = xEval("%&opt_rounding%(%&read_number%)");
                        debug_log(%debug%,%&script_debug_name%,"Rounding &&read_number ('&5%&before_round%&7') with Method: '&e%&opt_rounding%&7' returned: &d'%&read_number%&7'.");
                    else;
                        debug_log(%debug%,%&script_debug_name%,"Not rounding &&read_number ('&5%&before_round%&7') at all, Rounding Method (&&opt_rounding: '&e%&opt_rounding%&7') is set to 'NONE'.");
                    endif;
                endif;
                
                // Apply the specified Formatting Option as defined in '&opt_format'
                if(true);
                    &before_formatting = %&read_number%;
                    
                    // Figure out the Formatting Rules to pass to xFormatNumber
                    if(true);
                        // Figure out the Decimal Places to include in the Result (if any)
                        if(true);
                            &format_precision = "0";
                            if(%&opt_format% != "INTEGER");
                                &format_precision = "";
                                #precision_index  = indexof(&valid_formatting_vars[],,"&opt_precision");
                                custom_precision  = %valid_formatting_custom_input[%#precision_index%]%;
                                if(%custom_precision%);
                                    &format_precision = %&opt_precision%;
                                endif;
                            endif;
                        endif;
                        
                        // Figure out the Delimiter to Use in the Result (if any)
                        if(true);
                            if((%&opt_format% != "EXPONENT") && (&opt_format% != "METRIC"));
                                opt_delimiter    := %&opt_delimiter%;
                                #delimiter_index  = indexof(&valid_formatting_vars[],,"&opt_delimiter");
                                custom_delimiter  = %valid_formatting_custom_input[%#delimiter_index%]%;
                                use_delimiter     = ((%custom_delimiter%) || (%opt_delimiter%));
                            endif;
                            exclude_commas = !%use_delimiter%;
                        endif;
                        
                        // Format the Number using xFormatNumber
                        if(true);
                            &before_xformat      = %&read_number%;
                            &formatted_number    = xFormatNumber(%&read_number%,%&format_precision%,false);
                            &pure_number         = replace(&formatted_number,",");
                            debug_log(%debug%,%&script_debug_name%,"Calling &bxFormatNumber&7 on &&read_number ('&5%&before_xformat%&7') returned '&d%&formatted_number%&7' (called &bxFormatNumber&7 with args: precision: '&e%&format_precision%&7', exclude_commas: '&cfalse&7'). Comma Stripped version is '&e%&pure_number%&7'.");
                            if(%&opt_format% == "METRIC");
                                &read_number = convertToMetric(%&pure_number%,-1);
                                debug_log(%debug%,%&script_debug_name%,"Calling &bconvertToMetric&7 on &&pure_number ('&5%&pure_number%&7') returned '&d%&read_number%&7' (called &bconvertToMetric&7 with args: precision: '&e-1&7').");
                            elseif(%use_delimiter%);
                                &read_number = %&formatted_number%;
                                &delim_char  = ",";
                                if(%custom_delimiter%);
                                    &delim_char  = %&opt_delimiter%;
                                    &read_number = replace(&read_number,",",%&delim_char%);
                                endif;
                                debug_log(%debug%,%&script_debug_name%,"Set &&read_number ('&5%&pure_number%&7') to be formatted using delimiter character (&&delim_char: '&e%&delim_char%&7'): '&d%&read_number%&7'.");
                            else;
                                &read_number = %&pure_number%;
                                debug_log(%debug%,%&script_debug_name%,"Set &&read_number ('&5%&read_number%&7') to be stripped of Delimiter Characters.");
                            endif;
                        endif;
                        
                        // If we are only returning sig. figs, do that.
                        if(%&opt_precision% == "SIGNIFICANT");
                            ifmatches(%&read_number%,"^(.*?)\.0*$",&first_portion,1);
                                &read_number = %&first_portion%;
                            endif;
                        endif;
                    endif;
                endif;
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning '&d%&read_number%&7' from input number '&5%&number%&7' (applied opts: format='&e%&opt_format%&7', precision='&e%&opt_precision%&7', rounding='&e%&opt_rounding%&7', delimiter='&e%&opt_delimiter%&7').");
            return(%&read_number%);
        endfunction;
    // math/index/_lte
        // Wrapper that converts A and B to Numbers, then checks for A being <= B.
            // Params:
                // {string} <&a>    First Number to Parse and Compare.
                // {string} <&b>    Second Number to Parse and Compare.
            // Returns a Boolean
            // Example:
                //    less_than_or_equal_to = lte("1M","1000000");
        function _lte(&a,&b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:615
            &a_converted = number(%&a%,"F:FLOAT","P:SIGNIFICANT");
            &b_converted = number(%&b%,"F:FLOAT","P:SIGNIFICANT");
            &diff        = eval("%&a_converted% - %&b_converted%");
            ifmatches(%&diff%,"^-");
                return_boolean = true;
            elseifmatches(%&diff%,"^[0e.]+$");
                return_boolean = true;
            endif;
            return(%return_boolean%);
        endfunction;
    // math/index/_gt
        // Wrapper that converts A and B to Numbers, then checks for A being > B.
            // Params:
                // {string} <&a>    First Number to Parse and Compare.
                // {string} <&b>    Second Number to Parse and Compare.
            // Returns a Boolean
            // Example:
                //    greater_than = gt("1M","1000000");
        function _gt(&a,&b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:572
            equal          = _lte(%&a%,%&b%);
            return_boolean = !%equal%;
            return(%return_boolean%);
        endfunction;
//! @mkb-import-end