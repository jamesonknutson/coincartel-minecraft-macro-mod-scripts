//! @mkb-import-begin
    // gui/index/decodeContainerString
        // Decodes a Container String into an Array of it's components.
            // Params:
            //      {string} <&container_string>    A container string generated by getContainerString
            //
            // Returns an Array:
            //  0 {string} &container_gui   The string value of "%GUI%" from the Container String
            //  1 {string} &container_name  The string value of "%CONTAINERNAME%" from the Container String
            //  2 {number} #container_slots The number value of "%CONTAINERSLOTS%" from the Container String
            //
            // If the Container String holds NBT Item Data, elements 3, ... are the ENCODED NBT strings.
            //
        function decodeContainerString(&container_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:358
            &decoded_string = decode(%&container_string%);
            &decoded_vars[] = split("$",%&decoded_string%);
            #decoded_length = arraysize(&decoded_vars[]);
            
            &decoded_data[] = split("|",%&decoded_vars[0]%);
            if(%#decoded_length% > 1);
                &encoded_nbt[] = split("~",%&decoded_vars[1]%);
                push(&decoded_data[],&encoded_nbt[*]);
            endif;
            return(&decoded_data[]);
        endfunction;
    // gui/index/getContainerString
        // Encodes the current values of GUI, CONTAINERNAME, CONTAINERSLOTS, and optionally Slot Data from each slot in the Container
        // into a string using encode(). Used to check if the GUI has updated.
            // Params:
            //      {boolean} [include_items=false] If true, will call indexGUI and append it's data to the Container String.
            //
            // Returns a string encoded with encode() in format 'GUI|CONTAINERNAME|CONTAINERSLOTS[$<slot_nbt>~<slot_nbt>~<...>]'.
            // The [$<slot_nbt>~<slot_nbt>~<...>] portion is only included if [include_items] is true.
        function getContainerString(include_items=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:274
            &env_var_str = "%GUI%|%CONTAINERNAME%|%CONTAINERSLOTS%";
            if(%include_items%);
                if(%CONTAINERSLOTS% > 0);
                    #container_start = 0;
                    #container_end   = %CONTAINERSLOTS% - 37;
                    #inventory_start = %CONTAINERSLOTS% - 36;
                    #inventory_end   = %CONTAINERSLOTS% - 1;
                    #range_start     = %#container_start%;
                    #range_end       = %#inventory_end%;
                    for(#slot,%#range_start%,%#range_end%);
                        &f_item     = getslotitemnbt(%#slot%,,#f_stack,#f_data,&f_nbt);
                        &f_nbt      = strip(%&f_nbt%);
                        &f_nbt      = encode(%&f_nbt%);
                        &out_data[] = "%&f_item%|%#f_stack%|%#f_data%|%&f_nbt%";
                    next;
                endif;
                &gui_items   = join("~",&out_data[]);
                &env_var_str = "%&env_var_str%$%&gui_items%";
            endif;
            &return_string = encode(%&env_var_str%);
            return(%&return_string%);
        endfunction;
    // gui/index/enteredNewGUI
        // Checks if we are in a new GUI by comparing the <&init_container_string> to the current Container String returned by getContainerString.
            // Params:
            //      {string} <&init_container_string>   A Container String generated when we were on the Initial GUI that we want to check for an Update from.
            //      {boolean} [include_items=false]     Set this to true if [include_items] was used on the Initial call to getContainerString.
            //
            // Returns a boolean indicating whether or not the GUI has changed.
        function enteredNewGUI(&init_container_string,include_items=false,allow_mouse_full=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:304
            &mouse_item = getmouseitem(,#mouse_stack,#mouse_data,&mouse_nbt);
            if((%&mouse_item% != "air") && (!%allow_mouse_full%));
                return(False);
            endif;
            
            &mouse_nbt             = strip(%&mouse_nbt%);
            &mouse_nbt             = encode(%&mouse_nbt%);
            &curr_container_string = getContainerString(%include_items%);
            if(&curr_container_string != &init_container_string);
                if(%include_items%);
                    &init_data[] = call("decodeContainerString",%&init_container_string%);
                    &curr_data[] = call("decodeContainerString",%&curr_container_string%);
                    foreach(&init_data[],&init_data,#dei);
                        &curr_data = %&curr_data[%#dei%]%;
                        if(%&curr_data% != %&init_data%);
                            if(%#dei% <= 2);
                                return_boolean = True;
                                break;
                            else;
                                &init_data_arr[] = split("|",%&init_data%);
                                &init_data_item  = %&init_data_arr[0]%;
                                &init_data_nbt   = %&init_data_arr[3]%;
                                &curr_data_arr[] = split("|",%&curr_data%);
                                &curr_data_item  = %&curr_data_arr[0]%;
                                &curr_data_nbt   = %&curr_data_arr[3]%;
                                mouse_match      = (((%&init_data_item% == "air") && (%&mouse_nbt% == %&curr_data_nbt%)) || ((%&curr_data_item% == "air") && (%&mouse_nbt% == %&init_data_nbt%)));
                                
                                if(!%mouse_match%);
                                    return_boolean = True;
                                    break;
                                endif;
                            endif;
                        endif;
                    next;
                    return(%return_boolean%);
                endif;
                
                return(True);
            endif;
            return(False);
        endfunction;
    // string/index/convertENote
        // Converts a Number formatted in Exponential Notation (e.g. "3.172E10") to standard string decimal form.
            // Params:
                // {string} <&enote_string>    The E. Notation Number string to convert.
                //
            // Returns the Number coerced into a valid decimal float value. If a non-e-notation string is passed,
            // the input string is returned as-is.
        function convertENote(&convert_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:172
            debug              = true;
            &script_debug_name = "&9convertENote&7";
            &convert_string    = replace(&convert_string,",");
            &return_string     = %&convert_string%;
            ifmatches(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$");
                match(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$",{&m_sign_num,&m_leading_num,&m_trailing_num,&m_sign_exponent,&m_exponent_num});
                output_negative   = %&m_sign_num% == "-";
                exponent_negative = %&m_sign_exponent% == "-";
                
                // Convert Scientific Notation to a Real Number
                // Multiply the decimal number by 10 raised to the power indicated.
                // 3.456 x 10^4  = 3.456 x 10,000 = 34560
                // 3.456 x 10^-4 = 3.456 x .0001  = 0.0003456
                //
                
                //    Convert Scientific Notation without a Calculator
                //    We’ve shown you how to convert a number expressed in scientific notation to a decimal by solving,
                //    but this would get more difficult to do manually as the exponent gets larger. There’s an alternate
                //    way to convert to decimal without solving the equation.
                //
                //    If the exponent is positive, move the decimal point in the coefficient to the right one space for each
                //    value in the exponent.
                //
                //    For instance, if the exponent is two, then move the decimal point to the right two spaces. If the exponent
                //    is negative, then move the decimal point to the left.
                //
                //    For example, let’s convert 1.5 × 10^2 to a decimal using this method.
                //
                //    1.5 × 10^2 = 15.0  × 10^1
                //    1.5 × 10^2 = 150.0 × 10^0
                //    1.5 × 10^2 = 150.0
                
                //    For a Positive Exponent (moving decimal point to the right)
                    //    1.396       x    10^6    =    13.96        x 10^5
                    //    13.96       x    10^5    =    139.6        x 10^4
                    //    139.6       x    10^4    =    1396.0       x 10^3
                    //    1396.0      x    10^3    =    13960.0      x 10^2
                    //    13960.0     x    10^2    =    139600.0     x 10^1
                    //    139600.0    x    10^1    =    1396000.0    x 10^0
                    //    1.396       x    10^6    =    1396000.0
                //    For a Negative Exponent (moving decimal point to the left)
                    //    1.396          x    10^-6    = 0.1396         x    10^-5
                    //    0.1396         x    10^-5    = 0.01396        x    10^-4
                    //    0.01396        x    10^-4    = 0.001396       x    10^-3
                    //    0.001396       x    10^-3    = 0.0001396      x    10^-2
                    //    0.0001396      x    10^-2    = 0.00001396     x    10^-1
                    //    0.00001396     x    10^-1    = 0.000001396    x    10^ 0
                    //    0.000001396    x    10^-6    = 0.000001396
                
                #m_exponent_num  := %&m_exponent_num%;
                &m_joint_chars    = "%&m_leading_num%.%&m_trailing_num%";
                &m_joint_chars[]  = split("",%&m_joint_chars%);
                do(%#m_exponent_num%);
                    #m_joint_chars_sz   = arraysize(&m_joint_chars[]);
                    #m_joint_chars_len  = %#m_joint_chars_sz% - 1;
                    #curr_decimal_idx   = indexof(&m_joint_chars[],,".");
                    if(!%exponent_negative%);
                        #next_decimal_idx = %#curr_decimal_idx% + 1;
                        if(%#next_decimal_idx% <= %#m_joint_chars_len%);
                            &m_joint_chars[%#curr_decimal_idx%] = %&m_joint_chars[%#next_decimal_idx%]%;
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        else;
                            &m_joint_chars[%#curr_decimal_idx%] = "0";
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        endif;
                    else;
                        #next_decimal_idx = %#curr_decimal_idx% - 1;
                        if(%#next_decimal_idx% >= 0);
                            &m_joint_chars[%#curr_decimal_idx%] = %&m_joint_chars[%#next_decimal_idx%]%;
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        else;
                            unset(&tmp_joint_chars[]);
                            &m_joint_chars[%#curr_decimal_idx%] = "0";
                            push(&tmp_joint_chars[],".",&m_joint_chars[*]);
                            unset(&m_joint_chars[]);
                            push(&m_joint_chars[],&tmp_joint_chars[*]);
                        endif;
                    endif;
                loop;
                &return_string = join("",&m_joint_chars[]);
                &return_string = regexreplace(&return_string,"\.0*$");
                &return_string = regexreplace(&return_string,"^\.","0.");
                &return_string = "%&m_sign_num%%&return_string%";
            endif;
            return(%&return_string%);
        endfunction;
    // debug/index/debug_log
        // Logs a message to chat if debug is enabled.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_log(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:30
            // &matcher     = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement = "&$1";
            // &string      = regexreplace(&string,%&matcher%,%&replacement%);
            &out_string  = "&7%&script_debug_name%&7: %&string%";
            if(%debug_enabled%);
                log(%&out_string%);
            endif;
            return(%&out_string%);
        endfunction;
    // string/index/xEval
        // Identical to original `eval`, but passes the result of the function along to `convertENote` to ensure decimal values are conserved.
            // Params:
                // {string} <&expression>              The arithmetic expression to evaluate with `eval`.
                // {boolean} [coerce_integer=false]    If true, will attempt to coerce the result of the evaluation from a decimal value into an integer.
            // Returns the result of `eval` passed through `convertENote`, and optionally coerced into an Integer if [coerce_integer] is True.
        function xEval(&expression,coerce_integer=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:276
            debug              = false;
            &script_debug_name = "&9xEval&7";
            debug_log(%debug%,%&script_debug_name%,"evaluating '%&expression%', coerce_integer: %coerce_integer%.");
            &return_string     = eval(%&expression%);
            debug_log(%debug%,%&script_debug_name%,"got result: '&d%&return_string%&7', passing thru convertENote");
            &return_string     = convertENote(%&return_string%);
            debug_log(%debug%,%&script_debug_name%,"convertENote returned: '&d%&return_string%&7'");
            if(%coerce_integer%);
                debug_log(%debug%,%&script_debug_name%,"coercing '&d%&return_string%&7' to a number");
                &return_string = formatnumber(%&return_string%,0,true);
            endif;
            debug_log(%debug%,%&script_debug_name%,"returning '&d%&return_string%&7'");
            return(%&return_string%);
        endfunction;
    // misc/index/miscValidate
        // Validates that <&search_term> is found in the <&array[]>, and/or if it is not found in the <&array[]>, the value of the element
        // found at [#default_idx=0] is returned. Set [#default_idx] to -1 to indicate that no default value should be used.
            // Params:
            //      {array} <&elements[]>       The Array to search for <&search_term> in.
            //      {string} <&search_term>     The Search Term to check if exists in <&elements[]>.
            //      {number} [#default_idx=0]   The Index of the Element in <&elements[]> to use as the default return value
            //                                  if <&search_term> is not found within the Array. If -1, will be taken as no default
            //                                  value should be used.
            //
            // Returns the element from the <&elements[]> Array that <&search_term> matches, or if no match was found and [#default_idx]
            // is not -1, the element at [#default_idx] in the <&elements[]> Array. If [#default_idx] is -1, an empty string is returned.
        function miscValidate(&search_term,#default_idx=0,...&elements[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/index.txt:12
            #term_index = indexof(&elements[],,%&search_term%);
            if(%#term_index% != -1);
                &return_string = %&elements[%#term_index%]%;
            elseif(%#default_idx% != -1);
                &return_string = %&elements[%#default_idx%]%;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/coerceNumber
        // Coerces an input number string into a valid integer. The input number string can be in E Notation, or contain
        // commas, or contain decimal values, or any mix of the above.
            // Params:
                // {string} <&number_string>                The Number String to Convert into a valid Integer.
                // {string} [&rounding_strategy="ROUND"]    String ENUM that dictates how to handle decimal values. Valid values are:
                //                                          FLOOR (towards negative infinity), CEILING|CEIL (towards positive infinity),
                //                                          TRUNCATE|TRUNC (rounds up or down towards 0), ROUND (towards nearest integer).
                //                                          Defaults to ROUND if omitted or an invalid input is provided.
            // Returns the Number coerced into a valid Integer (real-integer type, not string type. If the input string is not
            // coercable at all, 0 will be returned). If the final value before coercion to integer contains decimals, the coerced value
            // will be rounded according to the [&rounding_strategy] parameter.
            // Example:
                //    Converting a comma split, float string into an Integer
                    //    &number_string     = "100,000.9171";
                    //    &rounding_strategy = "ROUND";
                    //    #number_integer    = coerceNumber(%&number_string%,%&rounding_strategy%);
                    //    log("#number_integer: %#number_integer%"); // '#number_integer: 100001'
                //    Replace the content in the Parameters as needed:
                    //    &number_string     = "Can contain commas, decimals, e. notation, or mix of all three.";
                    //    &rounding_strategy = "One of: FLOOR, CEILING|CEIL, TRUNCATE|TRUNC, ROUND, or empty string.";
                    //    #number_integer    = coerceNumber(%&number_string%,%&rounding_strategy%);
        function coerceNumber(&number_string,&rounding_strategy="ROUND");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:343
            &number_string = replace(&number_string,",");
            &number_string = convertENote(%&number_string%);
            ifcontains(%&number_string%,".");
                &rounding_strategy = miscValidate(%&rounding_strategy%,0,"ROUND","FLOOR","CEILING","CEIL","TRUNCATE","TRUNC");
                if(%&rounding_strategy% == "ROUND");
                    // Round the decimal value to the nearest integer.
                    &return_string = formatnumber(%&number_string%,0,true);
                elseif((%&rounding_strategy% == "TRUNCATE") || (%&rounding_strategy% == "TRUNC"));
                    // Exclude the decimal value entirely.
                    &return_string = regexreplace(&number_string,"\.\d*$");
                else;
                    // Use xEval to evaluate the number_string with the corresponding rounding_term. Instruct
                    // xEval to coerce the value into an integer for us, so any trailing ".0" is stripped from it's
                    // return value.
                    if((%&rounding_strategy% == "CEILING") || (%&rounding_strategy% == "CEIL"));
                        &rounding_term = "ceil";
                    elseif(%&rounding_strategy% == "FLOOR");
                        &rounding_term = "floor";
                    endif;
                    &return_string = xEval("%&rounding_term%(%&number_string%)",true);
                endif;
            else;
                // The Number does not contain a decimal value to begin with, return as usual.
                &return_string = %&number_string%;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/stringToNumber
        // Coerces a given String to a Number (no decimal points).
            // Params:
                // {string} <&convert_string>    The String to Convert.
                // {number} [#precision=0]       Decimal Precision
            // Returns the Number result of the coercion.
        function stringToNumber(&convert_string,#precision=0);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:113
            #convert_number = coerceNumber(%&convert_string%);
            return(%#convert_number%);
        endfunction;
    // string/index/isStringFormattedNumber
        // Checks if a String is a valid Float/Number (with commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Formatted Number.
        function isStringFormattedNumber(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:80
            ifmatches(%&check_string%,"^[\d-]+,[\d.,-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
    // string/index/isStringInteger
        // Checks if a String is a valid Integer.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Integer.
        function isStringInteger(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:58
            ifmatches(%&check_string%,"^[0-9-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
    // string/index/isStringFloat
        // Checks if a String is a valid Float (without commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringFloat(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:69
            ifmatches(%&check_string%,"^[0-9-]*\.[0-9]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
    // string/index/isStringNumber
        // Checks if a String is a valid Number, coercable to a Float of some sort.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringNumber(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:91
            &call_functions[] = split(", ","isStringInteger, isStringFloat, isStringFormattedNumber");
            foreach(&call_functions[],&call_function,#cfi);
                if(%&call_function% == "isStringInteger");
                    return_boolean = isStringInteger(%&check_string%);
                elseif(%&call_function% == "isStringFloat");
                    return_boolean = isStringFloat(%&check_string%);
                elseif(%&call_function% == "isStringFormattedNumber");
                    return_boolean = isStringFormattedNumber(%&check_string%);
                endif;
                if(%return_boolean%);
                    break;
                endif;
            next;
            return(%return_boolean%);
        endfunction;
    // info/index/getDatamapItemIndex
        // Given a Search Term (an entry from: sb_datamap_item_names, sb_datamap_item_sbids, or it's Index), looks up the Search Term in the aforementioned Arrays
        // until it finds the Index for the Item.
            // Params:
                // {string} <&search_term>    The Search Term to Search for. Should be the Index, SBID, or Default Display Name.
                //
            // Returns the Index where the Item can be found in the sb_datamap_item_ Arrays, or -1 if it could not be found.
        function getDatamapItemIndex(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:978
            #return_number   = -1;
            &search_arrays[] = split(", ","names, sbids");
            &search_prefix   = "@&sb_datamap_item_";
            foreach(&search_arrays[],&search_array_suffix,#sasi);
                &search_array = "%&search_prefix%%&search_array_suffix%[]";
                #search_index = indexof(%&search_array%,,%&search_term%);
                if(%#search_index% != -1);
                    #return_number = %#search_index%;
                    break;
                endif;
            next;
            if(%#return_number% == -1);
                is_number = isStringNumber(%&search_term%);
                if(%is_number%);
                    #index_number             = stringToNumber(%&search_term%);
                    #sb_datamap_item_names_sz = arraysize(@&sb_datamap_item_names[]);
                    #sb_datamap_item_names_sz = %#sb_datamap_item_names_sz% -1;
                    if((%#index_number% >= 0) && (%#index_number% <= %#sb_datamap_item_names_sz%));
                        #return_number = %#index_number%;
                    endif;
                endif;
            endif;
            return(%#return_number%);
        endfunction;
    // info/index/_matchExpressionNBT
        // Used by getItemName, getItemUUID, getItemSBID to extract a regular expression capture group from NBT Data.
            // Params:
            //      {string} <&haystack>    The string to extract the first capture group from.
            //      {string} <&expression>  The expression to test against <&haystack>, must have at least one capture group.
            //
            // Returns the first capture group's content from the <&expression> match, or an empty string if no match is found.
        function _matchExpressionNBT(&haystack,&expr);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:34
            &return_string = "";
            ifmatches(%&haystack%,%&expr%,&capture_group,1);
                &return_string = %&capture_group%;
            endif;
            return(%&return_string%);
        endfunction;
    // info/index/getItemSBID
        // Given the NBT Data of an Item, extracts the Item's SBID from the NBT Data.
            // Params:
            //      {string} <&nbt> The NBT Data to extract the Item SBID from.
            //
            // Returns the Item's SBID, or an empty string if one is not found.
        function getItemSBID(&nbt);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:103
            &nbt           = strip(%&nbt%);
            &return_string = _matchExpressionNBT(%&nbt%,"\bid\"?\s*:\"([A-Z_0-9:]+)\"");
            return(%&return_string%);
        endfunction;
    // gui/getRoom/getStackRoomInventory
        // Calculates the amount of Room available for <&search_term> in the Inventory.
            // Params:
                // {string} <&search_term>    The Item's Default Display Name or SBID. Must be findable in the @&sb_datamap_item_... arrays.
                //
            // Returns the Integer amount of Room we have available for the <&search_term> in the Inventory. If <&search_term> cannot be resolved,
            // the default return value is always 0.
        function getStackRoomInventory(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/getRoom.txt:6
            #return_number = 0;
            #datamap_index = getDatamapItemIndex(%&search_term%);
            if(%#datamap_index% != -1);
                &r_json      = %@&sb_datamap_item_jsons[%#datamap_index%]%;
                #r_max_stack = jsonget("maxStack",%&r_json%);
                
                // Iterate over Static Inventory Slots
                if(true);
                    #r_start  = 9;
                    #r_end    = 43;
                    &r_item   = %@&sb_datamap_item_mcids[%#datamap_index%]%;
                    &r_sbid   = %@&sb_datamap_item_sbids[%#datamap_index%]%;
                    for(#r_slot,%#r_start%,%#r_end%);
                        #f_slot = %#r_slot%;
                        if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                            #r_offset = %#f_slot% + 1;
                            &f_item   = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                            if(%&f_item% == "air");
                                #return_number = %#return_number% + %#r_max_stack%;
                            else;
                                &f_nbt    = strip(%&f_nbt%);
                                &f_sbid   = getItemSBID(%&f_nbt%);
                                m_item    = ((!%&r_item%) || (%&r_item% == %&f_item%));
                                m_name    = ((!%&r_name%) || (%&r_name% == %&f_name%));
                                m_sbid    = ((!%&r_sbid%) || (%&r_sbid% == %&f_sbid%));
                                m_match   = ((%m_item%) && (%m_name%) && (%m_sbid%));
                                if(%m_match%);
                                    #stack_room    = %#r_max_stack% - %#f_stack%;
                                    #return_number = %#return_number% + %#stack_room%;
                                endif;
                            endif;
                        else;
                            break;
                        endif;
                    next;
                endif;
            endif;
            return(%#return_number%);
        endfunction;
    // gui/index/invslot_to_conslot
        // Takes input of a getslotiteminv indexed inventory slot (static, starts at 9 for top left inv, ends @ 44 bottom right inv)
        // and converts it to it's dynamic position in whatever GUI is currently opened.
            // Params:
            //      {number} <#slot>    The getslotiteminv indexed inventory slot to convert
            //
            // Returns <#slot>'s dynamic slot ID in whichever container is currently opened, or -1 if no container with CONTAINERSLOTS is opened.
        function invslot_to_conslot(#slot);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:62
            if(%CONTAINERSLOTS% >= 1);
                #conslot = (%CONTAINERSLOTS% - 45) + %#slot%;
                return(%#conslot%);
            else;
                return(-1);
            endif;
        endfunction;
    // info/index/getItemName
        // Given the NBT Data of an Item (and optionally it's base item), extracts the Display Name of the Item from the NBT Data.
            // Params:
            //      {string} <&nbt>         The NBT Data to extract the Name from.
            //      {string} [&item="air"]  The Item this NBT Data was collected from (only used in cases where the Item's Name cannot be found).
            //      {boolean} [strip=true]  Whether or not to strip formatting codes from the extracted Name.
            //
            // Returns the Display Name of the Item found from it's NBT Data, with formatting codes stripped if [strip] is true.
        function getItemName(&nbt,&item="air",strip=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:49
            ifmatches(%&nbt%,".*\bName\s*:\"\s*(.*?)\"",&found_name,1);
                if(%strip%);
                    &found_name = strip(%&found_name%);
                endif;
            elseif(%&item% == "air");
                &found_name = "Air";
            endif;
            return(%&found_name%);
        endfunction;
    // gui/containerLog/containerLog
                // {boolean} [append=false]            Whether or not to append the Data to the specified file.
                // {string} [...&context_strings[]]    Optional strings that will prepend the Container Data in the logged file.
                //
            // Returns the Path to the File where the Data was logged to.
        function containerLog(&log_path,append=false,...&context_strings[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/containerLog.txt:8
            if(!%&log_path%);
                &log_path = "~liteconfig/common/macros/logs/%TIMESTAMP%-containerNbt.txt";
            endif;
            
            &log_strings[] = "--- Begin Metadata ---";
            &log_strings[] = "";
            &log_strings[] = "Generation Time: %DATETIME%";
            &log_strings[] = "GUI: %GUI%";
            &log_strings[] = "CONTAINERSLOTS: %CONTAINERSLOTS%";
            &log_strings[] = "CONTAINERNAME: %CONTAINERNAME%";
            &log_strings[] = "";
            
            #context_strings_sz = arraysize(&context_strings[]);
            if(%#context_strings_sz%);
                &log_strings[] = "--- Begin Context Strings ---";
                &log_strings[] = "";
                push(&log_strings[],&context_strings[*]);
                &log_strings[] = "";
            endif;
            
            // Iterate over Static Inventory Slots
            if(true);
                &log_strings[] = "--- Begin Inventory ---";
                &log_strings[] = "";
                #r_start       = 9;
                #r_end         = 44;
                for(#f_slot,%#r_start%,%#r_end%);
                    &f_item        = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                    &f_nbt         = strip(%&f_nbt%);
                    &f_name        = getItemName(%&f_nbt%,%&f_item%);
                    &f_sbid        = getItemSBID(%&f_nbt%);
                    #c_slot        = invslot_to_conslot(%#f_slot%);
                    &log_strings[] = "Container Slot: %#c_slot% | Static Inventory Slot: %#f_slot%";
                    &log_strings[] = "MCID: %&f_item%:%#f_data%";
                    &log_strings[] = "Stack: %#f_stack%";
                    &log_strings[] = "Name: %&f_name%";
                    &log_strings[] = "SBID: %&f_sbid%";
                    &log_strings[] = "NBT: %&f_nbt%";
                    &log_strings[] = "";
                next;
            endif;
            
            // Iterate over Dynamic Container Slots
            if(%CONTAINERSLOTS%);
                &log_strings[] = "--- Begin Container ---";
                &log_strings[] = "";
                #r_start  = 0;
                #r_end    = %CONTAINERSLOTS% - 37;
                for(#f_slot,%#r_start%,%#r_end%);
                    &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                    &f_nbt    = strip(%&f_nbt%);
                    &f_name   = getItemName(%&f_nbt%,%&f_item%);
                    &f_sbid   = getItemSBID(%&f_nbt%);
                    &log_strings[] = "Container Slot: %#c_slot% | Static Inventory Slot: %#f_slot%";
                    &log_strings[] = "MCID: %&f_item%:%#f_data%";
                    &log_strings[] = "Stack: %#f_stack%";
                    &log_strings[] = "Name: %&f_name%";
                    &log_strings[] = "SBID: %&f_sbid%";
                    &log_strings[] = "NBT: %&f_nbt%";
                    &log_strings[] = "";
                next;
            endif;
            
            &file_path = writefile(%&log_path%,&log_strings[],%append%);
        endfunction;
    // info/index/getItemUUID
        // Given the NBT Data of an Item, extracts the Item's UUID from the NBT Data.
            // Params:
            //      {string} <&nbt> The NBT Data to extract the Item UUID from.
            //
            // Returns the Item's UUID, or an empty string if one is not found.
        function getItemUUID(&nbt);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:92
            &nbt           = strip(%&nbt%);
            &return_string = _matchExpressionNBT(%&nbt%,"uuid:\"(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})\"");
            return(%&return_string%);
        endfunction;
    // string/index/regexEscape
        // string/index.txt
        // Counts occurences of a given string within another string.
            // Params:
            //        <string> &source_string : The string to count occurences of &search_string in.
            //        <string> &search_string : The string to count occurences of.
            //
            // Returns the integer amount of occurences found.
        function countOccurencesInString(&source_string,&search_string);
            &script_debug_name  = "&9countOccurencesInString&7";
            debug               = false;
            ifcontains(%&source_string%,%&search_string%);
                &split_source_arr[] = split(%&search_string%,%&source_string%);
                #occurences         = arraysize(&split_source_arr[]);
                if(%#occurences% == 0); // source string exclusively held repetitions of the search string
                    #source_length = strlen(%&source_string%);
                    #search_length = strlen(%&search_string%);
                    #occurences    = %#source_length% / %#search_length%;
                endif;
            endif;
            return(%#occurences%);
        endfunction;
        
        // Checks if a string matches UUID regex.
            // Params:
            //        <string> &check_string : The string to check
            //
            // Returns a boolean.
            //
        function isStringUUID(&check_string);
            &script_debug_name = "&9isStringUUID&7";
            debug              = false;
            &split_uuid_expr   = "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$";
            &joint_uuid_expr   = "^[a-f0-9]{32}$";
            &uuid_exprs[]      = split(", ","%&split_uuid_expr%, %&joint_uuid_expr%");
            foreach(&uuid_exprs[],&uuid_expr);
                ifmatches(%&check_string%,%&uuid_expr%);
                    match_found = true;
                    break;
                endif;
            next;
            return(%match_found%);
        endfunction;
        
        // Checks if a string matches Boolean regex
            // Params:
                // {string} <&check_string>    The String to Check
            // Returns a Boolean
        function isStringBoolean(&check_string);
            &check_string_lcase = lcase(%&check_string%);
            &boolean_values[]   = split(", ","true, false, 1, 0");
            return_boolean      = arrayincludes(&boolean_values[],%&check_string_lcase%);
            return(%return_boolean%);
        endfunction;
        
        // Checks if a String is a valid Integer.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Integer.
        function isStringInteger(&check_string);
            ifmatches(%&check_string%,"^[0-9-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
        
        // Checks if a String is a valid Float (without commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringFloat(&check_string);
            ifmatches(%&check_string%,"^[0-9-]*\.[0-9]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
        
        // Checks if a String is a valid Float/Number (with commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Formatted Number.
        function isStringFormattedNumber(&check_string);
            ifmatches(%&check_string%,"^[\d-]+,[\d.,-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
        
        // Checks if a String is a valid Number, coercable to a Float of some sort.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringNumber(&check_string);
            &call_functions[] = split(", ","isStringInteger, isStringFloat, isStringFormattedNumber");
            foreach(&call_functions[],&call_function,#cfi);
                if(%&call_function% == "isStringInteger");
                    return_boolean = isStringInteger(%&check_string%);
                elseif(%&call_function% == "isStringFloat");
                    return_boolean = isStringFloat(%&check_string%);
                elseif(%&call_function% == "isStringFormattedNumber");
                    return_boolean = isStringFormattedNumber(%&check_string%);
                endif;
                if(%return_boolean%);
                    break;
                endif;
            next;
            return(%return_boolean%);
        endfunction;
        
        // Coerces a given String to a Number (no decimal points).
            // Params:
                // {string} <&convert_string>    The String to Convert.
                // {number} [#precision=0]       Decimal Precision
            // Returns the Number result of the coercion.
        function stringToNumber(&convert_string,#precision=0);
            #convert_number = coerceNumber(%&convert_string%);
            return(%#convert_number%);
        endfunction;
        
        function isStringBoolean(&check_string);
            if(%&check_string% == "");
                return_boolean = true;
            else;
                &boolean_coercable[] = split(", ","0, 1, true, false, True, False");
                #boolean_index       = indexof(&boolean_coercable[],,%&check_string%);
                return_boolean       = %#boolean_index% != -1;
            endif;
            return(%return_boolean%);
        endfunction;
        
        function stringToBoolean(&convert_string);
            is_coercable = isStringBoolean(%&convert_string%);
            if(%is_coercable%);
                return_boolean := %&convert_string%;
            elseifmatches(%&convert_string%,"\S");
                return_boolean  = true;
            else;
                return_boolean  = false;
            endif;
            return(%return_boolean%);
        endfunction;
        
        function regexEscape(&input_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:141
            &split_array[]  = split("\\",%&input_string%);
            foreach(&split_array[],&curr_char,#curr_index);
                if(%&curr_char% == "\\");
                    #last_index = #curr_index - 1;
                    #next_index = #curr_index + 1;
                    &last_char  = %&split_array[%#last_index%]%;
                    &next_char  = %&split_array[%#next_index%]%;
                    
                    // If this backslash is escaped already (last char == '\'), then we do not need to escape this char.
                    // If the backslash is escaping another backslash (next char == '\'), then we do not need to escape this char.
                    if((%&last_char% != "\\") && (%&next_char% != "\\"));
                        &rejoin_array[] = "\\";
                    endif;
                    &rejoin_array[] = %&curr_char%;
                else;
                    &rejoin_array[] = %&curr_char%;
                endif;
            next;
            &rejoint_string = join("",&rejoin_array[]);
            &search_string  = "(?<!\\\\)(?:\+|\*|\?|\^|\$|\.|\[|\]|\{|\}|\(|\)|\||\/)";
            &escaped_string = regexreplace(&rejoint_string,%&search_string%,"\\\$0");
            return(%&escaped_string%);
        endfunction;
    // gui/index/findItemContainer
        // Given any (or all, or any mix of) an Item's MCID, Name, SBID, and/or UUID, finds the Item in the Container and returns it's Slot.
            // Params:
                // {string} [...&filter_params[]]    An Array of Strings in format: [<PARAM_ENUM>: <FILTER>], where PARAM_ENUM can be any of:
                //                                   MCID|ITEM, DATA, STACK, NAME, SBID, NBT, or UUID. <FILTER> can be a Regular Expression or an Exact String.
                //                                   If Passing an Expression, prefix the Filter with 'r$'. All characters following the 'r$' will be used
                //                                   as the Expression.
                // {boolean} [return_arr=false]      If set to True, will return an Array of Slots matching the specified Filters. If set to False, will
                //                                   return the first Slot ID found that matches the Filters.
            // Returns the Slot ID(s) of the Item(s) found, or -1 if no Item(s) could be found. Will return -1 if CONTAINERSLOTS <= 0.
        function findItemContainer(return_arr=false,...&filter_params[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:1092
            #return_val = -1;
            
            // Setup Filter Parameters
            if(true);
                &valid_enums[] = split(", ","MCID, ITEM, DATA, STACK, NAME, SBID, UUID, NBT, SLOT");
                foreach(&filter_params[],&filter_param,#fpi);
                    ifmatches(%&filter_param%,"^(.+?):\s*(.+)$");
                        match(%&filter_param%,"^(.+?):\s*(.+)$",{&param_enum,&param_filter});
                        #enum_index = indexof(&valid_enums[],,%&param_enum%);
                        if(%#enum_index% != -1);
                            &param_enum = %&valid_enums[%#enum_index%]%;
                            if(%&param_enum% == "SLOT");
                                #prioritize_slot   = coerceNumber(%&param_filter%);
                                #prioritized_index = indexof(#prioritized_slots[],,%#prioritize_slot%);
                                if(%#prioritized_index% == -1);
                                    #prioritized_slots[] = %#prioritize_slot%;
                                endif;
                            else;
                                if(%&param_enum% == "ITEM");
                                    &param_enum = "MCID";
                                endif;
                                
                                ifmatches(%&param_filter%,"^r\$(.+)",&param_expression,1);
                                    &param_filter = %&param_expression%;
                                else;
                                    &param_filter = regexEscape(%&param_filter%);
                                    &param_filter = "^%&param_filter%$";
                                endif;
                                
                                &enum_array = lcase("&%&param_enum%_regex[]");
                                &enum_bool  = lcase("do_%&param_enum%");
                                push(%&enum_array%,%&param_filter%);
                                set(%&enum_bool%);
                            endif;
                        endif;
                    endif;
                next;
                
                foreach(&valid_enums[],&valid_enum);
                    if((%&valid_enum% != "SLOT") && (&valid_enum% != "ITEM"));
                        &enum_bool = lcase("do_%&valid_enum%");
                        enum_bool := "%%&enum_bool%%";
                        if(%enum_bool%);
                            &enum_array = lcase("&%&valid_enum%_regex[]");
                            &enum_value = join("|",%&enum_array%);
                            &enum_value = "(?:%&enum_value%)";
                            &enum_regex = lcase("&%&valid_enum%_regex");
                            set(%&enum_regex%,%&enum_value%);
                        endif;
                    endif;
                next;
                
                //    Array Name        |    Boolean Name    |    Regex String
                //    &mcid_regex[]     |    do_mcid         |    &mcid_regex
                //    &data_regex[]     |    do_data         |    &data_regex
                //    &stack_regex[]    |    do_stack        |    &stack_regex
                //    &name_regex[]     |    do_name         |    &name_regex
                //    &sbid_regex[]     |    do_sbid         |    &sbid_regex
                //    &uuid_regex[]     |    do_uuid         |    &uuid_regex
                //    &nbt_regex[]      |    do_nbt          |    &nbt_regex
            endif;
            
            // Iterate over Inventory Slots
            if(%CONTAINERSLOTS% >= 1);
                #r_start            = 0;
                #r_end              = %CONTAINERSLOTS% - 37;
                &r_filter[]         = split(", ","mcid, data, stack, name, sbid, uuid, nbt");
                
                #prioritize_slot_sz = arraysize(#prioritize_slot[]);
                if(%#prioritize_slot_sz% >= 1);
                    foreach(#prioritize_slot[],#prioritize_slot,#ps);
                        &f_mcid = getslotitemnbt(%#prioritize_slot%,,&f_stack,&f_data,&f_nbt);
                        &f_nbt  = strip(%&f_nbt%);
                        f_valid = true;
                        foreach(&r_filter[],&r_term,#rti);
                            &f_bool  = "do_%&r_term%";
                            f_bool  := "%%&f_bool%%";
                            if(%f_bool%);
                                if(%#rti% >= 3);
                                    if(%&r_term% == "name");
                                        &f_value = getItemName(%&f_nbt%,%&f_mcid%);
                                    elseif(%&r_term% == "sbid");
                                        &f_value = getItemSBID(%&f_nbt%);
                                    elseif(%&r_term% == "uuid");
                                        &f_value = getItemUUID(%&f_nbt%);
                                    elseif(%&r_term% == "nbt");
                                        &f_value = %&f_nbt%;
                                    endif;
                                else;
                                    &f_value = "&f_%&r_term%";
                                    &f_value = "%%&f_value%%";
                                endif;
                                &f_regex = "&%&r_term%_regex";
                                &f_regex = "%%&f_regex%%";
                                ifnotmatches(%&f_value%,%&f_regex%);
                                    // log("Term %&r_term% > No match between value %&f_value% and expression %&f_regex%");
                                    f_valid = false;
                                    break;
                                endif;
                            endif;
                        next;
                        
                        if(%f_valid%);
                            if(!%return_arr%);
                                #return_val = %#f_slot%;
                                break;
                            endif;
                            #return_val[] = %#f_slot%;
                        endif;
                    next;
                endif;
                for(#f_slot,%#r_start%,%#r_end%);
                    &f_mcid = getslotitemnbt(%#f_slot%,,&f_stack,&f_data,&f_nbt);
                    &f_nbt  = strip(%&f_nbt%);
                    f_valid = true;
                    foreach(&r_filter[],&r_term,#rti);
                        &f_bool  = "do_%&r_term%";
                        f_bool  := "%%&f_bool%%";
                        if(%f_bool%);
                            if(%#rti% >= 3);
                                if(%&r_term% == "name");
                                    &f_value = getItemName(%&f_nbt%,%&f_mcid%);
                                elseif(%&r_term% == "sbid");
                                    &f_value = getItemSBID(%&f_nbt%);
                                elseif(%&r_term% == "uuid");
                                    &f_value = getItemUUID(%&f_nbt%);
                                elseif(%&r_term% == "nbt");
                                    &f_value = %&f_nbt%;
                                endif;
                            else;
                                &f_value = "&f_%&r_term%";
                                &f_value = "%%&f_value%%";
                            endif;
                            &f_regex = "&%&r_term%_regex";
                            &f_regex = "%%&f_regex%%";
                            ifnotmatches(%&f_value%,%&f_regex%);
                                // log("Term %&r_term% > No match between value %&f_value% and expression %&f_regex%");
                                f_valid = false;
                                break;
                            endif;
                        endif;
                    next;
                    
                    if(%f_valid%);
                        if(!%return_arr%);
                            #return_val = %#f_slot%;
                            break;
                        elseif(%#prioritize_slot_sz% <= 0);
                            #return_val[] = %#f_slot%;
                        else;
                            #return_index = indexof(#return_val[],,%#f_slot%);
                            if(%#return_index% == -1);
                                #return_val[] = %#f_slot%;
                            endif;
                        endif;
                    endif;
                next;
            endif;
            
            if(%return_arr%);
                #return_val_sz = arraysize(#return_val[]);
                if(%#return_val_sz% == 0);
                    #return_val[] = -1;
                endif;
                return(#return_val[]);
            endif;
            return(%#return_val%);
        endfunction;
    // misc/index/canDoInteraction
        // Checks if we can 'do' an Interaction by determining whether we have waited a whole amount of <#ticks_per_action> in <#waited_ticks>.
        // Basically a modulo operation. If return True, execute Action. If not, skip action and keep waiting.
            // Params:
                // {number} [#waited_ticks=0]    Amount of Ticks that have been waited thus far
                // {number} [#tick_wait=20]      Ticks to wait in between actions
            // Returns a Boolean
            // Example:
                //    can_do_action = canDoInteraction(%#waited_ticks%,%#tick_wait%);
        function canDoInteraction(#waited_ticks=0,#tick_wait=20);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/index.txt:43
            #actions_done  = %#waited_ticks% / %#tick_wait%;
            #ticks_to_next = %#waited_ticks% - (%#actions_done% * %#tick_wait%);
            can_do_action  = %#ticks_to_next% == 0;
            return(%can_do_action%);
        endfunction;
    // debug/index/debug_error
        // Logs a message to chat with an error prefix.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_error(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:49
            // &matcher       = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement   = "&$1";
            // &string        = regexreplace(&string,%&matcher%,%&replacement%);
            &error_message = "&4Error > &c%&string%";
            &error_message = regexreplace(&error_message,"&7","&c");
            &error_message = "&7%&script_debug_name%&7: %&error_message%";
            if(%debug_enabled%);
                log(%&error_message%);
            endif;
            return(%&error_message%);
        endfunction;
    // info/index/hasTimeExceeded
        // Used to determine whether to timeout a function.
            // Params:
                // {number} <#start_time>        The start timestamp to subtract from current timestamp
                // {number} <#timeout_sec>       The amount of seconds to check if difference between now & start is >=.
                // {number} [do_timeout=true]    If false, will always return false (used as shorthand for functions that
                //                               use this function to determine whether or not they have timed out).
            // Returns a boolean indicating whether or not <#start_timestamp> was >= <#seconds> ago.
            // Example:
                //    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
        function hasTimeExceeded(#start_time,#timeout_sec,do_timeout=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:10
            #elapsed_sec   = %TIMESTAMP% - #start_time;
            return_boolean = ((%do_timeout%) && (#elapsed_sec >= #timeout_sec));
            return(%return_boolean%);
        endfunction;
    // info/index/isInLimbo
        // Checks if the Player is in Limbo by reading the Dimension, as well as checking to see if there are any signs at the sign positions
        // where they normally are in Limbo.
            // Params:
            //      None
            //
            // Returns a boolean indicating whether or not the Player is in Limbo.
        function isInLimbo();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:475
            if((%YPOS% > 35) || (%DIMENSION% != "END"));
                return(False);
            endif;
            
            #limbo_x = -20;
            #limbo_y = 32;
            #limbo_z = 21;
            
            if((%XPOS% == #limbo_x) && (%YPOS% == #limbo_y) && (%ZPOS% == #limbo_z));
                return(True);
            endif;
            
            &armor_vars[] = split(", ","ITEM, BOOTSID, LEGGINGSID, CHESTPLATEID, HELMID");
            all_air       = true;
            foreach(&armor_vars[],&armor_var);
                &armor_val = "%%&armor_var%%";
                if(%&armor_val% != "air");
                    all_air = false;
                    break;
                endif;
            next;
            if((%SLOTSFULL% == 0) && (%all_air%));
                return(True);
            endif;
            
            #sign_x   = -21;
            #sign_y[] = split(", ","31, 32, 33");
            #sign_z[] = split(", ","20, 21, 22");
            foreach(#sign_y[],#sign_y);
                foreach(#sign_z[],#sign_z);
                    &block_id = getid(%#sign_x%,%#sign_y%,%#sign_z%);
                    if(&block_id == "wall_sign");
                        in_limbo = true;
                        break;
                    endif;
                next;
            next;
        endfunction;
    // info/index/getHypixelGamemodeFromScoreboard
        // Attempts to read the Scoreboard (foreach("teams") ... prefix + suffix ... next) to find the Player's location on Hypixel
            // Params:
            //      None
            //
            // Returns one of the following strings: 'LOBBY', 'SKYBLOCK', or 'OTHER'. 'OTHER' indicates that the function
            // was not able to determine which area the Player is located in.
        function getHypixelGamemodeFromScoreboard();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:382
            &return_string = "OTHER";
            
            // Setup indicator strings
            if(true);
                &match_expr[] = "Games in this lobby are"; // Only shown in Prototype Lobby Servers
                &match_area[] = "LOBBY";
                
                &match_expr[] = "^Achievements: .+$"; // Only shown in Hypixel Main Lobby Servers
                &match_area[] = "LOBBY";
                
                &match_expr[] = "^Purse: [0-9,.]+"; // Only shown in SkyBlock Servers
                &match_area[] = "SKYBLOCK";
                
                &match_expr[] = "^Bits: [0-9,.]+"; // Only shown in SkyBlock Servers
                &match_area[] = "SKYBLOCK";
            endif;
            
            foreach("teams");
                &joint_team = strip("%TEAMPREFIX%%TEAMSUFFIX%");
                &joint_team = trim(%&joint_team%);
                &joint_team = regexreplace(&joint_team,"^\s*","");
                foreach(&match_expr[],&match_expr,#mei);
                    ifmatches(%&joint_team%,%&match_expr%);
                        &return_string = %&match_area[%#mei%]%;
                        break;
                    endif;
                next;
            next;
            
            return(%&return_string%);
        endfunction;
    // info/index/getSkyBlockPlayerListInfo
        // Returns an Array of information extracted from the Hypixel SkyBlock PlayerList.
            // Params:
            //      {string} [...&extract_vars[]]   The variables to extract from the Player List. Valid values are:
            //                                      'AREA', 'SERVER', 'PROFILE', 'BANK', 'SKILLS', 'SPEED', 'STRENGTH',
            //                                      'CRIT_CHANCE', 'CRIT_DAMAGE', 'ATTACK_SPEED'. If no values are provided,
            //                                      will return variables 'AREA', and 'PROFILE' by default.
            //
            // Returns an Array of the extracted variables indexed in the order they were passed to the Function,
            // or if no variables were able to be extracted, the first element of this Array will be -1.
        function getSkyBlockPlayerListInfo(...&extract_vars[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:258
            // Setup valid variables
            if(true);
                &valid_vars[]  = split(", ","AREA, SERVER, PROFILE, BANK, SKILLS, SPEED, STRENGTH, CRIT_CHANCE, CRIT_DAMAGE, ATTACK_SPEED");
                #extract_len   = arraysize(&extract_vars[]);
                assign_default = #extract_len == 0;
                if(!%assign_default%);
                    foreach(&valid_vars[],&valid_var);
                        #extract_idx = indexof(&extract_vars[],,%&valid_var%);
                        if(#extract_idx != -1);
                            &use_out_vars[] = %&valid_var%;
                            #use_out_idxs[] = %#extract_idx%;
                            matched[]       = false;
                        endif;
                    next;
                    #use_out_len   = arraysize(&use_out_vars[]);
                    assign_default = #use_out_len == 0;
                endif;
                
                if(!%assign_default%);
                    sort("ASC",#use_out_idxs[],&use_out_vars[]);
                else;
                    &use_out_vars[] = split(", ","AREA, PROFILE");
                    matched[]       = split(", ","false, false");
                endif;
            endif;
            
            // Compile matches
            if(true);
                #return_index = indexof(&use_out_vars[],,"AREA");
                if(#index_area != -1);
                    &match_names[] = "!C-b";
                    &match_exprs[] = "Area: (.+)"; // Area: Private Island
                endif;
                
                #return_index = indexof(&use_out_vars[],,"SERVER");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!C-c";
                    &match_exprs[%#return_index%] = "Server: (.+)"; // Server: mini787Q
                endif;
                
                #return_index = indexof(&use_out_vars[],,"PROFILE");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!D-b";
                    &match_exprs[%#return_index%] = "Profile: (.+)"; // Profile: Pineapple
                endif;
                
                #return_index = indexof(&use_out_vars[],,"BANK");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!D-d";
                    &match_exprs[%#return_index%] = "Bank: (.+)"; // Bank: 50/50
                endif;
                
                #return_index = indexof(&use_out_vars[],,"SKILLS");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!D-g";
                    &match_exprs[%#return_index%] = "Skills: (.+)"; // Skills: Foraging 17: 24.1%
                endif;
                
                #return_index = indexof(&use_out_vars[],,"SPEED");
                if(#return_index != -1);
                    &tmp_expr_char                = char("10022");
                    &match_names[%#return_index%] = "!D-h";
                    &match_exprs[%#return_index%] = "Speed: %&tmp_expr_char%(.+)"; // Speed: ✦220
                endif;
                
                #return_index = indexof(&use_out_vars[],,"STRENGTH");
                if(#return_index != -1);
                    &tmp_expr_char                = char("10049");
                    &match_names[%#return_index%] = "!D-i";
                    &match_exprs[%#return_index%] = "Strength: %&tmp_expr_char%(.+)"; // Strength: ❁149
                endif;
                
                #return_index = indexof(&use_out_vars[],,"CRIT_CHANCE");
                if(#return_index != -1);
                    &tmp_expr_char                = char("9763");
                    &match_names[%#return_index%] = "!D-j";
                    &match_exprs[%#return_index%] = "Crit Chance: %&tmp_expr_char%(.+)"; // Crit Chance: ☣64
                endif;
                
                #return_index  = indexof(&use_out_vars[],,"CRIT_DAMAGE");
                if(#return_index != -1);
                    &tmp_expr_char                = char("9760");
                    &match_names[%#return_index%] = "!D-k";
                    &match_exprs[%#return_index%] = "Crit Damage: %&tmp_expr_char%(.+)"; // Crit Damage: ☠130
                endif;
                
                #return_index  = indexof(&use_out_vars[],,"ATTACK_SPEED");
                if(#return_index != -1);
                    &tmp_expr_char                = char("9876");
                    &match_names[%#return_index%] = "!D-l";
                    &match_exprs[%#return_index%] = "Attack Speed: %&tmp_expr_char%(.+)"; // Attack Speed: ⚔0
                endif;
            endif;
            
            foreach("players");
                #line_index = indexof(&match_names[],,%PLAYERNAME%);
                if(#line_index != -1);
                    matched[%#line_index%] = true;
                    &line_text             = strip(%PLAYERDISPLAYNAME%);
                    &line_text             = trim(%&line_text%);
                    ifmatches(%&line_text%,%&match_exprs[%#line_index%]%,&capture_group,1);
                        &return_array[%#line_index%] = %&capture_group%;
                        #non_matched_var_index       = indexof(matched[],,false);
                        if(#non_matched_var_index == -1);
                            break;
                        endif;
                    endif;
                endif;
            next;
            
            #return_len = arraysize(&return_array[]);
            if(#return_len == 0);
                &return_array[] = -1;
            endif;
            return(&return_array[]);
        endfunction;
    // info/index/getHypixelGamemode
        // Gets the current Gamemode / Gametype that the Player is in by reading the Scoreboard, etc.
        // Params:
        //      None
        //
        // Returns one of: 'LOBBY', 'LIMBO', 'SKYBLOCK', or 'OTHER'.
        function getHypixelGamemode();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:520
            if(true);
                do(3);
                    // Check to see if we can read the Gamemode from the 9th Hotbar Slot.
                    if(true);
                        #static_hb_end = 44;
                        &found_item    = getslotiteminv(%#static_hb_end%,,#found_stack,#found_data,&found_nbt);
                        &found_nbt     = strip(%&found_nbt%);
                        &found_name    = getItemName(%&found_nbt%,%&found_item%);
                        
                        &known_names[] = split(", ","Lobby Selector (Right Click), SkyBlock Menu (Right Click)");
                        &known_areas[] = split(", ","LOBBY, SKYBLOCK");
                        #known_index   = indexof(&known_names[],,%&found_name%);
                        if(%#known_index% != -1);
                            &return_string = %&known_areas[%#known_index%]%;
                            break;
                        endif;
                    endif;
                    
                    // Cant find the Gamemode from the 9th Hotbar Slot, have to read additional Data. Check to see if we can find any Data from the Playerlist.
                    &skyblock_area = getSkyBlockPlayerListInfo("AREA");
                    if(%&skyblock_area% != "-1");
                        &return_string = "SKYBLOCK";
                        break;
                    endif;
                    
                    // Try to read the location from the Scoreboard.
                    &scoreboard_location = getHypixelGamemodeFromScoreboard();
                    if(%&scoreboard_location% != "OTHER");
                        &return_string = %&scoreboard_location%;
                        break;
                    endif;
                    
                    // Check if we are in Limbo as a last resort
                    in_limbo = isInLimbo();
                    if(%in_limbo%);
                        &return_string = "LIMBO";
                        break;
                    endif;
                    
                    wait("1000ms");
                loop;
            endif;
            
            if(%&return_string% != "");
                return(%&return_string%);
            endif;
            return("OTHER");
        endfunction;
    // info/index/getServerID
        // Gets the Current Server ID.
            // REQUIRES CHATFILTER EXPRESSIONS:
                //    elseifmatches(%CHATCLEAN%,"^You are currently (?:connected to server|in) (.+)$",&current_server_id);
                //        @&current_server_id = ucase(%&current_server_id%);
                //        if(%debug%);
                //            log("&7%&script_debug_name%&7: Updated '&e@&&current_server_id&7' to '&d%@&current_server_id%&7'.");
                //        endif;
                //    elseifmatches(%CHATCLEAN%,"^Unknown command. Type \"/help\" for help.$");
                //        @chatfilter_unknown_cmd = true;
            // Params:
                // {number} [#wait_ticks=20]     Amount of Ticks to wait between actions
                // {number} [#timeout_sec=30]    Maximum amount of Seconds the Function can execute for before timing out and returning ERROR_TIMEOUT.
            // Returns the Server ID, or an Error String ENUM:
                // ERROR_TIMEOUT    Function timed out
                // ERROR_UNKNOWN    Function failed for an unknown reason
                // ERROR_COMMAND    Function failed because Command was not available on our Server somehow
        function getServerID(#wait_ticks=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:1020
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9getServerID&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &enum_timeout      = "ERROR_TIMEOUT";
                &enum_unknown      = "ERROR_UNKNOWN";
                &enum_command      = "ERROR_COMMAND";
            endif;
            
            // 1. Check to see if we can grab the Server ID from the Tablist and/or checking to see if we are in Limbo.
            if(true);
                // 1a. Check the Tablist
                if(true);
                    debug_log(%debug%,%&script_debug_name%,"Trying to get Server ID from SkyBlock Tablist...");
                    &server_id = getSkyBlockPlayerListInfo("SERVER");
                    &server_id = ucase(%&server_id%);
                    debug_log(%debug%,%&script_debug_name%,"Returned Server ID is '&d%&server_id%&7'.");
                    if((%&server_id% != "") && (%&server_id% != "-1"));
                        @&current_server_id = %&server_id%;
                        debug_log(%debug%,%&script_debug_name%,"Got a valid Server ID from the Tab List: '&d%&server_id%&7'. Returning it.");
                        return(%&server_id%);
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"Did not get a valid Server ID from the Tab List. Checking if we are in Limbo...");
                endif;
                
                // 1b. Check if we are in Limbo
                if(true);
                    &current_gamemode = getHypixelGamemode();
                    if(%&current_gamemode% == "LIMBO");
                        debug_log(%debug%,%&script_debug_name%,"We are in Limbo. Returning '&dLIMBO&7'.");
                        @&current_server_id = "LIMBO";
                        return("LIMBO");
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"We are not in Limbo. Trying /whereami Command...");
                endif;
            endif;
            
            // 2. Loop command '/whereami' until we find out what Server we are on, or we encounter an Error we cannot recover from.
            if(true);
                unset(@&current_server_id);
                unset(@chatfilter_unknown_cmd);
                #waited_ticks = 0;
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Check if we have a Server ID, or if we are on a Server where this Command is not available somehow.
                    if((%message_sent%) && ((%@&current_server_id% != "") || (%@chatfilter_unknown_cmd%)));
                        if(%@&current_server_id% != "");
                            debug_log(%debug%,%&script_debug_name%,"Got a valid Current Server ID: '&d%@&current_server_id%&7'.");
                            &return_string = %@&current_server_id%;
                        elseif(%@chatfilter_unknown_cmd%);
                            debug_error(%debug%,%&script_debug_name%,"Somehow, we cannot use the Command &4/whereami&c on whichever Server we are on.");
                            &return_string = %&enum_command%;
                        endif;
                        break;
                    endif;
                    
                    // 3. Check to see if we can send the Chat Command
                    do_command = canDoInteraction(%#waited_ticks%,%#wait_ticks%);
                    if(%do_command%);
                        echo("/whereami");
                        message_sent = true;
                    endif;
                    
                    inc(#waited_ticks);
                    wait("1t");
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning: '&d%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // info/index/getSkyblockAreaFromWTFMAP
        // Attempts to read the SkyBlock Area from the /wtfmap command + chatfilter.
            // Params:
            //      {number} [#timeout_sec=30]  Max amount of seconds to wait for Chat Filter to read the wtfmap output.
            //                                  Set to -1 to disable timeout.
            //      {number} [#wait_ticks=60]   Amount of ticks to wait between attempts to issue the command.
            //
            // Returns the String returned from the Command (i.e. "SkyBlock Dynamic"), or "-1" if cannot be found/timed out.
        function getSkyblockAreaFromWTFMAP(#timeout_sec=30,#wait_ticks=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:422
            debug              = true;
            &script_debug_name = "&3getSkyBlockAreaFromWTFMAP&7";
            
            @cannot_use_wtfmap = false;
            @&wtfmap           = "";
            #start_time        = %TIMESTAMP%;
            do_timeout         = #timeout_sec != -1;
            &return_string     = "-1";
            do;
                func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                if(%func_timeout%);
                    break;
                endif;
                    
                debug_log(%debug%,%&script_debug_name%,"echoing '/wtfmap'...");
                echo("/wtfmap");
                do(%#wait_ticks%);
                    wait("1t");
                    got_response   = ((%@&wtfmap% != "") || (%@cannot_use_wtfmap%));
                until(%got_response%);
                if((%got_response%) && (%@&wtfmap% != ""));
                    &return_string = %@&wtfmap%;
                    break;
                endif;
            until((%got_response%) || (%func_timeout%));
            return(%&return_string%);
        endfunction;
    // info/index/getScoreboardSkyBlockArea
        // Attempts to read the Scoreboard to find the Player's AREA on Hypixel SkyBlock (i.e. 'Private Island', 'Hub', 'Bank', etc).
            // Params:
            //      None
            //
            // Returns the string found on the Scoreboard following the Gem Character, or "-1" if not able to be parsed.
        function getScoreboardSkyBlockArea();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:456
            &return_string = -1;
            foreach("teams");
                &joint_team = strip("%TEAMPREFIX%%TEAMSUFFIX%");
                &joint_team = trim(%&joint_team%);
                &joint_team = regexreplace(&joint_team,"^\s*","");
                ifmatches(%&joint_team%,"\u23E3 (.+)",&found_area,1);
                    &return_string = %&found_area%;
                endif;
            next;
            return(%&return_string%);
        endfunction;
    // info/index/getSkyBlockArea
        // Gets the SkyBlock Server Type that we are currently connected to. Returns SKYBLOCK_HUB, SKYBLOCK_HOME, or OTHER. OTHER is only returned if
        // the Function cannot determine whether it is on a SkyBlock Server, or if it is not on a SkyBlock Server.
            // Params:
            //      None
            //
            // Returns one of the following strings: 'SKYBLOCK_HUB', 'SKYBLOCK_HOME', 'OTHER'. 'OTHER' is returned if none of the functions return any
            // parseable values.
        function getSkyBlockArea();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:577
            &playerlist_area = getSkyBlockPlayerListInfo("AREA");
            if(%&playerlist_area% == "-1");
                &scoreboard_area = getScoreboardSkyBlockArea();
                if(%&scoreboard_area% == "-1");
                    &wtfmap_area = getSkyBlockAreaFromWTFMAP();
                    if(%&wtfmap_area% == "SkyBlock Hub");
                        return("SKYBLOCK_HUB");
                    elseif(%&wtfmap_area% == "SkyBlock Dynamic");
                        return("SKYBLOCK_HOME");
                    endif;
                    return("OTHER");
                elseif(%&playerlist_area% == "Your Island");
                    return("SKYBLOCK_HOME");
                else;
                    return("SKYBLOCK_HUB");
                endif;
            elseif(%&playerlist_area% == "Private Island");
                return("SKYBLOCK_HOME");
            else;
                return("SKYBLOCK_HUB");
            endif;
        endfunction;
    // movement/index/gotoServer
        // Given a Server type to get to, gets to the Server type from wherever we are. Returns a boolean indicating
        // whether or not the action was successful.
            // Params:
            //      {string} [&target_server="SKYBLOCK_HOME"]   The target server to get to. Valid values are: 'SKYBLOCK',
            //                                                  'SKYBLOCK_HUB', 'SKYBLOCK_HOME. Defaults to 'SKYBLOCK_HOME'.
            //                                                  If set to 'SKYBLOCK', will accept any SkyBlock server.
            //      {number} [#command_wait_ticks=100]          Amount of ticks to wait between issuing each command needed.
            //      {number} [#timeout_sec=300]                 Amount of seconds to attempt this action before timing out and
            //                                                  returning false. Set to -1 to make the action try to go on indefinitely.
            //                                                  Defaults to 300 (5 minutes).
            //      {boolean} [force_cmd=false]                 If set to true, will force the function to send a command to try and
            //                                                  get to the correct server regardless of whether or not it is already on it
            //                                                  at time of function call.
            //
            // Returns a boolean indicating whether or not the Player is on the [&target_server] at the time of function exit.
        function gotoServer(&target_server="SKYBLOCK_HOME",#command_wait_ticks=100,#timeout_sec=300,force_cmd=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:339
            debug              = true;
            &script_debug_name = "&4gotoServer";
            
            &target_server = miscValidate(%&target_server%,0,"SKYBLOCK_HOME","SKYBLOCK_HUB","SKYBLOCK");
            do_timeout     = #timeout_sec > 0;
            #start_time    = %TIMESTAMP%;
            &encode_vars[] = split(", ","@&auto-restarts-case, @world_changed, BIOME, DIMENSION, XPOS, YPOS, ZPOS"); // Variables used to detect a world change event.
            first_loop     = false;
            #min_tick_wait = %#command_wait_ticks% / 2; // used to ensure we do not spam requests if we switch servers quickly
            
            do;
                if(%do_timeout%);
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                        break;
                    endif;
                endif;
                
                // Figure out what type of command we are going to need to issue.
                if(!%do_override%);
                    &hypixel_gamemode = getHypixelGamemode(); // 'LOBBY', 'LIMBO', 'SKYBLOCK', or 'OTHER'.
                    debug_log(%debug%,%&script_debug_name%,"force_cmd: %force_cmd%, target_server: %&target_server%, hypixel_gamemode: %&hypixel_gamemode%");
                    if(%&hypixel_gamemode% == "SKYBLOCK");
                        return_boolean = %&target_server% == "SKYBLOCK";
                        if((%return_boolean%) && ((!%force_cmd%) || (%first_loop%)));
                            debug_log(%debug%,%&script_debug_name%,"Got to target_server 'SKYBLOCK'.");
                            break;
                        endif;
                        
                        &skyblock_area = getSkyBlockArea(); // 'SKYBLOCK_HUB', 'SKYBLOCK_HOME', 'OTHER'
                        debug_log(%debug%,%&script_debug_name%,"force_cmd: %force_cmd%, target_server: %&target_server%, hypixel_gamemode: %&hypixel_gamemode%, skyblock_area: %&skyblock_area%");
                        return_boolean = %&target_server% == %&skyblock_area%;
                        if((%return_boolean%) && ((!%force_cmd%) || (%first_loop%)));
                            debug_log(%debug%,%&script_debug_name%,"Got to target_server '%&skyblock_area%'.");
                            break;
                        endif;
                        
                        if(%&skyblock_area% == "SKYBLOCK_HUB");
                            if((%force_cmd%) && (%&target_server% == "SKYBLOCK_HUB"));
                                &echo_command = "/warp hub";
                            else;
                                &echo_command = "/warp home";
                            endif;
                        elseif(%&skyblock_area% == "SKYBLOCK_HOME");
                            &echo_command = "/warp hub";
                        elseif(%&skyblock_area% == "OTHER");
                            &echo_command = "/lobby";
                        endif;
                    elseif(%&hypixel_gamemode% == "LIMBO");
                        &echo_command = "/lobby";
                    elseif(%&hypixel_gamemode% == "LOBBY");
                        &echo_command = "/play skyblock";
                    elseif(%&hypixel_gamemode% == "OTHER");
                        &echo_command = "/lobby";
                    endif;
                else;
                    // Issue the override "/lobby" command to break out of the "Cannot send chat message" loop.
                    &echo_command = "/lobby";
                    do_override   = false;
                endif;
                debug_log(%debug%,%&script_debug_name%,"echo_command: &d%&echo_command%");
                
                // Issue the command and wait for an update in our environment variables.
                if(true);
                    if((#waited_ticks > 0) && (#waited_ticks < #command_wait_ticks));
                        do;
                            wait("1t");
                            inc(#waited_ticks);
                        until(%#waited_ticks% >= %#command_wait_ticks%);
                    endif;
                
                    foreach(&encode_vars[],&encode_var,#evi);
                        ifmatches(%&encode_var%,"(?-i:[a-z])"); // Unset any global variables, i.e. '@world_changed'.
                            unset(%&encode_var%);
                        endif;
                        &initial_vals[%#evi%] = "%%&encode_var%%";
                    next;
                    
                    debug_log(%debug%,%&script_debug_name%,"running %&echo_command%");
                    echo(%&echo_command%);
                    env_updated   = false;
                    #waited_ticks = 0;
                    do(%#command_wait_ticks%);
                        wait("1t");
                        inc(#waited_ticks);
                        foreach(&encode_vars[],&encode_var,#evi);
                            &encode_val = "%%&encode_var%%";
                            if(%&initial_vals[%#evi%]% != %&encode_val%);
                                env_updated = true; // Break early as soon as we detect some sort of change in our environment.
                                break;
                            endif;
                        next;
                    until(%env_updated%);
                    
                    // Check to see if we hit the @&auto-restarts-case ("Cannot send chat message")
                    if(%@&auto-restarts-case% != "");
                        do_override = true;
                    endif;
                endif;
                
                first_loop = true;
            until((%func_timeout%) || ((%return_boolean%) && ((!%force_cmd%) || (%first_loop%))));
            
            return(%return_boolean%);
        endfunction;
    // misc/index/getNewTimeoutSec
        // Adjusts <#timeout_sec> to be <#timeout_sec> minus amount of seconds elapsed since <#start_time>.
            // Params:
                // {number} <#start_time>         Timestamp of fn start in caller script
                // {number} <#timeout_sec>        Timeout seconds passed to caller script
                // {boolean} [do_timeout=true]    Whether or not the timeout is active (if it is, the function will always
                //                                return a positive number. If it is not, it will allow <= 0 numbers).
            // Returns the new Timeout in Seconds
            // Example:
                //    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
        function getNewTimeoutSec(#start_time,#timeout_sec,do_timeout=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/index.txt:59
            #recursive_timeout = %#timeout_sec%;
            if(%do_timeout%);
                #recursive_timeout = %#timeout_sec% - (%TIMESTAMP% - %#start_time%);
                if(%#recursive_timeout% <= 0);
                    #recursive_timeout = 1;
                endif;
            endif;
            return(%#recursive_timeout%);
        endfunction;
    // movement/index/swapServers
        // Swaps the Server we are currently connected to by switching to the Hub if we are at Home, or Home if we are at Hub.
        // REQUIRES CHATFILTER LINES:
            // ifmatches(%CHATCLEAN%,"^You are currently connected to server (.+)$",@&current_server_id);
            // Params:
                // {number} [#timeout_sec=30]    Amount of Seconds Function can run for before timing out.
                // {number} [#wait_ticks=100]    Amount of Ticks to wait in between calling Commands.
                //
            // Returns a String ENUM:
                // SUCCESS          Successfully swapped Servers.
                // ERROR_TIMEOUT    Function timed out.
                // ERROR_SERVER     Could not get onto a SkyBlock Server.
        function swapServers(#wait_ticks=100,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:1049
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9swapServers&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &enum_success      = "SUCCESS";
                &enum_timeout      = "ERROR_TIMEOUT";
                &enum_server       = "ERROR_SERVER";
                &enum_unknown      = "ERROR_UNKNOWN";
            endif;
            
            // Loop getting the Initial Server ID and Type followed by switching to the opposing Server until we are on a Server with a different Server ID, or an Error is encountered.
            if(true);
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out. (err code &&enum_timeout: '&4%&enum_timeout%&7'.)");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Get Initial Server ID and Type
                    if(true);
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &init_server_id    = getServerID(%#wait_ticks%,%#recursive_timeout%);
                        ifmatches(%&init_server_id%,"^ERROR_");
                            debug_error(%debug%,%&script_debug_name%,"(INIT) Got an ERROR response from &9getServerID&7: '&4%&init_server_id%&7'.");
                            if((%&init_server_id% == %&enum_unknown%) || (%&init_server_id% == %&enum_server%) || (%&init_server_id% == %&enum_timeout%));
                                debug_error(%debug%,%&script_debug_name%,"Err code &&init_server_id: '&4%&init_server_id%&7'.");
                                &return_string = %&init_server_id%;
                            else;
                                debug_error(%debug%,%&script_debug_name%,"Err code &&enum_unknown: '&4%&enum_unknown%&7'.");
                                &return_string = %&enum_unknown%;
                            endif;
                            break;
                        endif;
                    
                        // Make sure we are on a SkyBlock Server to begin with.
                        if(true);
                            #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            on_skyblock        = gotoServer("SKYBLOCK",%#wait_ticks%,%#recursive_timeout%);
                            if(!%on_skyblock%);
                                debug_error(%debug%,%&script_debug_name%,"Could not get onto a valid SkyBlock Server! (err code &&enum_server: '&4%&enum_server%&7'.)");
                                &return_string = %&enum_server%;
                                break;
                            endif;
                        endif;
                        
                        &init_server_type = getSkyBlockArea();
                    endif;
                    
                    // 3. Swap Servers to the Opposite of our Current Server, then check if the Server ID is different.
                    if(true);
                        if(%&init_server_type% == "SKYBLOCK_HUB");
                            &goto_server_type = "SKYBLOCK_HOME";
                        elseif(%&init_server_type% == "SKYBLOCK_HOME");
                            &goto_server_type = "SKYBLOCK_HUB";
                        else;
                            debug_error(%debug%,%&script_debug_name%,"&9getSkyBlockArea&7 returned '&4%&init_server_type%&7'! (err code &&enum_server: '&4%&enum_server%&7'.)");
                            &return_string = %&enum_server%;
                            break;
                        endif;
                        
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        on_skyblock        = gotoServer(%&goto_server_type%,%#wait_ticks%,%#recursive_timeout%);
                        if(!%on_skyblock%);
                            debug_error(%debug%,%&script_debug_name%,"Could not get onto the &&goto_server_type: '&4%&goto_server_type%&c' Server Type! (err code &&enum_server: '&4%&enum_server%&7'.)");
                            &return_string = %&enum_server%;
                            break;
                        endif;
                        
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &post_server_id    = getServerID(%#wait_ticks%,%#recursive_timeout%);
                        ifmatches(%&post_server_id%,"^ERROR_");
                            debug_error(%debug%,%&script_debug_name%,"(POST) Got an ERROR response from &9getServerID&7: '&4%&post_server_id%&7'.");
                            if((%&post_server_id% == %&enum_unknown%) || (%&post_server_id% == %&enum_server%) || (%&post_server_id% == %&enum_timeout%));
                                &return_string = %&post_server_id%;
                            else;
                                &return_string = %&enum_unknown%;
                            endif;
                            break;
                        endif;
                        
                        if(%&post_server_id% != %&init_server_id%);
                            debug_log(%debug%,%&script_debug_name%,"Updated Server ID from (init) &8%&init_server_id%&7 to (post) &e%&post_server_id%&7.");
                            &return_string = %&enum_success%;
                            break;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Init Server ID (init: '&8%&init_server_id%&7') is the same as Post Server ID (post: '&e%&post_server_id%&7'). Trying again...");
                        endif;
                    endif;
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning &&return_string: '&d%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // tablist/index/getGodPotionExpiryTimestamp
        // Reads the Tab List to find whether or not the Player has a God Potion effect enabled. If so,
        // returns the Seconds Timestamp of when that God Potion will expire. If not, returns -1.
            // Params:
            //      None
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function getGodPotionExpiryTimestamp();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:26
            &time_expression = "You have a God Potion active! (?:(\d+):)?(?:(\d+):)?(?:(\d+))";
            #expiry_ts       = -1;
            foreach("tablist");
                ifmatches(%CLEANLINE%,%&time_expression%);
                    match(%CLEANLINE%,%&time_expression%,{#hours,#minutes,#seconds});
                    #expiry_ts = %TIMESTAMP% + ((#days * 86400) + (#hours * 3600) + (#minutes * 60) + #seconds);
                    log("%#hours% hours, %#minutes% minutes, %#seconds% seconds")
                    break;
                endif;
            next;
            return(#expiry_ts);
        endfunction;
    // tablist/index/getCookieExpiryTimestamp
        // Reads the Tab List to find whether or not the Player has a Booster Cookie effect enabled. If so,
        // returns the Seconds Timestamp of when that Booster Cookie will expire. If not, returns -1.
            // Params:
            //      None
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function getCookieExpiryTimestamp();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:7
            &time_expression = "(?:(\d+)d\s*)?(?:(\d+)h\s*)?(?:(\d+)m\s*)?(?:(\d+)s)";
            #expiry_ts       = -1;
            foreach("tablist");
                ifmatches(%CLEANLINE%,"Cookie Buff\n(.+)",&cookie_buff_time,1);
                    match(%&cookie_buff_time%,%&time_expression%,{#days,#hours,#minutes,#seconds});
                    #expiry_ts = %TIMESTAMP% + ((#days * 86400) + (#hours * 3600) + (#minutes * 60) + #seconds);
                    break;
                endif;
            next;
            return(#expiry_ts);
        endfunction;
    // tablist/index/getEffectExpiryTimestamp
        // Wrapper that dynamically calls getCookieExpiryTimestamp or getGodPotionExpiryTimestamp based on input.
            // Params:
            //      {string} [&type="COOKIE"]   The Effect Type to get the Expiry Timestamp of. One of: 'COOKIE', 'GODPOT'.
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function getEffectExpiryTimestamp(&type="COOKIE");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:73
            &type      = miscValidate(%&type%,0,"COOKIE","GODPOT");
            #expiry_ts = -1;
            if(%&type% == "COOKIE");
                #expiry_ts = getCookieExpiryTimestamp();
            elseif(%&type% == "GODPOT");
                #expiry_ts = getGodPotionExpiryTimestamp();
            endif;
            return(%#expiry_ts%);
        endfunction;
    // tablist/index/isEffectEnabled
        // Wrapper that dynamically calls isCookieEnabled or isGodPotionEnabled based on input.
            // Params:
            //      {string} [&type="COOKIE"]       The Effect Type to get the Expiry Timestamp of. One of: 'COOKIE', 'GODPOT'.
            //      {number} [#expiry_offset_sec=0] An offset in seconds to apply to the real expiry timestamp used
            //                                      to report whether the effect should be considered 'active' or not.
            //                                      For example, if set to 300, if the cookie expires within 300 seconds / 5 min,
            //                                      will return false (when otherwise, it would return true.)
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function isEffectEnabled(&type="COOKIE",#expiry_offset_sec=0);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:93
            #effect_expiry_ts = getEffectExpiryTimestamp(%&type%);
            effect_enabled    = %TIMESTAMP% < (#effect_expiry_ts - #expiry_offset_sec);
            return(%effect_enabled%);
        endfunction;
    // gui/index/localGUI
        // Changes the current GUI to a local GUI.
            // Params:
            //      {string} [&target_gui="NONE"]         - The Target GUI to switch to. Can be any of the following strings:
            //                                              "NONE", "GUIINVENTORY", "GUICHAT".
            //      {number} [#wait_ticks=@#def_wait_ticks]- Amount of ticks (1t = 50ms) to wait between each action (press/GUI).
            //
            // Returns a boolean indicating whether or not GUI == <&target_gui> at end of function.
        function localGUI(&target_gui="NONE",#wait_ticks=20);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:11
            &valid_guis[] = split(", ","NONE, GUIINVENTORY, GUICHAT");
            #valid_gui    = indexof(&valid_guis[],,%&target_gui%);
            if(#valid_gui == -1);
                #valid_gui = 0;
            endif;
            &target_gui = ucase(%&valid_guis[%#valid_gui%]%);
            
            do;
                if(%GUI% == %&target_gui%);
                    break;
                elseif(%GUI% != "NONE");
                    press("escape");
                    do(%#wait_ticks%);
                        wait("1t");
                    until(%GUI% == "NONE");
                else;
                    if(%&target_gui% == "GUIINVENTORY");
                        gui("inventory");
                    elseif(%&target_gui% == "GUICHAT");
                        gui("chat");
                    endif;
                    
                    do(%#wait_ticks%);
                        wait("1t");
                    until(%GUI% != "NONE");
                endif;
            until(%GUI% == %&target_gui%);
            return_boolean = %GUI% == %&target_gui%;
            return(%return_boolean%);
        endfunction;
    // array/index/arrayDelete
        // Removes the Element at <#index> from <&array[]> (different from calling unset, completely clears the entry from the Array).
            // Params:
            //        {array} <&array[]>    The Array to unset the specified index from.
            //        {number} <#index>     The Index to unset in the Source Array. If negative, will be taken
            //                              as an offset from the end of the Array (i.e. -1 = array.length - 1).
            //                              If the Index is greater than the length of the Source Array, no element
            //                              will be removed.
        function arrayDelete(&array[],#index);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:295
            #array_size = arraysize(&array[]);
            #array_len  = #array_size - 1;
            if(%#array_size% == 0);
                return(&array[]);
            else;
                if(%#index% < 0);
                    #index = #array_len + #index;
                endif;
                
                if((%#index% >= 0) && (%#index% <= %#array_len%));
                    foreach(&array[],&element,#i);
                        if(%#i% != %#index%);
                            &out_array[] = %&element%;
                        endif;
                    next;
                endif;
            endif;
            return(&out_array[]);
        endfunction;
    // string/index/xJsonGet
        // Identical to original `jsonget`, but passes the result of the function along to `convertENote` to ensure decimal values are conserved.
            // Params:
                // {string} <&string_a>    The Key to get in the JSON Object, or the JSON Object itself.
                // {string} <&string_b> The Key to get in the JSON Object, or the JSON Object itself. Must be the other value compared to <&string_a>
            // Returns the value provided by `jsonget`, processed thru `convertENote`. Identical results, only difference is preservation of silently coerced Numbers.
        function xJsonGet(&string_a,&string_b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:265
            &return_string = jsonget(%&string_a%,%&string_b%);
            &return_string = convertENote(%&return_string%);
            return(%&return_string%);
        endfunction;
    // array/index/arrayLength
        // Returns the zero-indexed length of an Array.
            // Params:
            //        <array> <&array[]>    The Array to measure the length of.
            //
            // Returns the zero-indexed length of the Array (arraysize - 1).
        function arrayLength(&array[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:6
            #array_size   = arraysize(&array[]);
            #array_length = #array_size - 1;
            return(%#array_length%);
        endfunction;
    // api/minecraft/getMinecraftProfileCacheIndex
        // Checks if a Minecraft Profile is available in the Cached Arrays (@&cached_mc_ [split_ids, joint_ids, usernames, change_ts]).
        // If it is, and the Cache is not invalid, the index the entry can be found at is returned. Otherwise, -1 is returned.
                // Params:
                //        <string>  &search_term   : The term to search for. Can be the username, dashed UUID, or joint UUID.
                //      [boolean] check_validity : True to return the index only if it is valid, false to return the index regardless of it's validity.
                //
                // Returns the index the Profile can be found at in the Cache.
        function getMinecraftProfileCacheIndex(&search_term,check_validity=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/minecraft.txt:8
            &script_debug_name = "&9getMinecraftProfileCacheIndex&7";
            debug              = true;
        
            // Check if the search term can be found in any of the caches.
            if(true);
                #lookup_index  = -1;
                #cache_index[] = indexof(@&cached_mc_split_uuids[],,%&search_term%);
                #cache_index[] = indexof(@&cached_mc_joint_uuids[],,%&search_term%);
                #cache_index[] = indexof(@&cached_mc_usernames[],,%&search_term%);
                foreach(#cache_index[],#cache_index);
                    if(%#cache_index% != -1);
                        #lookup_index = %#cache_index%;
                        break;
                    endif;
                next;
        
                // If we hit a valid cache entry, check if it is valid.
                if(%#lookup_index% != -1);
                    #valid_before = %@#cached_mc_valid_until[%#lookup_index%]%;
                    if((!%check_validity%) || (%#valid_before% >= %TIMESTAMP%));
                        // Player can't change name yet, the cache is valid.
                        return(%#lookup_index%);
                    endif;
                endif;
            endif;
        
            return(-1);
        endfunction;
    // api/minecraft/getMinecraftProfile
        // Gets a User's Minecraft Profile from playerdb.co.
            // Params:
                // {string} &search_term : The term to search for. Can be the username, dashed UUID, or joint UUID.
                //
            // Returns an Array:
                // 0 {boolean} success     : Whether or not the request was successful
                // 1 {string}  &username   : The player's username
                // 2 {string}  &joint_uuid : The player's joint UUID
                // 3 {string}  &split_uuid : The player's split UUID
            // Example:
                //    &minecraft_profile[]   = getMinecraftProfile(%&search_term%);
                //    minecraft_profile     := %&minecraft_profile[0]%;
                //    &minecraft_username    = %&minecraft_profile[1]%;
                //    &minecraft_joint_uuid  = %&minecraft_profile[2]%;
                //    &minecraft_split_uuid  = %&minecraft_profile[3]%;
        function getMinecraftProfile(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/minecraft.txt:53
            &script_debug_name = "&9getMinecraftProfile&7";
            debug              = false;
        
            // If we are checking the current player, we can skip requests altogether.
            &player_split_uuid = %UUID%;
            &player_joint_uuid = regexreplace(&player_split_uuid,"-","");
            &player_identity[] = split(", ","%&player_split_uuid%, %&player_joint_uuid%, %PLAYER%");
            #player_index      = indexof(&player_identity[],,%&search_term%);
            if(%#player_index% != -1);
                &player_username   = %PLAYER%;
                &player_joint_uuid = %&player_joint_uuid%;
                &player_split_uuid = %UUID%;
                success            = true;
            else;
                // Not checking current player, do API calls.
                #cache_index  = getMinecraftProfileCacheIndex(%&search_term%,false);
                #valid_before = %@#cached_mc_valid_until[%#cache_index%]%;
                if((%#valid_before% >= %TIMESTAMP%) && (%#cache_index% != -1));
                    // Entry is cached, we can skip the request.
                    &player_username   = %@&cached_mc_usernames[%#cache_index%]%;
                    &player_joint_uuid = %@&cached_mc_joint_uuids[%#cache_index%]%;
                    &player_split_uuid = %@&cached_mc_split_uuids[%#cache_index%]%;
                    success            = true;
                else;
                    // Search term is not cached, try the API.
                    if(true);
                        setrequestheader("accept","application/json");
                        setrequestheader("user-agent","MC_API")
                        &api_url  = "https://playerdb.co/api/player/minecraft/%&search_term%";
                        &api_resp = httpget(%&api_url%,,#api_code);
                        &api_code = jsonget("code",%&api_resp%);
                        if(%&api_code% == "player.found");
                            &player_username   = jsonget("data.player.username",%&api_resp%);
                            &player_joint_uuid = jsonget("data.player.raw_id",%&api_resp%);
                            &player_split_uuid = jsonget("data.player.id",%&api_resp%);
                            success            = true;
                        elseif(%debug%);
                            &vars[] = split(" ","&api_url &api_resp &api_code #api_code");
                            foreach(&vars[],&var,#v);
                                &var_ = regexreplace(&var,"&","&&");
                                &val  = "%%&var%%";
                            next;
                        endif;
                    endif;
        
                    // Update the cache entry.
                    if(true);
                        if(%success%);
                            // Search term (could be UUID or Username) was valid and found on a Player.
                            // Update or initialize the Cache entry for the UUID.
                            &player_name_hist      = jsonget("data.player.meta.name_history",%&api_resp%);
                            &player_name_changes[] = getjsonasarray(%&player_name_hist%);
                            #player_name_changes   = arraylength(&player_name_changes[]);
                            if(%#player_name_changes% == 1);
                                &latest_change_time = 0;
                            else;
                                &latest_change_time = xJsonGet("changedToAt",%&player_name_changes[%#player_name_changes%]%);
                                &latest_change_time = match(%&latest_change_time%,"(^.{10})",1);
                            endif;
        
                            // A player can change their name every 30 days since their most recent name change.
                            // Set the 'cache invalidation' timestamp for this entry to be the latest change time + ms in 30 days.
                            #latest_change_time := %&latest_change_time%;
                            #can_change_name_at  = %#latest_change_time% + (60 * 60 * 24 * 30);
                            
                            #uuid_index = indexof(@&cached_mc_split_uuids[],,%&player_split_uuid%);
                            if(%#uuid_index% == -1);
                                @&cached_mc_split_uuids[] = %&player_split_uuid%;
                                @&cached_mc_joint_uuids[] = %&player_joint_uuid%;
                                @&cached_mc_usernames[]   = %&player_username%;
                                @#cached_mc_valid_until[] = %#can_change_name_at%;
                            else;
                                @&cached_mc_usernames[%#uuid_index%]   = %&player_username%;
                                @#cached_mc_valid_until[%#uuid_index%] = %#can_change_name_at%;
                            endif;
                        elseif(%#cache_index% != -1);
                            // Search term (has to be Username) was a previously valid Username on another User, but they have since
                            // changed their Username. We can be certain of this because the Cache was hit successfully, but the request
                            // did not pull up any valid Account.
                            //
                            // Clear the invalid entry from the Cache.
                            //
                            
                            @&cached_mc_split_uuids[] = arrayDelete(@&cached_mc_split_uuids[],%#cache_index%);
                            @&cached_mc_joint_uuids[] = arrayDelete(@&cached_mc_joint_uuids[],%#cache_index%);
                            @&cached_mc_usernames[]   = arrayDelete(@&cached_mc_usernames[],%#cache_index%);
                            @#cached_mc_valid_until[] = arrayDelete(@#cached_mc_valid_until[],%#cache_index%);
                        endif;
                    endif;
                endif;
            endif;
            return(%success%,%&player_username%,%&player_joint_uuid%,%&player_split_uuid%);
        endfunction;
    // string/index/xFormatNumber
        // Identical to original `formatnumber`, but passes the input_string through `convertENote` before passing it into `formatnumber`.
            // Params:
                // {string} <&input_string>          The Number or String to Format into a Number. If this Number includes Commas, they will be stripped
                //                                   from the string passed to `formatnumber`.
                // {string} [&decimal_precision]     The desired level of precision following the decimal. If omitted or an empty string, will
                //                                   include the amount of decimals included in the <&input_string>. If provided, should be an integer >= 0.
                //                                   If set to 0, will not include a decimal character or trail at all. Providing a value that is incoherent
                //                                   to the level of decimal precision present in the <&input_string> will result in the output being rounded
                //                                   to the desired level of precision.
                // {boolean} [strip_commas=false]    Whether or not to strip commas when formatting the Number. If set to True, and [&decimal_precision]
                //                                   is set to "0", this Function will return a valid Integer.
            // Returns the result of the `formatnumber` expression.
            // Examples:
                // Converting a formatted string Number to a valid Integer:
                    //    &input_string      = "1009.0131";
                    //    &decimal_precision = "0";
                    //    strip_commas       = true;
                    //    #output_integer    = xFormatNumber(%&input_string%,%&decimal_precision%,%strip_commas%);
                // Converting a valid Integer to a formatted (comma split) string:
                    //    &input_string      = "10000";
                    //    &decimal_precision = "";
                    //    strip_commas       = false;
                    //    &output_string     = xFormatNumber(%&input_string%,%&decimal_precision%,%strip_commas%);
        function xFormatNumber(&input_string,&decimal_precision,strip_commas=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:315
            &return_string = replace(&input_string,",");
            &return_string = convertENote(%&return_string%);
            &return_string = formatnumber(%&return_string%,%&decimal_precision%,%strip_commas%);
            return(%&return_string%);
        endfunction;
    // string/index/convertToMetric
        // Takes an input of a Number String and formats it into a Metric String (K, M, B, or T as suffix).
            // Params:
                // {string} <&convert_string>         The Number String to convert.
                // {number} [#decimal_precision=1]    Amount of sig. figs to round the conversion off to. If set to <= -1, will just
                //                                    format the number as-is (it will keep as many decimal places as it had in the first place).
            // Returns a String.
            // Example:
                //    &metric_string = convertToMetric("151091.501",1);
                //    log(%&metric_string%); // 151.1 K
        function convertToMetric(&convert_string,#decimal_precision=1);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:566
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9convertToMetric&7";
                debug_log(%debug%,%&script_debug_name%,"called, args are &&convert_string='&e%&convert_string%&7', #decimal_precision=&e%#decimal_precision%");
            endif;
            &metric_chars[] = split(", ","K, M, B, T");
            &metric_ratio[] = split(", ","1000, 1000000, 1000000000, 1000000000000");
            &return_string  = %&convert_string%;
            ifmatches(%&convert_string%,"^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)",&integer_portion,2);
                log("&7matched expression '&d^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)&7' against string ")
                #component_a_len = strlen(%&integer_portion%);
                debug_log(%debug%,%&script_debug_name%,"matched expression '&d^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)&7' against &&convert_string='&e%&convert_string%&7', extracted &&integer_portion='&e%&integer_portion%&7' with length=&e%#component_a_len%&7.");
                #metric_index    = -1;
                foreach(&metric_ratio[],&metric_ratio,#mr);
                    #metric_ratio_len = strlen(%&metric_ratio%);
                    if(%#component_a_len% >= %#metric_ratio_len%);
                        debug_log(%debug%,%&script_debug_name%,"metric_ratio_len=&e%#metric_ratio_len%&7 >= #component_a_len=&e%#component_a_len%&7, setting metric_index=&e%#mr%");
                        #metric_index = %#mr%;
                    endif;
                next;
                
                if(%#metric_index% >= 0);
                    &metric_char   = %&metric_chars[%#metric_index%]%;
                    &metric_ratio  = %&metric_ratio[%#metric_index%]%;
                    &return_string = xEval("%&convert_string% / %&metric_ratio%");
                    if(%#decimal_precision% <= -1);
                        &return_string = xFormatNumber(%&return_string%);
                    else;
                        &return_string = xFormatNumber(%&return_string%,%#decimal_precision%);
                    endif;
                    &return_string = "%&return_string% %&metric_char%";
                endif;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/convertMetricString
        // Takes an input of a string with metric numbers in it (e.g. '10K, '10.5M', etc) and parses out the metric character
        // then converts the input into a number and returns it. Supports K, M, B, T suffixes.
            // Params:
                // {string} <&metric_string>               The String to Parse
                // {number} [#decimal_precision=-1]        Amount of sig. figs to round the conversion off to. If set to <= -1, will just
                //                                         format the number as-is (it will keep as many decimal places as it had in the first place).
                // {boolean} [format_with_commas=false]    Whether or not to format the conversion with commas every 3 characters.
            // Returns an Empty String if no conversion were able to be done, or a (possibly formatted) Number otherwise.
            // Example:
                //    #converted_units = convertMetricString("10K",2,true);
                //    log(%#converted_units%); // 10,000.00
        function convertMetricString(&metric_string,#decimal_precision=-1,format_with_commas=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:529
            &base_expression = "([\d,.-]+)(?:.*?\b|\B)";
            &metric_chars[]  = split(", ","K, M, B, T");
            &metric_ratio[]  = split(", ","1000, 1000000, 1000000000, 1000000000000");
            &return_string   = "0";
            match_found      = false;
            foreach(&metric_chars[],&metric_char,#mc);
                &metric_expr = "%&base_expression%%&metric_char%";
                ifmatches(%&metric_string%,%&metric_expr%,&amount_units,1);
                    match_found    = true
                    &amount_units  = replace(&amount_units,",");
                    &return_string = xEval("%&return_string% + (%&amount_units% * %&metric_ratio[%#mc%]%)");
                endif;
            next;
            
            if(%match_found%);
                strip_commas = !%format_with_commas%;
                if(%#decimal_precision% <= -1);
                    &return_string = xFormatNumber(%&return_string%,"",%strip_commas%);
                else;
                    &return_string = xFormatNumber(%&return_string%,%#decimal_precision%,%strip_commas%);
                endif;
                return(%&return_string%);
            else;
                return("");
            endif;
        endfunction;
    // string/index/isMetricString
        // Checks if a String is a Metric String
            // Params:
                // {string} <&metric_string>    The String to check for a Metric Suffix (and/or Metric Suffixes)
                //
            // Returns a Boolean indicating whether or not the String is a Metric String
            // Example:
                //    is_metric = isMetricString(%&metric_string%);
        function isMetricString(&metric_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:510
            &base_expression = "([\d,.-]+)(?:.*?\b|\B)(K|M|B|T)";
            ifmatches(%&metric_string%,%&base_expression%);
                return_boolean = true;
            endif;
            return(%return_boolean%);
        endfunction;
    // array/index/miscComparator
        // Evaluates whether <&left> is <&operator> to <&right> (executes a variable comparison). Returns a boolean.
            // Params:
            //        {string} <&left>        The Left Hand side of the Comparison.
            //        {string} <&operator>    The Operator to apply the Condition against each Element with. Has to be one of:
            //                                '==', '!=', '>', '<', '>=', '<=', 'eq', 'ne', 'gte', 'lte', 'gt', or 'lt'. If a
            //                                number comparison operator is used, the values in the Array will be coerced to a
            //                                number so long as the condition is an integer. If the condition is a float value,
            //                                they will be evaluated using float math (eval).
            //        {string} <&right>       The Right Hand side of the Comparison
            //
            // Returns a boolean indicating the outcome of the evaluation.
        function miscComparator(&left,&operator,&right);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:88
            &sign_operators[] = split(", ","==, !=, >=, <=, >, <");
            #sign_op_index    = indexof(&sign_operators[],,%&operator%);
            if(%#sign_op_index% == -1);
                &char_operators[] =    split(", ","eq, ne, gte, lte, gt, lt");
                #char_op_index    = indexof(&char_operators[],,%&operator%);
                if(%#char_op_index% == -1);
                    return(&return_array[]);
                endif;
                
                &operator = %&sign_operators[%#char_op_index%]%;
            endif;
        
            if(%&operator% == "==");
                if(%&left% == %&right%);
                    return_boolean = true;
                endif;
            elseif(&operator% == "!=");
                if(%&left% != %&right%);
                    return_boolean = true;
                endif;
            else;
                ifmatches(%&right%,"^(\d+)$",#right,1);
                    // Doing Integer Evaluation
                    #left := %&left%;
                    if((%&operator% == ">=") && (%#left% >= %#right%));
                        return_boolean = true;
                    elseif((%&operator% == ">") && (%#left% > %#right%));
                        return_boolean = true;
                    elseif((%&operator% == "<=") && (%#left% <= %#right%));
                        return_boolean = true;
                    elseif((%&operator% == "<") && (%#left% < %#right%));
                        return_boolean = true;
                    endif;
                elseifmatches(%&right%,"^[0-9.-]+");
                    // Doing Float Evaluation
                    &float_diff = eval("%&left% - %&right%");
                    ifmatches(%&float_diff%,"^-");
                        // <left> - <right> = negative number, left was less than right
                        if((%&operator% == "<=") || (%&operator% == "<"));
                            return_boolean = true;
                        endif;
                    else;
                        // <left> - <right> = positive or 0, left was greater than or equal to right
                        ifmatches(%&float_diff%,"[0.]+");
                            // <left> - <right> = 0, left was equal to right
                            if((%&operator% == ">=") || (%&operator% == "<="));
                                return_boolean = true;
                            endif;
                        elseif((%&operator% == ">=") || (%&operator% == ">"));
                            // <left> - <right> = greater than 0, left was greater than right
                            return_boolean = true;
                        endif;
                    endif;
                endif;
            endif;
            return(%return_boolean%);
        endfunction;
    // math/index/number
        // Normalizes any type of input Number into the Type.
            // Params:
                // {string} <&number>             The Number to Format. Can be integer, decimal, negative, positive, metric, e-notation, whatever.
                // {string} [...&formatting[]]    The Formatting Options to apply. Settings are provided in '<KEY>: <VALUE>' notation. Valid Options:
                                                //    ['F'|'T'|'S'|'TYPE'|'STYLE'|'FORMAT']:
                                                //        - ['I'|'N'|'INT'|'INTEGER'|'NUM'|'NUMBER']           : Formats the output as an Integer.
                                                //        - ['D'|'F'|'L'|'DECIMAL'|'FLOAT'|'LONG'|'DOUBLE']    : Formats the output as a Decimal Number.
                                                //        - ['E'|'ENOTE'|'EXP'|'EXPONENT']                     : Formats the output in Exponentional Notation.
                                                //        - ['M'|'METRIC']                                     : Formats the output as a Metric Suffixed Number.
                                                //    ['P'|'PLACE'|'PLACES'|'PRECISION'] (Only available if Type is Decimal or Metric or equivalent):
                                                //        - ['S'|'SIG'|'SIGFIG'|'SIGNIFICANT']    : Applies the default amount of Decimal Places (the Sig. Figs in the converted value).
                                                //        - <NUMBER >= 0>                         : Applies <NUMBER> amount of Decimal Places (setting this to 0 is the same as using F: INT, R: ROUND).
                                                //    ['R'|'ROUND'|'ROUNDING'] (Only available if Precision is not 'SIG' or equivalent):
                                                //        - ['R'|'ROUND'|'D'|'DEFAULT'|'STD'|'STANDARD'|'NEAR'|'NEAREST'|'INT'|'NUM'|'INTEGER'|'NUMBER']    : Round using 'ROUND' (towards nearest integer).
                                                //        - ['F'|'FLOOR'|'DOWN'|'D'|'<'|'LESSER'|'LT']                                                      : Round using 'FLOOR' (towards negative infinity).
                                                //        - ['C'|'CEIL'|'CEILING'|'UP'|'>'|'GREATER'|'GT']                                                  : Round using 'CEIL' (towards positive infinity).
                                                //        - ['T'|'TRUNCATE'|'TRUNC']                                                                        : Rounds up or down towards 0
                                                //        - ['N'|'NONE']                                                                                    : Does not round the output.
                                                //    ['C'|'COMMA'|'COMMAS'|'DELIMIT'|'DELIMITER'|'SPACE'|'SPACER']:
                                                //        - <BOOLEAN>          : Enables (or disables) formatting the output with Commas every 3 sig. figs (e.g. 100000 -> 100,000)
                                                //        - <STRING>           : Enables formatting the output with <STRING> as the delimiter every 3 sig. figs
                                                //        - ['N'|'NONE'|'']    : Disables formatting the output with delimiters.
                                                //    The Default Values for each Setting are as follows:
                                                //        FORMAT       : FLOAT
                                                //        PRECISION    : SIGNIFICANT
                                                //        ROUNDING     : NONE
                                                //        DELIMITER    : FALSE
            // Returns the Number specified formatted according to the Rules specified in [...&formatting[]].
            // Example:
                //    &number = number("100,000,000.192");
                //    log("number: %&number%"); // 'number: 100000000.192' (default formatting rules were applied)
        function number(&number="0",...&formatting[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:198
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6mathNumber&7";
                exponent_ready     = false;
                
                // Parse Formatting Options
                if(true);
                    // Wrap Formatting Keys, Valid Values and Default Values
                    if(true);
                        if(true); // Wrap '&opt_format' Formatting Option
                            &valid_formatting_vars[]        = "&opt_format";
                            &valid_formatting_keys[]        = "F|T|S|TYPE|STYLE|FORMAT";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            if(%exponent_ready%);
                                &valid_formatting_vals[] = "INTEGER|I|N|INT|NUM|NUMBER~FLOAT|D|F|L|DECIMAL|LONG|DOUBLE~EXPONENT|E|ENOTE|EXP~METRIC|M";
                                &valid_formatting_expr[] = "INTEGER|r$^[\d]+$~FLOAT|r$^[\d]*\.\d+$~EXPONENT|r$(?:e|\^)";
                            else;
                                &valid_formatting_vals[] = "INTEGER|I|N|INT|NUM|NUMBER~FLOAT|D|F|L|DECIMAL|LONG|DOUBLE~METRIC|M";
                                &valid_formatting_expr[] = "INTEGER|r$^[\d]+$~FLOAT|r$^[\d]*\.\d+$";
                            endif;
                            &opt_format = "FLOAT";
                        endif;
                        
                        if(true); // Wrap '&opt_precision' Formatting Option
                            &valid_formatting_vars[]        = "&opt_precision";
                            &valid_formatting_keys[]        = "P|PLACE|PLACES|PRECISION";
                            &valid_formatting_vals[]        = "SIGNIFICANT|SIGFIG|SIG|S";
                            &valid_formatting_expr[]        = "CUSTOM|r$^\d+$";
                            &valid_formatting_validation[]  = ">= 0";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_precision                  = "SIGNIFICANT";
                        endif;
                        
                        if(true); // Wrap '&opt_rounding' Formatting Option
                            &valid_formatting_vars[]        = "&opt_rounding";
                            &valid_formatting_keys[]        = "ROUNDING|ROUND|R";
                            &valid_formatting_vals[]        = "ROUND|INT|NUM|NUMBER|NEAREST|NEAR|STD|STANDARD|DEFAULT|D|INTEGER|R~FLOOR|F|DOWN|D|<|LESSER|LT~CEIL|CEILING|C|UP|>|GREATER|GT~NONE|N~TRUNCATE|TRUNC|T";
                            &valid_formatting_expr[]        = "";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_rounding                   = "NONE";
                        endif;
                        
                        if(true); // Wrap '&opt_delimiter' Formatting Option
                            &valid_formatting_vars[]        = "&opt_delimiter";
                            &valid_formatting_keys[]        = "DELIMITER|C|COMMA|COMMAS|DELIMIT|SPACE|SPACER|SPACES|SPACERS|DELIMITERS";
                            &valid_formatting_vals[]        = "TRUE|1~FALSE|0~NONE|N"
                            &valid_formatting_expr[]        = "CUSTOM|r$^.+$";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_delimiter                  = "false";
                        endif;
                    endif;
                    
                    // Parse Options
                    if(true);
                        #formatting_sz = arraysize(&formatting[]);
                        if(%#formatting_sz% >= 1);
                            foreach(&formatting[],&formatting,#f);
                                ifmatches(%&formatting%,"^(.*?):\s*?(.*)$");
                                    match(%&formatting%,"^(.*?):\s*?(.*)$",{&custom_key,&custom_val});
                                    &check_key_index_for = ucase(%&custom_key%);
                                    &check_val_index_for = ucase(%&custom_val%);
                                    foreach(&valid_formatting_keys[],&valid_formatting_keys_str,#vfk);
                                        if(!%valid_formatting_def_override[%#vfk%]%);
                                            &valid_formatting_keys_arr[] = split("|",%&valid_formatting_keys_str%);
                                            #check_key_index_for         = indexof(&valid_formatting_keys_arr[],,%&check_key_index_for%);
                                            debug_log(%debug%,%&script_debug_name%,"checking key for '&d%&check_key_index_for%&7' index is '&e%#check_key_index_for%&7'.");
                                            if(%#check_key_index_for% != -1);
                                                &valid_formatting_val_types_arrs[] = split("~",%&valid_formatting_vals[%#vfk%]%);
                                                foreach(&valid_formatting_val_types_arrs[],&valid_formatting_val_type_str,#vfvt);
                                                    &valid_formatting_val_types_arr[] = split("|",%&valid_formatting_val_type_str%);
                                                    #check_val_index_for              = indexof(&valid_formatting_val_types_arr[],,%&check_val_index_for%);
                                                    debug_log(%debug%,%&script_debug_name%,"checking val index for '&d%&check_val_index_for%&7' index is '&e%#check_val_index_for%&7'.");
                                                    if(%#check_val_index_for% != -1);
                                                        &set_var = %&valid_formatting_vars[%#vfk%]%;
                                                        &set_val = %&valid_formatting_val_types_arr[0]%;
                                                        debug_log(%debug%,%&script_debug_name%,"setting value of &%&set_var%='&e%&set_val%&7'");
                                                        set(%&set_var%,%&set_val%);
                                                        set(valid_formatting_def_override[%#vfk%],true);
                                                        break;
                                                    endif;
                                                next;
                                                
                                                // If we found a match for the Key, but not for the Value, check to see if this Option allows Custom Input.
                                                // If it does, check if the provided Value passes the Regular Expression Validation, and then if this Option
                                                // also has a further Validation Check, ensure it passes that further Validation Check as well.
                                                if((!%valid_formatting_def_override[%#vfk%]%) && (%&valid_formatting_expr[%#vfk%]% != ""));
                                                    &input_validation_expr_groups[]      = split("~",%&valid_formatting_expr[%#vfk%]%);
                                                    &input_validation_expr_validations[] = split("~",%&valid_formatting_validation[%#vfk%]%);
                                                    input_passes_validation              = false;
                                                    foreach(&input_validation_tests[],&input_validation_test_string,#ivt);
                                                        ifmatches(%&input_validation_test_string%,"^(.+?)\|r\$(.+)$");
                                                            match(%&input_validation_test_string%,"^(.+?)\|r\$(.+)$",{&matched_value,&matched_expr});
                                                            ifmatches(%&custom_val%,%&matched_expr%);
                                                                input_passes_validation = true;
                                                                if(%&input_validation_expr_validations[%#ivt%]% != "");
                                                                    &validation_params[]    = split(" ",%&input_validation_expr_validations[%#ivt%]%);
                                                                    &validation_op          = %&validation_params[0]%;
                                                                    &validation_rhs         = %&validation_params[1]%;
                                                                    input_passes_validation = miscComparator(%&custom_val%,%&validation_op%,%&validation_rhs%);
                                                                endif;
                                                                
                                                                if(%input_passes_validation%);
                                                                    &set_var = %&valid_formatting_vars[%#vfk%]%;
                                                                    &set_val = ucase(%&matched_value%);
                                                                    if(%&set_val% == "CUSTOM");
                                                                        &set_val = %&custom_val%;
                                                                        set(valid_formatting_custom_input[%#vfk%],true);
                                                                    endif;
                                                                    set(%&set_var%,%&set_val%);
                                                                    set(valid_formatting_def_override[%#vfk%],true);
                                                                    debug_log(%debug%,%&script_debug_name%,"set value of &%&set_var%='&e%&set_val%&7'");
                                                                    break;
                                                                endif;
                                                            endif;
                                                        endif;
                                                    next;
                                                endif;
                                                
                                                if(%valid_formatting_def_override[%#vfk%]%);
                                                    break;
                                                endif;
                                            endif;
                                        endif;
                                    next;
                                endif;
                                
                                #non_overriden_index = indexof(valid_formatting_def_override[],,false);
                                if(%#non_overriden_index% == -1);
                                    break;
                                endif;
                            next;
                        endif;
                    endif;
                endif;
            endif;
            
            // Parse the Number into Standardized Format.
            if(true);
                ifnotmatches(%&number%,"\d");
                    &number = "0";
                endif;
                
                &read_number = replace(&number,",");
                ifmatches(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$");
                    &read_number = convertENote(%&number%);
                else;
                    &read_number = %&number%;
                endif;
                debug_log(%debug%,%&script_debug_name%,"Conversion of &&number (&5'%&number%&7') from Exp. Notation to Decimal returned &&read_number ('&d%&read_number%&7').");
                
                is_metric = isMetricString(%&read_number%);
                if(%is_metric%);
                    &before_metric = %&read_number%;
                    &read_number   = convertMetricString(%&read_number%,"-1");
                    ifmatches(%&read_number%,"^([\d.-]+)\.0*$",&first_portion,1);
                        debug_log(%debug%,%&script_debug_name%,"Conversion of &&read_number ('&5%&before_metric%&7') from Metric returned insignificant digits, cutting off (setting &&read_number to: '&e%&first_portion%&7' from '&d%&read_number%&7').");
                        &read_number = %&first_portion%;
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"Conversion of &&read_number ('&5%&before_metric%&7') from Metric returned '&d%&read_number%&7'.");
                elseif(%debug%);
                    debug_log(%debug%,%&script_debug_name%,"&&read_number ('&5%&read_number%&7') was not classified as being a Metric String.");
                endif;
                
                if(%debug%);
                    debug_log(%debug%,%&script_debug_name%,"Formatting Input Number '&d%&number%&7' (standardized: '&d%&read_number%&7')...");
                    &vars[] = split(" ","&number &read_number &opt_format &opt_precision &opt_rounding &opt_delimiter");
                    foreach(&vars[],&var,#v);
                        &val    = "%%&var%%";
                        &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                        &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                        debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
                    next;
                endif;
                
                // Apply the specified Rounding Option as defined in '&opt_rounding'
                if(true);
                    &before_round = %&read_number%;
                    if(%&opt_rounding% == "TRUNCATE");
                        debug_log(%debug%,%&script_debug_name%,"Truncating &&read_number ('&5%&before_round%&7') by cutting off all decimals.");
                        ifmatches(%&read_number%,"^([\d-]+)\.",&truncated_number,1);
                            &read_number = %&truncated_number%;
                            debug_log(%debug%,%&script_debug_name%,"Truncated &&read_number ('&5%&before_round%&7') to: '&d%&read_number%&7'.");
                        else;
                            debug_log(%debug%,%&script_debug_name%,"No decimal points to truncate in &&read_number ('&5%&before_round%&7').");
                        endif;
                    elseif(%&opt_rounding% != "NONE");
                        &read_number = xEval("%&opt_rounding%(%&read_number%)");
                        debug_log(%debug%,%&script_debug_name%,"Rounding &&read_number ('&5%&before_round%&7') with Method: '&e%&opt_rounding%&7' returned: &d'%&read_number%&7'.");
                    else;
                        debug_log(%debug%,%&script_debug_name%,"Not rounding &&read_number ('&5%&before_round%&7') at all, Rounding Method (&&opt_rounding: '&e%&opt_rounding%&7') is set to 'NONE'.");
                    endif;
                endif;
                
                // Apply the specified Formatting Option as defined in '&opt_format'
                if(true);
                    &before_formatting = %&read_number%;
                    
                    // Figure out the Formatting Rules to pass to xFormatNumber
                    if(true);
                        // Figure out the Decimal Places to include in the Result (if any)
                        if(true);
                            &format_precision = "0";
                            if(%&opt_format% != "INTEGER");
                                &format_precision = "";
                                #precision_index  = indexof(&valid_formatting_vars[],,"&opt_precision");
                                custom_precision  = %valid_formatting_custom_input[%#precision_index%]%;
                                if(%custom_precision%);
                                    &format_precision = %&opt_precision%;
                                endif;
                            endif;
                        endif;
                        
                        // Figure out the Delimiter to Use in the Result (if any)
                        if(true);
                            if((%&opt_format% != "EXPONENT") && (&opt_format% != "METRIC"));
                                opt_delimiter    := %&opt_delimiter%;
                                #delimiter_index  = indexof(&valid_formatting_vars[],,"&opt_delimiter");
                                custom_delimiter  = %valid_formatting_custom_input[%#delimiter_index%]%;
                                use_delimiter     = ((%custom_delimiter%) || (%opt_delimiter%));
                            endif;
                            exclude_commas = !%use_delimiter%;
                        endif;
                        
                        // Format the Number using xFormatNumber
                        if(true);
                            &before_xformat      = %&read_number%;
                            &formatted_number    = xFormatNumber(%&read_number%,%&format_precision%,false);
                            &pure_number         = replace(&formatted_number,",");
                            debug_log(%debug%,%&script_debug_name%,"Calling &bxFormatNumber&7 on &&read_number ('&5%&before_xformat%&7') returned '&d%&formatted_number%&7' (called &bxFormatNumber&7 with args: precision: '&e%&format_precision%&7', exclude_commas: '&cfalse&7'). Comma Stripped version is '&e%&pure_number%&7'.");
                            if(%&opt_format% == "METRIC");
                                &read_number = convertToMetric(%&pure_number%,-1);
                                debug_log(%debug%,%&script_debug_name%,"Calling &bconvertToMetric&7 on &&pure_number ('&5%&pure_number%&7') returned '&d%&read_number%&7' (called &bconvertToMetric&7 with args: precision: '&e-1&7').");
                            elseif(%use_delimiter%);
                                &read_number = %&formatted_number%;
                                &delim_char  = ",";
                                if(%custom_delimiter%);
                                    &delim_char  = %&opt_delimiter%;
                                    &read_number = replace(&read_number,",",%&delim_char%);
                                endif;
                                debug_log(%debug%,%&script_debug_name%,"Set &&read_number ('&5%&pure_number%&7') to be formatted using delimiter character (&&delim_char: '&e%&delim_char%&7'): '&d%&read_number%&7'.");
                            else;
                                &read_number = %&pure_number%;
                                debug_log(%debug%,%&script_debug_name%,"Set &&read_number ('&5%&read_number%&7') to be stripped of Delimiter Characters.");
                            endif;
                        endif;
                        
                        // If we are only returning sig. figs, do that.
                        if(%&opt_precision% == "SIGNIFICANT");
                            ifmatches(%&read_number%,"^(.*?)\.0*$",&first_portion,1);
                                &read_number = %&first_portion%;
                            endif;
                        endif;
                    endif;
                endif;
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning '&d%&read_number%&7' from input number '&5%&number%&7' (applied opts: format='&e%&opt_format%&7', precision='&e%&opt_precision%&7', rounding='&e%&opt_rounding%&7', delimiter='&e%&opt_delimiter%&7').");
            return(%&read_number%);
        endfunction;
    // auctions/getListingInfo/auctionsCheckCache
        // Given any number of an Auction's Identifiers, sifts through Cached Auctions and finds a Listing that matches all of the Identifiers.
            // Params:
                // {string} <...&auction_identifiers[]>    An Array of Auction Identifiers in format: '<ID_TYPE>: <ID_DATA>'. If multiple instances of a given
                //                                         ID_TYPE are encountered, the one that appears latest in the Array is used. Valid ID_TYPE Prefixes are
                //                                         at the end of this Comment.
            // Valid ID_TYPE Prefixes:
                // {string} ID          The Listing ID
                // {string} TYPE        The Listing Type (one of: BIN, AUCTION)
                // {number} PRICE       The Current Listing Price
                // {number} BIDS        The amount of Bids on the Listing
                // {boolean} ENDED      Whether or not the Listing has Ended
                // {boolean} CLAIMED    Whether or not the Listing has been claimed
                // {string} OWNER       The UUID of the Player that created this Listing
                // {string} PROFILE     The Profile ID the Owner of this Listing was using to create this Listing
                // {string} SBID        The SkyBlock ID of the Item that this Listing represents
                // {string} NAME        The Display Name of the Item that this Listing represents
                // {string} MCID        The Minecraft Item ID that this Listing represents
                // {number} DATA        The Data Value of the Item that this Listing represents
                // {number} STACK       The Stack Size of the Item that this Listing represents
                // {string} BUYER       A UUID(s) of a Player who purchased/claimed this Listing. If giving multiple, join them with ~.
            // Returns an Array:
                // 0  {boolean} cache_hit          Whether or not an Item from the Cache was found that matches the specified Auction Identifiers.
                // 1  {string}  &cache_id          The Listing ID
                // 2  {string}  &cache_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #cache_price       The Current Listing Price
                // 4  {number}  #cache_bids        The amount of Bids on the Listing
                // 5  {boolean} cache_ended        Whether or not the Listing has Ended
                // 6  {boolean} cache_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &cache_owner       The UUID of the Player that created this Listing
                // 8  {string}  &cache_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &cache_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &cache_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &cache_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #cache_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #cache_stack       The Stack Size of the Item that this Listing represents
                // 14 {string}  &cache_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #cache_end_time    The Timestamp of when this Listing will end
            // Example
                //    &cache_data[]    = auctionsCheckCache(...&auction_identifiers[]);
                //    cache_hit       := %&cache_data[0]%;
                //    &cache_id        = %&cache_data[1]%;
                //    &cache_type      = %&cache_data[2]%;
                //    #cache_price    := %&cache_data[3]%;
                //    #cache_bids     := %&cache_data[4]%;
                //    cache_ended     := %&cache_data[5]%;
                //    cache_claimed   := %&cache_data[6]%;
                //    &cache_owner     = %&cache_data[7]%;
                //    &cache_profile   = %&cache_data[8]%;
                //    &cache_sbid      = %&cache_data[9]%;
                //    &cache_name      = %&cache_data[10]%;
                //    &cache_mcid      = %&cache_data[11]%;
                //    #cache_data     := %&cache_data[12]%;
                //    #cache_stack    := %&cache_data[13]%;
                //    &cache_buyers    = %&cache_data[14]%;
                //    #cache_end_time := %&cache_data[15]%;
        function auctionsCheckCache(...&auction_identifiers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:56
            // Setup Function Variables
            if(true);
                debug                  = false;
                &script_debug_name     = "&5auctionsCheckCache&7";
                &identifier_prefixes[] = split(", ","ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK, BUYER, END_TIME");
                &identifier_types[]    = split(", ","string, string, number, number, boolean, boolean, string, string, string, string, string, number, number, string, number");
                &map_type_terms[]      = split(", ","string, number, boolean");
                &map_type_prefixes[]   = split(", ","&, #, ");
                &valid_prefixes        = join("|",&identifier_prefixes[]);
                &return_array[0]       = "false";
                
                // Create Array of Unique Identifiers to match against cache entries
                debug_log(%debug%,%&script_debug_name%,"creating array of unique auction identifiers...");
                foreach(&auction_identifiers[],&auction_identifier,#ai);
                    ifmatches(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$");
                        match(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$",{&identifier_prefix,&identifier_value});
                        #filter_key_index = indexof(&filter_keys[],,%&identifier_prefix%);
                        if(%#filter_key_index% == -1);
                            #prefix_index           = indexof(&identifier_prefixes[],,%&identifier_prefix%);
                            #map_type_index         = indexof(&map_type_terms[],,%&identifier_types[%#prefix_index%]%);
                            &filter_keys[]          = %&identifier_prefix%;
                            &filter_vals[]          = %&identifier_value%;
                            &filter_type_terms[]    = %&identifier_types[%#prefix_index%]%;
                            &filter_type_prefixes[] = %&map_type_prefixes[%#map_type_index%]%;
                        else;
                            &filter_vals[%#filter_key_index%]% = %&identifier_value%;
                        endif;
                    endif;
                next;
                
                #filter_keys_sz = arraysize(&filter_keys[]);
                debug_log(%debug%,%&script_debug_name%,"found a total of &d%#filter_keys_sz% unique identifiers, they are:");
                foreach(&filter_keys[],&filter_key,#fk);
                    debug_log(%debug%,%&script_debug_name%,"%#fk% > key: %&filter_key%, value: %&filter_vals[%#fk%]%");
                next;
            endif;
            
            // Loop over Cached Entries and try to find an Entry that has a match for all the Keys we are filtering for.
            if(%#filter_keys_sz% >= 1);
                // Correct the filter_key OWNER from Username to UUID, if OWNER is in the Filter Keys Array. Do the same for BUYER.
                if(true);
                    &check_for_keys[] = split(", ","OWNER, BUYER");
                    foreach(&check_for_keys[],&check_for_key,#cfk);
                        #key_index = indexof(&filter_keys[],,%&check_for_key%);
                        if(%#key_index% != -1);
                            &minecraft_profile[]  = getMinecraftProfile(%&filter_vals[%#key_index%]%);
                            minecraft_profile    := %&minecraft_profile[0]%;
                            if(%minecraft_profile%);
                                &minecraft_joint_uuid      = %&minecraft_profile[2]%;
                                debug_log(%debug%,%&script_debug_name%,"converted key &d%&check_for_key%&7 with value &d%&filter_vals[%#key_index%]%&7 to UUID &d%&minecraft_joint_uuid%&7.");
                                &filter_vals[%#key_index%] = %&minecraft_joint_uuid%;
                            else;
                                debug_error(%debug%,%&script_debug_name%,"failed to convert key &d%&check_for_key%&7 with value &d%&filter_vals[%#key_index%]%&7 to UUID!");
                            endif;
                        endif;
                    next;
                endif;
                
                // Iteratively loop over the Cache Array that maps to the First Element of the Filter Keys Array to record all Indexes
                // where we may find a match for all the Auction Identifiers in their source Arrays. We do this to cut down on the amount of Elements
                // that we must manually iterate over.
                if(true);
                    // Check if there is an ID or OWNER Key to use as the 'primary' key. If so, prefer to use that Key as the primary key. If not, use the first index.
                    if(true);
                        #primary_key_index = 0;
                        #id_index          = indexof(&filter_keys[],,"ID");
                        #owner_index       = indexof(&filter_keys[],,"OWNER");
                        if(%#id_index% != -1);
                            #primary_key_index = %#id_index%;
                        elseif(%#owner_index% != -1);
                            #primary_key_index = %#owner_index%;
                        endif;
                    endif;
                    
                    debug_log(%debug%,%&script_debug_name%,"finding possible indices");
                    &map_type_prefix           = %&filter_type_prefixes[%#primary_key_index%]%;
                    &primary_cache_search_term = %&filter_vals[%#primary_key_index%]%;
                    &primary_cache_arr_ptr     = lcase("@%&map_type_prefix%cached_listing_%&filter_keys[%#primary_key_index%]%");
                    #loop_augment              = 0;
                    #latest_index              = -1;
                    do;
                        if(%#latest_index% >= 0);
                            debug_log(%debug%,%&script_debug_name%,"have pushed at least one element (#latest_index: %#latest_index%)");
                            #subarray_start = %#check_indices[%#latest_index%]% + 1;
                            debug_log(%debug%,%&script_debug_name%,"element at index %#latest_index% in #check_indices array is &d%#check_indices[%#latest_index%]%&7, will create subarray starting from +1 from this element (&d%#subarray_start%&7).");
                        else;
                            debug_log(%debug%,%&script_debug_name%,"have not pushed any elements, subarray_start set to 0.");
                            #subarray_start = 0;
                        endif;
                        &subarray_string = "%&primary_cache_arr_ptr%[%#subarray_start%:]";
                        push(&primary_cache_subarray[],%&subarray_string%);
                        #primary_cache_index = indexof(&primary_cache_subarray[],,%&primary_cache_search_term%);
                        if(%#primary_cache_index% != -1);
                            #previous_index = %#latest_index%;
                            #latest_index   = %#latest_index% + 1;
                            #real_index     = %#primary_cache_index% + %#subarray_start%;
                            debug_log(%debug%,%&script_debug_name%,"found element at index %#primary_cache_index% in subarray, offset &d%#subarray_start%&7 from source array, source index is &d%#real_index%&7. Incrementing #latest_index from &c%#previous_index%&7 to &a%#latest_index%&7.");
                            #check_indices[] = %#real_index%;
                        else;
                            debug_log(%debug%,%&script_debug_name%,"cannot find any more elements, breaking");
                            break;
                        endif;
                        unset(&primary_cache_subarray[]);
                    until(%#primary_cache_index% == -1);
                endif;
                
                #check_indices_sz = arraysize(#check_indices[]);
                debug_log(%debug%,%&script_debug_name%,"found total of &d%#check_indices_sz%&7 possible indices");
                if(%#check_indices_sz% >= 1);
                    debug_log(%debug%,%&script_debug_name%,"iterating over possible indices to find entries");
                    foreach(#check_indices[],#check_index,#ci);
                        debug_log(%debug%,%&script_debug_name%,"%#ci%/%#check_indices_sz% - checking index %#check_index%");
                        index_matched = true;
                        foreach(&filter_keys[],&filter_key,#fk);
                            &filter_val         = %&filter_vals[%#fk%]%;
                            &filter_type_term   = %&filter_type_terms[%#fk%]%;
                            &filter_type_prefix = %&filter_type_prefixes[%#fk%]%;
                            &filter_cache_ptr   = lcase("@%&filter_type_prefix%cached_listing_%&filter_key%[%#check_index%]");
                            &filter_cache_val   = %%&filter_cache_ptr%%;
                            val_match           = %&filter_cache_val% == %&filter_val%;
                            if(%&filter_type_term% == "boolean");
                                filter_val  := %&filter_val%;
                                cached_val  := %&filter_cache_val%;
                                val_match    = %filter_val% == %cached_val%;
                            elseif(%&filter_type_term% == "number");
                                #filter_val := %&filter_val%;
                                #cached_val := %&filter_cache_val%;
                                val_match    = %#filter_val% == %#cached_val%;
                            endif;
                            
                            if(!%val_match%);
                                debug_log(%debug%,%&script_debug_name%,"cached_listing index &d%#check_index%&7 is disqualified, term &d%&filter_key%&7 expected value &a%&filter_val%&7, indexed value was &c%&filter_cache_val%&7.");
                                index_matched = false;
                                break;
                            endif;
                        next;
                        
                        if(%index_matched%);
                            debug_log(%debug%,%&script_debug_name%,"cached_listing index &d%#check_index%&7 is &amatched&7, all terms met expected values");
                            &return_array[0] = "true";
                            foreach(&identifier_prefixes[],&identifier_prefix,#ipi);
                                #map_type_term_index    = indexof(&map_type_terms[],,%&identifier_types[%#ipi%]%);
                                &identifier_type_prefix = %&map_type_prefixes[%#map_type_term_index%]%;
                                &prefix_cache_ptr       = lcase("@%&identifier_type_prefix%cached_listing_%&identifier_prefix%[%#check_index%]");
                                &return_array[]         = %%&prefix_cache_ptr%%;
                            next;
                            break;
                        endif;
                    next;
                endif;
            endif;
            
            return(&return_array[]);
        endfunction;
    // info/index/getItemInfoSB
        // Given an Item's Display Name or SBID, looks it up in the global arrays @&sb_datamap_item_names[] and/or
        // @&sb_datamap_item_sbids[], then returns the Data found at that index accordingly.
            // Params:
                //    {string}     <&search_term>               The Item's Display Name or SBID to search for.
                //    {boolean}    [return_collection=false]    Whether or not to append Collection information to the returned Array.
                //
            // Returns an Array -- first element will be -1 if no match was found.
                //    0    {string}     &found_name        The Display Name of the Item found
                //    1    {string}     &found_sbid        The SBID of the Item found
                //    2    {string}     &found_mcid        The MCID of the Item found
                //    3    {number}     #found_data        The Data value of the Item found (0 = no data).
                //    4    {number}     #found_sell        The Sell Price of the Item found (0 = not sellable).
                //    5    {number}     #found_stack       The maximum stack size of the Item found
                //    6    {string}     &found_tier        The Tier of this Item ("" = no Tier, valid strings = COMMON, UNCOMMON, RARE, EPIC, LEGENDARY, MYTHIC, SPECIAL)
                //    7    {string}     &found_category    The Category of this Item ("" = no Category, valid strings = ACCESSORY, ARROW, ARROW_POISON, AXE, BAIT, BOOTS,
                //                                         BOW, CHESTPLATE, COSMETIC, DRILL, DUNGEON_PASS, FISHING_ROD, FISHING_WEAPON, GAUNTLET, HELMET, HOE, LEGGINGS,
                //                                         PET_ITEM, PICKAXE, REFORGE_STONE, SHEARS, SPADE, SWORD, TRAVEL_SCROLL, WAND).
                //    8    {boolean}    found_bazaar       Whether or not the Item is available for trading on Bazaar.
                //
                //
                // The following elements will also be returned if [return_collection] is set to True.
                    //    9     {boolean}    has_collection         Whether or not the Item belongs to a Collection
                    //    10    {string}     &collection_name       The Name of the Collection this Item belongs to ("NULL" = no collection).
                    //    11    {string}     &collection_cmdname    The Command String (used in /viewcollection <&collection_cmdname>) to directly enter this Collection.
                    //                                              "NULL" = no collection.
                    //    12    {string}     &collection_sbid       The SBID of the Base Item in this Collection.
                    //    13    {number}     #collection_tier       The Tier of the Collection this Item belongs to (0 = no collection).
                    //    14    {number}     #collection_amt        The Amount of Items required to have been Collected in order for this Item to be unlocked.
                    //                                              0 = no collection.
            // Example:
                // Without Collection Appended
                    //    &item_data[]    = getItemInfoSB("ENCHANTED_DIAMOND_BLOCK");
                    //    &found_name     = %&item_data[0]%;
                    //    &found_sbid     = %&item_data[1]%;
                    //    &found_mcid     = %&item_data[2]%;
                    //    #found_data    := %&item_data[3]%;
                    //    #found_sell    := %&item_data[4]%;
                    //    #found_stack   := %&item_data[5]%;
                    //    &found_tier     = %&item_data[6]%;
                    //    &found_category = %&item_data[7]%;
                    //    found_bazaar   := %&item_data[8]%;
                // With Collection Appended
                    //    &item_data[]        = getItemInfoSB("ENCHANTED_DIAMOND_BLOCK",true);
                    //    &found_name         = %&item_data[0]%;
                    //    &found_sbid         = %&item_data[1]%;
                    //    &found_mcid         = %&item_data[2]%;
                    //    #found_data        := %&item_data[3]%;
                    //    #found_sell        := %&item_data[4]%;
                    //    #found_stack       := %&item_data[5]%;
                    //    &found_tier         = %&item_data[6]%;
                    //    &found_category     = %&item_data[7]%;
                    //    found_bazaar       := %&item_data[8]%;
                    //    has_collection     := %&item_data[9]%;
                    //    &collection_name    = %&item_data[10]%;
                    //    &collection_cmdname = %&item_data[11]%;
                    //    &collection_sbid    = %&item_data[12]%;
                    //    #collection_tier   := %&item_data[13]%;
                    //    #collection_amt    := %&item_data[14]%;
        function getItemInfoSB(&search_term,return_collection=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:167
            // Find the Index of the Data we are retrieving.
            if(true);
                #name_index = indexof(@&sb_datamap_item_names[],,%&search_term%);
                #sbid_index = indexof(@&sb_datamap_item_sbids[],,%&search_term%);
                if((#name_index == -1) && (#sbid_index == -1));
                    &return_array[] = "-1";
                    return(&return_array[]);
                elseif(%#sbid_index% != -1);
                    #use_index = %#sbid_index%;
                elseif(%#name_index% != -1);
                    #use_index = %#name_index%;
                endif;
            endif;
            
            // Extract Data from the JSON Element located at the found Index.
            if(true);
                &found_json      = %@&sb_datamap_item_jsons[%#use_index%]%;
                &return_array[0] = jsonget("name",%&found_json%);
                &return_array[1] = jsonget("sbid",%&found_json%);
                &return_array[2] = jsonget("mcid",%&found_json%);
                &return_array[3] = jsonget("data",%&found_json%);
                &return_array[4] = xJsonGet("sellPrice",%&found_json%);
                &return_array[5] = jsonget("maxStack",%&found_json%);
                &return_array[6] = jsonget("tier",%&found_json%);
                &return_array[7] = jsonget("category",%&found_json%);
                &return_array[8] = jsonget("onBazaar",%&found_json%);
                if(%return_collection%);
                    &collection_json = jsonget("collection",%&found_json%);
                    has_collection   = jsonget("hasCollection",%&collection_json%);
                    &return_array[9] = %has_collection%;
                    if(%has_collection%);
                        &collection_name  = jsonget("name",%&collection_json%);
                        &return_array[10]  = %&collection_name%;
                        #coll_ext_index   = indexof(@&sb_datamap_collection_names[],,%&collection_name%);
                        &coll_ext_json    = %@&sb_datamap_collection_jsons[%#coll_ext_index%]%;
                        &return_array[11]  = jsonget("cmdName",%&coll_ext_json%);
                        &return_array[12] = jsonget("sbid",%&coll_ext_json%);
                        #collection_tier  = jsonget("tier",%&collection_json%);
                        #collection_idx   = %#collection_tier% - 1;
                        &return_array[13] = %#collection_tier%;
                        &return_array[14] = xJsonGet("tiers.%#collection_idx%.amountRequired",%&coll_ext_json%);
                        return(&return_array[]);
                    endif;
                    &return_array[10]  = "NULL";
                    &return_array[11] = "NULL";
                    &return_array[12] = "NULL";
                    &return_array[13] = "0";
                    &return_array[14] = "0";
                    return(&return_array[]);
                endif;
                return(&return_array[]);
            endif;
        endfunction;
    // auctions/getListingInfo/auctionsDecodeItemData
        // Given an Auction's JSON Data, grabs the Auction's 'item_bytes.data' Field and submits it to the local NBT decoder API to convert it.
            // Params:
                // {string} <&auction_json>    The Auction JSON to extract Data from.
                //
            // Status String ENUMs:
                // SUCCESS               Successfully decoded the Data
                // ERROR_INVALID_DATA    Invalid Input Data
                // ERROR_SERVER          Decode API is Down
                // ERROR_UNKNOWN         Unknown Error occurred
            // Returns an Array:
                // 0 {string} &decoded_status    String ENUM describing the Status of the Decode Request. Possible values are defined above.
                // 1 {string} &decoded_sbid      The Auction Listing Item SBID
                // 2 {string} &decoded_mcid      The Auction listing Item MCID
                // 3 {string} &decoded_name      The Auction Listing Item Name
                // 4 {number} #decoded_data      The Auction Listing Item Data/Damage Value
                // 5 {number} #decoded_stack     The Stack Size of the Auction Listing Item
            // Example:
                //    &decoded_bytes[] = auctionsDecodeItemData(%&auction_json%);
                //    &decoded_status  = %&decoded_bytes[0]%;
                //    &decoded_sbid    = %&decoded_bytes[1]%;
                //    &decoded_mcid    = %&decoded_bytes[2]%;
                //    &decoded_name    = %&decoded_bytes[3]%;
                //    #decoded_data   := %&decoded_bytes[4]%;
                //    #decoded_stack  := %&decoded_bytes[5]%;
        function auctionsDecodeItemData(&auction_json);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:335
            // Setup Function Variables
            if(true);
                debug                    = true;
                &script_debug_name       = "&9auctionsDecodeItemData&7";
                &enum_success            = "SUCCESS";
                &enum_error_invalid_data = "ERROR_INVALID_DATA";
                &enum_error_server       = "ERROR_SERVER";
                &enum_error_unknown      = "ERROR_UNKNOWN";
                &decode_api_url          = "http://localhost:8080/";
                &decoded_status          = %&enum_error_unknown%;
                ifmatches(%&decode_api_url%,"localhost");
                    log("&4&lWARNING: auctionsDecodeItemData is using localhost decoder API! Change to remote hosted decoder API before release to Production.")
                endif;
                
                setrequestheader("User-Agent",%UUID%);
                setrequestheader("Content-Type","application/json");
            endif;
            
            // Handle the API Request.
            if(true);
                &encoded_data = jsonget("item_bytes.data",%&auction_json%);
                ifmatches(%&encoded_data%,"^ERROR_");
                    debug_error(%debug%,%&script_debug_name%,"Invalid Auction JSON Data passed to Function, cannot extract item_bytes.data Field: &4%&auction_json%&c.");
                    &decoded_status  = %&enum_error_invalid_data%;
                else;
                    &request_body    = "{\"data\":\"%&encoded_data%\"}";
                    &server_response = httppost(%&decode_api_url%,%&request_body%,#decoded_code);
                    if(%#decoded_code% == 200);
                        &decoded_status  = %&enum_success%;
                        &decoded_sbid    = getItemSBID(%&server_response%);
                        &decoded_data[]  = getItemInfoSB(%&decoded_sbid%);
                        &decoded_sbid    = %&decoded_data[1]%;
                        &decoded_mcid    = %&decoded_data[2]%;
                        #decoded_data   := %&decoded_data[3]%;
                        #decoded_stack   = jsonget("Count",%&server_response%);
                        &decoded_name    = jsonget("item_name",%&auction_json%);
                        &decoded_name    = strip(%&decoded_name%);
                    elseif(%#decoded_code% == -1);
                        &decoded_status  = %&enum_error_server%;
                    elseif(%#decoded_code% == 500);
                        &decoded_status  = %&enum_error_server%;
                    endif;
                endif;
                
                &vars[] = split(" ","&decoded_status &decoded_sbid &decoded_mcid &decoded_name #decoded_data #decoded_stack");
                foreach(&vars[],&var,#v);
                    &val = %%&var%%;
                    &logvar = regexreplace(&var,"(?<!&)&","&&");
                    debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar% : %&val%");
                next;
                
                &return_array[] = split(", ","%&decoded_status%, %&decoded_sbid%, %&decoded_mcid%, %&decoded_name%, %#decoded_data%, %#decoded_stack%");
            endif;
            return(&return_array[]);
        endfunction;
    // debug/index/debug_breakpoint
        // Logs a message to chat and halts until SHIFT is held.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_breakpoint(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:70
            // &matcher       = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement   = "&$1";
            // &string        = regexreplace(&string,%&matcher%,%&replacement%);
            &break_message = "&7%&script_debug_name%&7: &8Breakpoint (HOLD SHIFT)&7 > %&string%";
            if(%debug_enabled%);
                log(%&break_message%);
                do;wait("1t");until(%SHIFT%);
                do;wait("1t");while(%SHIFT%);
            endif;
            return(%&break_message%);
        endfunction;
    // auctions/getListingInfo/auctionsDecodeListingsData
        // Similar to auctionsDecodeItemData, except decodes an Array of Auction's 'item_bytes.data' Fields.
            // Params:
                // {string} <&all_auctions_json>    All of the Auction JSONs to extract Data from.
                //
            // Status String ENUMs:
                // SUCCESS               Successfully decoded the Data
                // ERROR_INVALID_DATA    Invalid Input Data
                // ERROR_SERVER          Decode API is Down
                // ERROR_UNKNOWN         Unknown Error occurred
            // Returns an Array where the first Element is the Decode Status ENUM, then the remaining are Tunnel Split Strings, where each String holds Data in Format:
                // 0 {string} &decoded_sbid     The Auction Listing Item SBID
                // 1 {string} &decoded_mcid     The Auction listing Item MCID
                // 2 {string} &decoded_name     The Auction Listing Item Name
                // 3 {number} #decoded_data     The Auction Listing Item Data/Damage Value
                // 4 {number} #decoded_stack    The Stack Size of the Auction Listing Item
            // Example:
                //    &decoded_auctions[] = auctionsDecodeListingsData(%&all_auctions_json%);
                //    foreach(&decoded_auctions[],&decoded_auction,#dai);
                //        if(%#dai% == 0);
                //            &decoded_status = %&decoded_auction%;
                //            if(%&decoded_status% == "SUCCESS");
                //            else;
                //                if(%&decoded_status% == "ERROR_INVALID_DATA");
                //                elseif(%&decoded_status% == "ERROR_SERVER");
                //                elseif(%&decoded_status% == "ERROR_UNKNOWN");
                //                endif;
                //            endif;
                //        else;
                //            &decoded_auction[]  = split("|",%&decoded_auction%);
                //            &decoded_sbid       = %&decoded_auction[0]%;
                //            &decoded_mcid       = %&decoded_auction[1]%;
                //            &decoded_name       = %&decoded_auction[2]%;
                //            #decoded_data      := %&decoded_auction[3]%;
                //            #decoded_stack     := %&decoded_auction[4]%;
                //        endif;
                //    next;
        function auctionsDecodeListingsData(&all_auctions_json);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:248
            // Setup Function Variables
            if(true);
                debug                    = false;
                &script_debug_name       = "&9auctionsDecodeListingsData&7";
                &enum_success            = "SUCCESS";
                &enum_error_invalid_data = "ERROR_INVALID_DATA";
                &enum_error_server       = "ERROR_SERVER";
                &enum_error_unknown      = "ERROR_UNKNOWN";
                &decode_api_url          = "http://localhost:8080/multi";
                &return_array[0]         = %&enum_error_unknown%;
                ifmatches(%&decode_api_url%,"localhost");
                    log("&4&lWARNING: auctionsDecodeListingsData is using localhost decoder API! Change to remote hosted decoder API before release to Production.")
                endif;
                
                setrequestheader("User-Agent",%UUID%);
                setrequestheader("Content-Type","application/json");
            endif;
            
            // Handle the API Request.
            if(true);
                // Compile the Listings
                do;
                    &encoded_data = jsonget("auctions.%#auction_index%.item_bytes.data",%&all_auctions_json%);
                    ifmatches(%&encoded_data%,"^ERROR_");
                        debug_log(%debug%,%&script_debug_name%,"final auction index is %#auction_index%");
                        #final_index = %#auction_index%;
                        break;
                    endif;
                    
                    &decode_strings[] = "\"%&encoded_data%\"";
                    inc(#auction_index);
                loop;
                
                #decode_strings_sz = arraysize(&decode_strings[]);
                if(%#decode_strings_sz% >= 1);
                    &decode_strings  = join(",",&decode_strings[]);
                    &request_body    = "{\"listings\":[%&decode_strings%]}";
                    &server_response = httppost(%&decode_api_url%,%&request_body%,#decoded_code);
                    if(%#decoded_code% == 200);
                        &return_array[0] = %&enum_success%;
                        for(#auction_index,0,%#final_index%);
                            &decoded_nbt     = jsonget(%#auction_index%,%&server_response%);
                            &decoded_sbid    = getItemSBID(%&decoded_nbt%);
                            &decoded_data[]  = getItemInfoSB(%&decoded_sbid%);
                            &decoded_sbid    = %&decoded_data[1]%;
                            &decoded_mcid    = %&decoded_data[2]%;
                            #decoded_data   := %&decoded_data[3]%;
                            #decoded_stack   = jsonget("Count",%&decoded_nbt%);
                            &decoded_name    = jsonget("auctions.%#auction_index%.item_name",%&all_auctions_json%);
                            &decoded_name    = strip(%&decoded_name%);
                            &return_array[]  = "%&decoded_sbid%|%&decoded_mcid%|%&decoded_name%|%#decoded_data%|%#decoded_stack%";
                        next;
                    elseif((%#decoded_code% == -1) || (%#decoded_code% == 500));
                        &return_array[0] = %&enum_error_server%;
                    endif;
                else;
                    debug_error(%debug%,%&script_debug_name%,"did not find any decode_strings in passed all_auctions_json!");
                endif;
            endif;
            return(&return_array[]);
        endfunction;
    // api/index/getHypixelAPIRequestLimit
        // Gets the limiting variables for the current Player.
            // Params:
            //        None
            //
            // Returns an Array:
            //        0 <integer> #reqs_in_last_min : Total requests in the last 60 seconds.
            //        1 <integer> #reqs_avail_now   : Total requests available now before hitting throttle.
            //        2 <integer> #wait_timestamp   : Timestamp to wait till before making the next request to avoid being throttled.
        function getHypixelAPIRequestLimit();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:45
            &script_debug_name = "&9getHypixelAPIRequestLimit&7";
            debug              = true;
            #max_req_per_min   = 120;
        
            #api_reqs = arraysize(@#api_req_ts[]);
            if(%#api_reqs% >= 1);
                #array_end = %#api_reqs% - 1;
                for(#i,%#array_end%,0);
                    #api_req_ts  = %@#api_req_ts[%#i%]%;
                    #elapsed_sec = %TIMESTAMP% - %#api_req_ts%;
                    if(%#elapsed_sec% <= 120);
                        #save_timestamps[] = %#api_req_ts%;
                    endif;
                next;
        
                unset(@#api_req_ts[]);
                push(@#api_req_ts[],#save_timestamps[*]);
        
            endif;
        
            #reqs_in_last_min = arraysize(#save_timestamps[]);
            #reqs_avail_now   = 120 - %#reqs_in_last_min%;
            #wait_timestamp   = %TIMESTAMP% + ((%#reqs_in_last_min% - 120) / 2);
            return(%#reqs_in_last_min%,%#reqs_avail_now%,%#wait_timestamp%);
        endfunction;
    // string/index/isStringUUID
        // Checks if a string matches UUID regex.
            // Params:
            //        <string> &check_string : The string to check
            //
            // Returns a boolean.
            //
        function isStringUUID(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:28
            &script_debug_name = "&9isStringUUID&7";
            debug              = false;
            &split_uuid_expr   = "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$";
            &joint_uuid_expr   = "^[a-f0-9]{32}$";
            &uuid_exprs[]      = split(", ","%&split_uuid_expr%, %&joint_uuid_expr%");
            foreach(&uuid_exprs[],&uuid_expr);
                ifmatches(%&check_string%,%&uuid_expr%);
                    match_found = true;
                    break;
                endif;
            next;
            return(%match_found%);
        endfunction;
    // api/index/getHypixelAPIKey
        // Gets a new Hypixel API Key.
            // Params:
            //        None
            //
            // Returns the new API Key String.
        function getHypixelAPIKey();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:6
            &script_debug_name = "&9getHypixelAPIKey&7";
            debug              = false;
            &old_api_key       = %@&api_key%;
            
            // Check if we need to get onto a Hypixel Server (not in Limbo) before execution.
            &hy_gamemode = getHypixelGamemode();
            if(%&hy_gamemode% == "LIMBO");
                do;
                    on_server = gotoServer("SKYBLOCK");
                    if(%on_server%);
                        break;
                    endif;
                    wait("1t");
                until(%on_server%);
            endif;
            
            do;
                echo("/api new");
                do(20);
                    wait("1t");
                until(%&old_api_key% != %@&api_key%);
                if(%&old_api_key% != %@&api_key%);
                    &new_api_key  = %@&api_key%;
                    new_valid_key = isStringUUID(%&new_api_key%);
                    &old_api_key  = %&new_api_key%;
                endif;
            until(%new_valid_key%);
            return(%&new_api_key%);
        endfunction;
    // api/index/hypixelAPICall
        // Makes a Hypixel API Call.
            // Params:
                // {string}  <&api_url>                The endpoint to call
                // {string}  [&api_key=%@&api_key%]    The API Key to use with the request. Defaults to @&api_key
                // {boolean} [recursion=false]         True if this function was called by itself. Defaults to false
            // Returns an Array:
                // 0 {boolean}    req_success    True if we received response from API, false if we got throttled by CF.
                // 1 {boolean}    api_success    The value of the 'success' key in the API response.
                // 2 {integer}    #api_code      The HTTP Response Code from the API Request.
                // 3 {string}     &api_resp      The raw JSON data returned from the Server.
            // Example:
                // &api_data[]  = hypixelAPICall(%&api_url%);
                // req_success := %&api_data[0]%; // True if we received response from API, false if we got throttled by CF.
                // api_success := %&api_data[1]%; // The value of the 'success' key in the API response.
                // #api_code   := %&api_data[2]%; // The HTTP Response Code from the API Request.
                // &api_resp    = %&api_data[3]%; // The raw JSON data returned from the Server.
        function hypixelAPICall(&api_url,&api_key=%@&api_key%,recursion=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:88
            &script_debug_name = "&9hypixelAPICall&7";
            debug              = true;
            
            // Setup variables
            if(true);
                key_needed     = true;
                req_success    = false;
                api_success    = false;
                #api_code      = -1;
                &api_resp      = "";
                #retry_codes[] = split(", ","403, 429, 503"); // 403: invalid api key, 429: throttled, 503: data unavailable right now
        
                // Setup known API Endpoints
                if(true);
                    &api_endpoints[] = "false|skyblock/auctions_ended";
                    &api_endpoints[] = "true|skyblock/auctions";
                    &api_endpoints[] = "true|skyblock/profiles";
                    &api_endpoints[] = "true|skyblock/auction";
                    &api_endpoints[] = "true|skyblock/profile";
                    &api_endpoints[] = "false|skyblock/bazaar";
                    &api_endpoints[] = "true|punishmentstats";
                    &api_endpoints[] = "true|skyblock/news";
                    &api_endpoints[] = "true|leaderboards";
                    &api_endpoints[] = "true|recentgames";
                    &api_endpoints[] = "false|resources";
                    &api_endpoints[] = "true|boosters";
                    &api_endpoints[] = "true|friends";
                    &api_endpoints[] = "true|player";
                    &api_endpoints[] = "true|status";
                    &api_endpoints[] = "true|counts";
                    &api_endpoints[] = "true|guild";
                    &api_endpoints[] = "true|key";
                endif;
        
                // Find the endpoint we are hitting
                if(true);
                    &api_uri = regexreplace(&api_url,"https://api.hypixel.net/","");
                    &use_uri = "";
                    foreach(&api_endpoints[],&api_endpoint,#aei);
                        &this_data[]   = split("|",%&api_endpoint%);
                        this_key_req  := %&this_data[0]%;
                        &this_endpoint = %&this_data[1]%;
                        ifmatches(%&api_uri%,"^%&this_endpoint%");
                            &use_uri   = %&this_endpoint%;
                            key_needed = %this_key_req%;
                            break;
                        endif;
                    next;
                    skip_req = %&use_uri% == "";
                endif;
            endif;
        
            // Validate the API Key passed to the function, if we are going to be using one.
            if((!%skip_req%) && (%key_needed%));
                key_test = isStringUUID(%&api_key%);
                if(!%key_test%);
                    debug_error(%debug%,%&script_debug_name%,"Parameter 'api_key' is invalid UUID: &4%&api_key%&7. Attempting to fix");
                    global_test = isStringUUID(%@&api_key%);
                    if(%global_test%);
                        &api_key = %@&api_key%;
                        debug_log(%debug%,%&script_debug_name%,"Using environment api_key instead (&a%@&api_key%&7).");
                    else;
                        &new_key  = getHypixelAPIKey();
                        new_valid = isStringUUID(%&new_key%);
                        if(%new_valid%);
                            debug_log(%debug%,%&script_debug_name%,"Using new api_key instead (&a%&new_key%&7).");
                            &api_key = %&new_key%;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Failed to get a new valid API key to use.");
                        endif;
                    endif;
                    key_test = isStringUUID(%&api_key%);
                    skip_req = !%key_test%;
                endif;
            endif;
        
            // Make the request, if we are making the request.
            if(true);
                if(!%skip_req%);
                    if(%key_needed%);
                        setrequestheader("API-Key",%&api_key%);
                        #throttle_vars[]  = getHypixelAPIRequestLimit();
                        #reqs_in_last_min = %#throttle_vars[0]%;
                        #reqs_avail_now   = %#throttle_vars[1]%;
                        #wait_timestamp   = %#throttle_vars[2]%;
        
                        if(%#reqs_avail_now% <= 0);
                            #wait_seconds = %#wait_timestamp% - %TIMESTAMP%;
                            debug_log(%debug%,%&script_debug_name%,"Delaying request by &d%#wait_seconds% seconds&7 to avoid being limited by Hypixel API.");
                            wait("%#wait_seconds%s");
                            &return_array[] = call("hypixelAPICall",%&api_url%,%&api_key%);
                            return(&return_array[]);
                        endif;
                    endif;
        
                    // Add the base URL to the request URL if it was not provided.
                    ifmatches(%&api_url%,"^https://api.hypixel.net");else;
                        &api_parts[] = "https://api.hypixel.net"
                        ifmatches(%&api_url%,"^/");else;
                            &api_parts[] = "/";
                        endif;
                        &api_parts[] = %&api_url%;
                        &api_url     = join("",&api_parts[]);
                    endif;
        
                    @#api_req_ts[] = %TIMESTAMP%;
                    &api_resp      = httpget(%&api_url%,,#api_code);
                    &success       = jsonget("success",%&api_resp%);
                    ifmatches(%&success%,"ERROR_"); // If we got an unexpected error, it normally means we got throttled by CloudFlare.
                        &req_uuid      = %UNIQUEID%;
                        &log_strings[] = "-----"
                        &log_strings[] = "Request Date: %DATETIME%";
                        &log_strings[] = "Request UUID: %&req_uuid%";
                        &log_strings[] = "Request URL : %&api_url%";
                        &log_strings[] = "Request Key : %&api_key%";
                        &log_strings[] = " ";
                        &log_strings[] = "Response Code: %#api_code%";
                        &log_strings[] = "Response Body: %&api_resp%";
                        &log_strings[] = " ";
                        &log_strings[] = " ";
                        &log_path[]    = split(%FILESEPARATOR%,%MACROSCONFIGDIR%);
                        &log_path[]    = "logs";
                        &log_path[]    = "bad_requests.txt";
                        &log_path      = join(%FILESEPARATOR%,&log_path[]);
                        writefile(%&log_path%,&log_strings[],true);
                        debug_error(%debug%,%&script_debug_name%,"Got a bad request from the API call, response logged to file:");
                        &vars[] = split(" ","&req_uuid &log_path #api_code");
                        foreach(&vars[],&var,#v);
                            &_var = regexreplace(&var,"&","&&");
                            &val  = "%%&var%%";
                            debug_log(%debug%,%&script_debug_name%,"%#v% > %&_var%: &d%&val%&7.");
                        next;
                    else;
                        req_success  = true;
                        api_success := %&success%;
                        #retry_index = indexof(#retry_codes[],,%#api_code%);
        
                        // If the request was unsuccessful and the Response Code is an error that we can fix, attempt to do so.
                        if((!%api_success%) && (%#retry_index% != -1) && (!%recursion%));
                            if(%#api_code% == 403); // invalid api key
                                &api_key = getHypixelAPIKey();
                            elseif((%#api_code% == 429) || (%#api_code% == 503)); // throttled = 429, 503 = data unavailable right now
                                wait("10000ms");
                            endif;
        
                            skip_return_arr = true;
                            &return_array[] = call("hypixelAPICall",%&api_url%,%&api_key%,true);
                        endif;
                    endif;
                elseif(%&use_uri% == "");
                    debug_error(%debug%,%&script_debug_name%,"Could not find API Endpoint from URL: &4%&api_url%&7.");
                endif;
            endif;
        
            // Populate the return array, unless it was already populated.
            if(!%skip_return_arr%);
                &return_array[] = %req_success%;
                &return_array[] = %api_success%;
                &return_array[] = %#api_code%;
                &return_array[] = %&api_resp%;
            endif;
            return(&return_array[]);
        endfunction;
    // auctions/getListingInfo/auctionsGetListingInfoFromAPI
        // Given an Auction's ID, and/or the Auctioneer's Username and as much identifying information regarding the Item as is possible, finds the Auction
        // Listing from the API and returns it's Data.
            // Params:
                // {string} <...&auction_identifiers[]>    An Array of Auction Identifiers in format: '<ID_TYPE>: <ID_DATA>'. If multiple instances of a given
                //                                         ID_TYPE are encountered, the one that appears latest in the Array is used. Valid ID_TYPE Prefixes are
                //                                         at the end of this Comment.
            // Valid ID_TYPE Prefixes:
                // {string} ID          The Listing ID
                // {string} TYPE        The Listing Type (one of: BIN, AUCTION)
                // {number} PRICE       The Current Listing Price
                // {number} BIDS        The amount of Bids on the Listing
                // {boolean} ENDED      Whether or not the Listing has Ended
                // {boolean} CLAIMED    Whether or not the Listing has been claimed
                // {string} OWNER       The UUID of the Player that created this Listing
                // {string} PROFILE     The Profile ID the Owner of this Listing was using to create this Listing
                // {string} SBID        The SkyBlock ID of the Item that this Listing represents
                // {string} NAME        The Display Name of the Item that this Listing represents
                // {string} MCID        The Minecraft Item ID that this Listing represents
                // {number} DATA        The Data Value of the Item that this Listing represents
                // {number} STACK       The Stack Size of the Item that this Listing represents
                // {string} BUYER       A UUID of a Player who purchased/claimed this Listing.
                // {number} END_TIME    The Timestamp of when this Listing will end
            // Returns an Array:
                // 0  {boolean} api_hit          Whether or not an Item from the api was found that matches the specified Auction Identifiers.
                // 1  {string}  &api_id          The Listing ID
                // 2  {string}  &api_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #api_price       The Current Listing Price
                // 4  {number}  #api_bids        The amount of Bids on the Listing
                // 5  {boolean} api_ended        Whether or not the Listing has Ended
                // 6  {boolean} api_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &api_owner       The UUID of the Player that created this Listing
                // 8  {string}  &api_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &api_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &api_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &api_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #api_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #api_stack       The Stack Size of the Item that this Listing represents
                // 14 {string}  &api_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #api_end_time    The Timestamp of when this Listing will end
            // Example
                //    &api_data[]    = auctionsGetListingInfoFromAPI(...&auction_identifiers[]);
                //    api_hit       := %&api_data[0]%;
                //    &api_id        = %&api_data[1]%;
                //    &api_type      = %&api_data[2]%;
                //    #api_price    := %&api_data[3]%;
                //    #api_bids     := %&api_data[4]%;
                //    api_ended     := %&api_data[5]%;
                //    api_claimed   := %&api_data[6]%;
                //    &api_owner     = %&api_data[7]%;
                //    &api_profile   = %&api_data[8]%;
                //    &api_sbid      = %&api_data[9]%;
                //    &api_name      = %&api_data[10]%;
                //    &api_mcid      = %&api_data[11]%;
                //    #api_data     := %&api_data[12]%;
                //    #api_stack    := %&api_data[13]%;
                //    &api_buyers    = %&api_data[14]%;
                //    #api_end_time := %&api_data[15]%;
        function auctionsGetListingInfoFromAPI(...&auction_identifiers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:449
            // Setup Function Variables
            if(true);
                debug                  = false;
                &script_debug_name     = "&3auctionsGetListingInfoFromAPI&7";
                &identifier_paths[]    = split(", ","uuid, NULL, NULL, NULL, NULL, claimed, auctioneer, profile_id, NULL, item_name, NULL, NULL, NULL, NULL, NULL");
                &identifier_prefixes[] = split(", ","ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK, BUYER, END_TIME");
                &identifier_types[]    = split(", ","string, string, number, number, boolean, boolean, string, string, string, string, string, number, number, string, number");
                &map_type_terms[]      = split(", ","string, number, boolean");
                &map_type_prefixes[]   = split(", ","&, #, ");
                &valid_prefixes        = join("|",&identifier_prefixes[]);
                api_hit                = false;
                
                // Create Array of Unique Identifiers to match against cache entries
                foreach(&auction_identifiers[],&auction_identifier,#ai);
                    ifmatches(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$");
                        match(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$",{&identifier_prefix,&identifier_value});
                        #filter_key_index = indexof(&filter_keys[],,%&identifier_prefix%);
                        if(%#filter_key_index% == -1);
                            #prefix_index           = indexof(&identifier_prefixes[],,%&identifier_prefix%);
                            #map_type_index         = indexof(&map_type_terms[],,%&identifier_types[%#prefix_index%]%);
                            &filter_keys[]          = %&identifier_prefix%;
                            &filter_vals[]          = %&identifier_value%;
                            &filter_type_terms[]    = %&identifier_types[%#prefix_index%]%;
                            &filter_type_prefixes[] = %&map_type_prefixes[%#map_type_index%]%;
                            &filter_paths[]         = %&identifier_paths[%#prefix_index%]%;
                        else;
                            &filter_vals[%#filter_key_index%]% = %&identifier_value%;
                        endif;
                    endif;
                next;
                
                #filter_keys_sz = arraysize(&filter_keys[]);
            endif;
            
            // Loop over Cached Entries and try to find an Entry that has a match for all the Keys we are filtering for.
            if(%#filter_keys_sz% >= 1);
                // Determine the Method we will be using to find the Auction Listing (did we get an Auction ID, or the Auctioneer's UUID?)
                if(true);
                    #id_index      = indexof(&filter_keys[],,"ID");
                    #owner_index   = indexof(&filter_keys[],,"OWNER");
                    got_listing_id = %#id_index% != -1;
                    got_owner_id   = %#owner_index% != -1;
                    
                    if((%got_listing_id%) || (%got_owner_id%));
                        #buyer_index = indexof(&filter_keys[],,"BUYER");
                        if(%#buyer_index% != -1);
                            &split_buyers[] = split("~",%&filter_vals[%#buyer_index%]%);
                            foreach(&split_buyers[],&split_buyer,#sbi);
                                &buyer_profile[]   = getMinecraftProfile(%&split_buyer%);
                                buyer_profile     := %&buyer_profile[0]%;
                                if(%buyer_profile%);
                                    &buyer_joint_uuid    = %&buyer_profile[2]%;
                                    &fixed_buyer_uuids[] = %&buyer_joint_uuid%;
                                    do_fixed_buyer       = true;
                                endif;
                            next;
                            
                            if(%do_fixed_buyer%);
                                &filter_vals[%#buyer_index%] = join("~",&fixed_buyer_uuids[]);
                            else;
                                &filter_keys[]          = arrayDelete(&filter_keys[],%#buyer_index%);
                                &filter_vals[]          = arrayDelete(&filter_vals[],%#buyer_index%);
                                &filter_type_terms[]    = arrayDelete(&filter_type_terms[],%#buyer_index%);
                                &filter_type_prefixes[] = arrayDelete(&filter_type_prefixes[],%#buyer_index%);
                                &filter_paths[]         = arrayDelete(&filter_paths[],%#buyer_index%);
                            endif;
                        endif;
                    endif;
                endif;
                
                // Execute the branch corresponding to which Data Types we received.
                if(true);
                    debug_log(%debug%,%&script_debug_name%,"Making API Call...");
                    if(%got_listing_id%);
                        // Get the API Data
                        if(true);
                            &api_url     = "skyblock/auction?uuid=%&filter_vals[%#id_index%]%";
                            &api_data[]  = hypixelAPICall(%&api_url%);
                            req_success := %&api_data[0]%; // True if we received response from API, false if we got throttled by CF.
                            api_success := %&api_data[1]%; // The value of the 'success' key in the API response.
                            #api_code   := %&api_data[2]%; // The HTTP Response Code from the API Request.
                            &api_resp    = %&api_data[3]%; // The raw JSON data returned from the Server.
                            debug_log(%debug%,%&script_debug_name%,"Making API Call to %&api_url%, outcome req %req_success%, outcome api %api_success%, code %#api_code%");
                        endif;
                        
                        // If the API Data Request was successful, set the Auction JSON Match.
                        if((%req_success%) && (%api_success%));
                            &auction_json = jsonget("auctions.0",%&api_resp%);
                            ifnotmatches(%&auction_json%,"^ERROR_");
                                debug_log(%debug%,%&script_debug_name%,"Found Auction");
                                auction_found = true;
                            endif;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Did not get any usable Data from the API!");
                        endif;
                    elseif(%got_owner_id%);
                        // Get the Owner's UUID
                        if(true);
                            &owner_raw_input       = %&filter_vals[%#owner_index%]%;
                            &minecraft_profile[]   = getMinecraftProfile(%&owner_raw_input%);
                            minecraft_profile     := %&minecraft_profile[0]%;
                            &minecraft_username    = %&minecraft_profile[1]%;
                            &minecraft_joint_uuid  = %&minecraft_profile[2]%;
                            &minecraft_split_uuid  = %&minecraft_profile[3]%;
                        endif;
                        if(%minecraft_profile%);
                            // Get the API Data
                            if(true);
                                &filter_vals[%#owner_index%]  = %&minecraft_joint_uuid%;
                                &api_url                      = "skyblock/auction?player=%&minecraft_joint_uuid%";
                                &api_data[]                   = hypixelAPICall(%&api_url%);
                                req_success                  := %&api_data[0]%; // True if we received response from API, false if we got throttled by CF.
                                api_success                  := %&api_data[1]%; // The value of the 'success' key in the API response.
                                #api_code                    := %&api_data[2]%; // The HTTP Response Code from the API Request.
                                &api_resp                     = %&api_data[3]%; // The raw JSON data returned from the Server.
                            endif;
                            
                            // If the API Data Request was successful, iterate over all of the Owner's Auctions looking for a Match against all the Filtered Values.
                            if((%req_success%) && (%api_success%));
                                &decoded_auction_jsons[] = auctionsDecodeListingsData(%&api_resp%);
                                &decoded_status          = %&decoded_auction_jsons[0]%;
                                if(%&decoded_status% != "SUCCESS");
                                    debug_breakpoint(%debug%,%&script_debug_name%,"auctionsDecodeListingsData failed: &4%&decoded_status%&7.");
                                endif;
                                
                                auction_found            = false;
                                no_more_auctions         = false;
                                do;
                                    &auction_json = jsonget("auctions.%#loop_counter%",%&api_resp%);
                                    ifmatches(%&auction_json%,"^ERROR_");
                                        no_more_auctions = true;
                                        break;
                                    endif;
                                    
                                    #get_from_index   = %#loop_counter% + 1;
                                    &decoded_bytes[]  = split("|",%&decoded_auction_jsons[%#get_from_index%]%);
                                    &decoded_sbid     = %&decoded_bytes[0]%;
                                    &decoded_mcid     = %&decoded_bytes[1]%;
                                    &decoded_name     = %&decoded_bytes[2]%;
                                    #decoded_data    := %&decoded_bytes[3]%;
                                    #decoded_stack   := %&decoded_bytes[4]%;
                                    auction_found     = true;
                                    foreach(&filter_keys[],&filter_key,#fki);
                                        &filter_val    = %&filter_vals[%#fki%]%;
                                        &filter_type   = %&filter_type_terms[%#fki%]%;
                                        &filter_prefix = %&filter_type_prefixes[%#fki%]%;
                                        &filter_path   = %&filter_paths[%#fki%]%;
                                        filter_match   = false;
                                        
                                        // Check if the Auction's Data matches what we are filtering for with this Key.
                                        if(true);
                                            // ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK
                                            if(%&filter_path% != "NULL");
                                                &json_value  = xJsonGet(%&filter_path%,%&auction_json%);
                                                &json_value  = strip(%&json_value%);
                                                &json_value  = lcase(%&json_value%);
                                                &filter_val  = strip(%&filter_val%);
                                                &filter_val  = lcase(%&filter_val%);
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "TYPE");
                                                &json_value = jsonget("bin",%&auction_json%);
                                                ifmatches(%&json_value%,"^ERROR_");
                                                    &json_value = "AUCTION";
                                                else;
                                                    &json_value = "BIN";
                                                endif;
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "PRICE");
                                                #highest_bid = xJsonGet("highest_bid_amount",%&auction_json%);
                                                if(%#highest_bid% > 0);
                                                    &json_value = %#highest_bid%;
                                                else;
                                                    &json_value = xJsonGet("starting_bid",%&auction_json%);
                                                endif;
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "BIDS");
                                                &bids_array   = jsonget("bids",%&auction_json%);
                                                &bids_array[] = getjsonasarray(%&bids_array%);
                                                #bids_array   = arraysize(&bids_array[]);
                                                if(%#bids_array% > 1);
                                                    #bids_array = %#bids_array% - 1;
                                                endif;
                                                &json_value  = %#bids_array%;
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "ENDED");
                                                claimed_auction       = jsonget("claimed",%&auction_json%);
                                                &first_claimed_bidder = jsonget("claimed_bidders.0",%&auction_json%);
                                                &end_timestamp        = xJsonGet("end",%&auction_json%);
                                                setclipboard(%&auction_json%);
                                                
                                                if(%claimed_auction%);
                                                    debug_log(%debug%,%&script_debug_name%,"claimed_auction == true (%claimed_auction%) from auction_json. on clipboard");
                                                    json_value = true;
                                                elseifnotmatches(%&first_claimed_bidder%,"^ERROR_");
                                                    debug_log(%debug%,%&script_debug_name%,"first_claimed_bidder: &d%&first_claimed_bidder%&7.");
                                                    json_value = true;
                                                else;
                                                    #end_timestamp_rounded = xEval("ceil(%&end_timestamp% / 1000)",true);
                                                    json_value = %TIMESTAMP% >= %#end_timestamp_rounded%;
                                                    if(%json_value%);
                                                        debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) >= end_timestamp_rounded (%#end_timestamp_rounded%)");
                                                    else;
                                                        debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) < end_timestamp_rounded (%#end_timestamp_rounded%)");
                                                    endif;
                                                endif;
                                                
                                                filter_val   := %&filter_val%;
                                                filter_match  = %filter_val% == %json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %filter_val%, have: &8%json_value%&7.");
                                            elseif(%&filter_key% == "SBID");
                                                filter_match  = %&decoded_sbid% == %&filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&decoded_sbid%&7.");
                                            elseif(%&filter_key% == "MCID");
                                                filter_match  = %&decoded_mcid% == %&filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&decoded_mcid%&7.");
                                            elseif(%&filter_key% == "DATA");
                                                #filter_val  := %&filter_val%;
                                                filter_match  = %#decoded_data% == %#filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %#filter_val%, have: &8%#decoded_data%&7.");
                                            elseif(%&filter_key% == "STACK");
                                                #filter_val  := %&filter_val%;
                                                filter_match  = %#decoded_stack% == %#filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %#filter_val%, have: &8%#decoded_stack%&7.");
                                            elseif(%&filter_key% == "BUYER");
                                                &json_value = jsonget("claimed_bidders",%&auction_json%);
                                                ifnotmatches(%&json_value%,"^ERROR_");
                                                    #buyer_index = 0;
                                                    do;
                                                        &buyer_uuid = jsonget("claimed_bidders.%#buyer_index%",%&auction_json%);
                                                        ifmatches(%&buyer_uuid%,"^ERROR_");
                                                            break;
                                                        endif;
                                                        &buyer_uuids[] = %&buyer_uuid%;
                                                        &json_value    = "ARRAY";
                                                        inc(#buyer_index);
                                                    loop;
                                                else;
                                                    &json_value = "NULL";
                                                endif;
                                                
                                                if((%&json_value% == "NULL") && ((%&filter_val% == "NULL") || (%&filter_val% == "")));
                                                    filter_match = true;
                                                elseif((%&json_value% == "ARRAY") && ((%&filter_val% != "NULL") && (%&filter_val% != "")));
                                                    filter_match = true;
                                                    &split_buyers[] = split("~",%&filter_val%);
                                                    foreach(&split_buyers[],&split_buyer,#sbi);
                                                        #buyer_uuid_index = indexof(&buyer_uuids[],,%&split_buyer%);
                                                        if(%#buyer_uuid_index% == -1);
                                                            debug_error(%debug%,%&script_debug_name%,"cannot find buyer uuid '&4%&split_buyer%&c' in claimed_bidders array!");
                                                            filter_match = false;
                                                            break;
                                                        endif;
                                                    next;
                                                else;
                                                    debug_error(%debug%,%&script_debug_name%,"json_value and filter_val are out of sync (one is ARRAY, other is NULL)");
                                                    filter_match = false;
                                                endif;
                                            elseif(%&filter_key% == "END_TIME");
                                                &json_value  = jsonget("end",%&auction_json%);
                                                #end_ceiling = xEval("ceil(%&json_value% / 1000)",true);
                                                #filter_val := %&filter_val%;
                                                filter_match = %#end_ceiling% == %#filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %#filter_val%, have: &8%#end_ceiling%&7.");
                                            endif;
                                        
                                            if(!%filter_match%);
                                                debug_log(%debug%,%&script_debug_name%,"auction json at index %#loop_counter% is invalid due to a failed match for key &d%&filter_key%&7!");
                                                auction_found = false;
                                                break;
                                            endif;
                                        endif;
                                    next;
                                    
                                    if(%auction_found%);
                                        break;
                                    endif;
                                    inc(#loop_counter);
                                until((%auction_found%) || (%no_more_auctions%));
                            endif;
                        endif;
                    else;
                        debug_error(%debug%,%&script_debug_name%,"Did not find an ID or OWNER Term in the auction_identifiers[] Array!");
                    endif;
                endif;
                
                if(%auction_found%);
                    // Set Default Values
                    if(true);
                        api_hit       = true;
                        &api_id       = jsonget("uuid",%&auction_json%);
                        &api_type     = "AUCTION";
                        #api_price    = xJsonGet("highest_bid_amount",%&auction_json%);
                        #api_bids     = 0;
                        api_ended     = jsonget("claimed",%&auction_json%);
                        api_claimed   = jsonget("claimed",%&auction_json%);
                        &api_owner    = jsonget("auctioneer",%&auction_json%);
                        &api_profile  = jsonget("profile_id",%&auction_json%);
                        &api_buyer    = jsonget("claimed_bidders",%&auction_json%);
                        &api_end_time = jsonget("end",%&auction_json%);
                        #api_end_time = xEval("ceil(%&api_end_time% / 1000)",true);
                        
                        use_decode_api  = true;
                        if(%use_decode_api%);
                            &decoded_bytes[] = auctionsDecodeItemData(%&auction_json%);
                            &decoded_status  = %&decoded_bytes[0]%;
                            decode_success   = %&decoded_status% == "SUCCESS";
                        endif;
                        
                        if(%decode_success%);
                            &api_sbid   = %&decoded_bytes[1]%;
                            &api_mcid   = %&decoded_bytes[2]%;
                            &api_name   = %&decoded_bytes[3]%;
                            #api_data  := %&decoded_bytes[4]%;
                            #api_stack := %&decoded_bytes[5]%;
                        else;
                            &api_sbid   = "NULL";
                            &api_mcid   = "NULL";
                            &api_name   = jsonget("item_name",%&auction_json%);
                            #api_data   = -1;
                            #api_stack  = -1;
                        endif;
                    endif;
                    
                    // Correct Values from Defaults if Needed
                    if(true);
                        // Correct API Type from Default if Needed
                        if(true);
                            &listing_type = jsonget("bin",%&auction_json%);
                            ifnotmatches(%&listing_type%,"^ERROR_");
                                &api_type = "BIN";
                            endif;
                        endif;
                        
                        // Correct API Price from Default if Needed
                        if(true);
                            if(%#api_price% <= 0);
                                #api_price = xJsonGet("starting_bid",%&auction_json%);
                            endif;
                        endif;
                        
                        // Correct API Bids
                        if(true);
                            &bids_array   = jsonget("bids",%&auction_json%);
                            &bids_array[] = getjsonasarray(%&bids_array%);
                            #bids_array   = arraysize(&bids_array[]);
                            if(%#bids_array% > 1);
                                #bids_array = %#bids_array% - 1;
                            endif;
                            #api_bids = %#bids_array%;
                        endif;
                        
                        // Correct API Ended if Needed
                        if(!%api_ended%);
                            claimed_auction       = jsonget("claimed",%&auction_json%);
                            &first_claimed_bidder = jsonget("claimed_bidders.0",%&auction_json%);
                            &end_timestamp        = xJsonGet("end",%&auction_json%);
                            
                            if(%claimed_auction%);
                                debug_log(%debug%,%&script_debug_name%,"claimed_auction == true (%claimed_auction%) from auction_json. on clipboard");
                                api_ended = true;
                            elseifnotmatches(%&first_claimed_bidder%,"^ERROR_");
                                api_ended(%debug%,%&script_debug_name%,"first_claimed_bidder: &d%&first_claimed_bidder%&7.");
                                api_ended = true;
                            else;
                                #end_timestamp_rounded = xEval("ceil(%&end_timestamp% / 1000)",true);
                                api_ended = %TIMESTAMP% >= %#end_timestamp_rounded%;
                                if(%api_ended%);
                                    debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) >= end_timestamp_rounded (%#end_timestamp_rounded%)");
                                else;
                                    debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) < end_timestamp_rounded (%#end_timestamp_rounded%)");
                                endif;
                            endif;
                        endif;
                        
                        &api_name = strip(%&api_name%);
                        
                        // Correct API SBID, MCID, DATA, and Stack, if possible.
                        if(!%decode_success%);
                            &nullable_keys[]  = split(", ","SBID, MCID, DATA, STACK");
                            &nullable_vars[]  = split(", ","&api_sbid, &api_mcid, #api_data, #api_stack");
                            &nullable_cache[] = split(", ","&cache_sbid, &cache_mcid, #cache_data, #cache_stack");
                            foreach(&nullable_keys[],&nullable_key,#nki);
                                #nullable_index        = indexof(&filter_keys[],,%&nullable_key%);
                                nullable_found[%#nki%] = %#nullable_index% != -1;
                                if(%#nullable_index% != -1);
                                    set(%&nullable_vars[%#nki%]%,%&filter_vals[%#nullable_index%]%);
                                endif;
                            next;
                            
                            #false_index = indexof(nullable_found[],,false);
                            if(%#false_index% != -1);
                                &cache_data[]  = auctionsCheckCache("ID: %&api_id%");
                                cache_hit     := %&cache_data[0]%;
                                if(%cache_hit%);
                                    &cache_sbid    = %&cache_data[9]%;
                                    &cache_mcid    = %&cache_data[11]%;
                                    #cache_data   := %&cache_data[12]%;
                                    #cache_stack  := %&cache_data[13]%;
                                    foreach(nullable_found[],nullable,#ni);
                                        if(!%nullable%);
                                            &nullable_var   = %&nullable_vars[%#ni%]%;
                                            &nullable_cache = %&nullable_cache[%#ni%]%;
                                            &nullable_val   = %%&nullable_cache%%;
                                            set(%&nullable_var%,%&nullable_val%);
                                        endif;
                                    next;
                                endif;
                            endif;
                        endif;
                        
                        // Correct API Buyer, if possible.
                        if(true);
                            ifnotmatches(%&api_buyer%,"^ERROR_");
                                #buyer_index = 0;
                                do;
                                    &buyer_uuid = jsonget("claimed_bidders.%#buyer_index%",%&auction_json%);
                                    ifmatches(%&buyer_uuid%,"^ERROR_");
                                        break;
                                    endif;
                                    api_buyer_found = true;
                                    &buyer_uuids[]  = %&buyer_uuid%;
                                    inc(#buyer_index);
                                loop;
                            endif;
                            
                            if(%api_buyer_found%);
                                &api_buyer = join("~",&buyer_uuids[]);
                            else;
                                &api_buyer = "NULL";
                            endif;
                        endif;
                    endif;
                    
                    // Setup Return Array
                    if(true);
                        &return_terms[] = split(", ","HIT, ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK, BUYER, END_TIME");
                        #update_index   = indexof(@&cached_listing_id[],,%&api_id%);
                        if(%#update_index% == -1);
                            @&cached_listing_id[] = %&api_id%;
                            #update_index         = indexof(@&cached_listing_id[],,%&api_id%);
                        endif;
                        
                        foreach(&return_terms[],&return_term,#rti);
                            if(%&return_term% != "HIT");
                                #term_index     = indexof(&identifier_prefixes[],,%&return_term%);
                                &term_type      = %&identifier_types[%#term_index%]%;
                                #type_index     = indexof(&map_type_terms[],,%&term_type%);
                                &term_prefix    = %&map_type_prefixes[%#type_index%]%;
                                &term_cache     = lcase("@%&term_prefix%cached_listing_%&return_term%[%#update_index%]");
                                &term_pointer   = lcase("%&term_prefix%api_%&return_term%");
                                &term_value     = %%&term_pointer%%;
                                set(%&term_cache%,%&term_value%);
                            else;
                                &term_value = %api_hit%;
                            endif;
                            &return_array[] = %&term_value%;
                        next;
                    endif;
                else;
                    &return_array[] = false;
                endif;
            else;
                &return_array[] = false;
            endif;
            return(&return_array[]);
        endfunction;
    // auctions/indexAuctions/auctionsIndexSlotData
        // Indexes the Data from the Auction found at the specified Slot.
            // Params:
                // {number} [#listing_item_slot=13]    The Slot to Query for Auction Data (defaults to the Slot where it is found in AUCTION_VIEW GUIs)
                // {boolean} [force=false]             Whether or not to force an update of the Data that is returned from the API.
            // Throws Errors:
                // ERROR_API_LIMIT    Hit an API Limit.
                // ERROR_NOT_FOUND    Auction ID was not found, and/or was not in a valid Auction Listing GUI at time of Function Call.
            // Returns an Array:
                // 0  {boolean} listing_hit          Whether or not an Item from the api was found that matches the specified Auction Identifiers.
                // 1  {string}  &listing_id          The Listing ID
                // 2  {string}  &listing_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #listing_price       The Current Listing Price
                // 4  {number}  #listing_bids        The amount of Bids on the Listing
                // 5  {boolean} listing_ended        Whether or not the Listing has Ended
                // 6  {boolean} listing_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &listing_owner       The UUID of the Player that created this Listing
                // 8  {string}  &listing_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &listing_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &listing_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &listing_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #listing_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #listing_stack       The Stack Size of the Item that this Listing represents
                // 14 {number}  &listing_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #listing_end_time    The Timestamp of when this Auction will end.
            // Example:
                //    &listing_info[]    = auctionsIndexSlotData(%#listing_item_slot%);
                //    listing_hit       := %&listing_info[0]%;
                //    &listing_id        = %&listing_info[1]%;
                //    &listing_type      = %&listing_info[2]%;
                //    #listing_price    := %&listing_info[3]%;
                //    #listing_bids     := %&listing_info[4]%;
                //    listing_ended     := %&listing_info[5]%;
                //    listing_claimed   := %&listing_info[6]%;
                //    &listing_owner     = %&listing_info[7]%;
                //    &listing_profile   = %&listing_info[8]%;
                //    &listing_sbid      = %&listing_info[9]%;
                //    &listing_name      = %&listing_info[10]%;
                //    &listing_mcid      = %&listing_info[11]%;
                //    #listing_data     := %&listing_info[12]%;
                //    #listing_stack    := %&listing_info[13]%;
                //    &listing_buyers    = %&listing_info[14]%;
                //    #listing_end_time := %&listing_info[15]%;
        function auctionsIndexSlotData(#listing_item_slot=13,force=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/indexAuctions.txt:43
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&eauctionsIndexSlotData&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
            endif;
            
            &listing_username_expr = "(?:\[.*?\] )?(\w{3,16})";
            &coins_expr            = "([\d,]+) coins";
            
            do;
                listing_loading = false;
                &listing_item   = getslotitemnbt(%#listing_item_slot%,,#listing_stack,#listing_data,&listing_nbt);
                &listing_nbt    = strip(%&listing_nbt%);
                if(%&listing_item% != "air");
                    ifnotmatches(%&listing_nbt%,"Seller: Refreshing");
                        debug_log(%debug%,%&script_debug_name%,"Trying to get Listing Data from current GUI");
                        if(%CONTAINERNAME% == "Auction View");
                            &auction_identifiers[] = "TYPE: AUCTION";
                        elseif(%CONTAINERNAME% == "BIN Auction View");
                            &auction_identifiers[] = "TYPE: BIN";
                        else;
                            get_type = true;
                        endif;
                        
                        &listing_name = getItemName(%&listing_nbt%,%&listing_item%);
                        &listing_sbid = getItemSBID(%&listing_nbt%);
                        
                        ifmatches(%&listing_nbt%,"Seller: %&listing_username_expr%",&seller_username,1);
                            if(%&seller_username% == "Refreshing");
                                listing_loading = true;
                                setclipboard(%&listing_nbt%);
                                debug_breakpoint(%debug%,%&script_debug_name%,"Breakpoint (seller == 'refreshing') hit!");
                            endif;
                            &auction_identifiers[] = "OWNER: %&seller_username%";
                        endif;
                        
                        &auction_identifiers[] = "MCID: %&listing_item%";
                        &auction_identifiers[] = "STACK: %#listing_stack%";
                        &auction_identifiers[] = "DATA: %#listing_data%";
                        &auction_identifiers[] = "NAME: %&listing_name%";
                        &auction_identifiers[] = "SBID: %&listing_sbid%";
                        
                        ifmatches(%&listing_nbt%,"(?:Top bid|Sold for): %&coins_expr%",&auction_price,1);
                            #auction_price         := regexreplace(&auction_price,",","");
                            &auction_identifiers[]  = "PRICE: %#auction_price%";
                            if(%get_type%);
                                ifmatches(%&listing_nbt%,"Top bid");
                                    get_type               = false;
                                    &auction_identifiers[] = "TYPE: AUCTION";
                                endif;
                            endif;
                        endif;
                        
                        ifmatches(%&listing_nbt%,"Bids: ([\d,]+) bids",&auction_bids,1);
                            #auction_bids          := regexreplace(&auction_bids,",","");
                            &auction_identifiers[]  = "BIDS: %#auction_bids%";
                            if(%get_type%);
                                get_type               = false;
                                &auction_identifiers[] = "TYPE: AUCTION";
                            endif;
                        endif;
                        
                        ifmatches(%&listing_nbt%,"Status: (?:Sold|Ended)!");
                            &auction_identifiers[] = "ENDED: true";
                        else;
                            &auction_identifiers[] = "ENDED: false";
                        endif;
                        
                        if(!%force%);
                            &cache_data[]  = auctionsCheckCache(...&auction_identifiers[]);
                            cache_hit     := %&cache_data[0]%;
                            if(%cache_hit%);
                                return_hit        = true;
                                &return_id        = %&cache_data[1]%;
                                &return_type      = %&cache_data[2]%;
                                #return_price    := %&cache_data[3]%;
                                #return_bids     := %&cache_data[4]%;
                                return_ended     := %&cache_data[5]%;
                                return_claimed   := %&cache_data[6]%;
                                &return_owner     = %&cache_data[7]%;
                                &return_profile   = %&cache_data[8]%;
                                &return_sbid      = %&cache_data[9]%;
                                &return_name      = %&cache_data[10]%;
                                &return_mcid      = %&cache_data[11]%;
                                #return_data     := %&cache_data[12]%;
                                #return_stack    := %&cache_data[13]%;
                                &return_buyers    = %&cache_data[14]%;
                                #return_end_time := %&cache_data[15]%;
                            endif;
                        endif;
                        
                        if(!%cache_hit%);
                            &api_data[]  = auctionsGetListingInfoFromAPI(...&auction_identifiers[]);
                            api_hit     := %&api_data[0]%;
                            if(%api_hit%);
                                return_hit        = true;
                                &return_id        = %&api_data[1]%;
                                &return_type      = %&api_data[2]%;
                                #return_price    := %&api_data[3]%;
                                #return_bids     := %&api_data[4]%;
                                return_ended     := %&api_data[5]%;
                                return_claimed   := %&api_data[6]%;
                                &return_owner     = %&api_data[7]%;
                                &return_profile   = %&api_data[8]%;
                                &return_sbid      = %&api_data[9]%;
                                &return_name      = %&api_data[10]%;
                                &return_mcid      = %&api_data[11]%;
                                #return_data     := %&api_data[12]%;
                                #return_stack    := %&api_data[13]%;
                                &return_buyers    = %&api_data[14]%;
                                #return_end_time := %&api_data[15]%;
                            endif;
                        endif;
                        
                        break;
                    endif;
                else;
                    break;
                endif;
                wait("1t");
            loop;
            
            return(%return_hit%,%&return_id%,%&return_type%,%#return_price%,%#return_bids%,%return_ended%,%return_claimed%,%&return_owner%,%&return_profile%,%&return_sbid%,%&return_name%,%&return_mcid%,%#return_data%,%#return_stack%,%&return_buyers%,%#return_end_time%);
        endfunction;
    // auctions/getListingInfo/auctionsGetListingInfo
        // Given an Auction's ID (or if called while in a Listing GUI), fetches Data regarding that Listing.
            // Params:
                // {string} [&auction_id]     The Auction ID. If omitted, will fetch the Listing found in the Active GUI.
                // {boolean} [force=false]    Whether or not to force an API request. If false, will return values from the Cache
                //                            unless the Data is not yet Cached.
            // Throws Errors:
                // ERROR_API_LIMIT    Hit an API Limit.
                // ERROR_NOT_FOUND    Auction ID was not found, and/or was not in a valid Auction Listing GUI at time of Function Call.
            // Returns an Array:
                // 0  {boolean} listing_hit          Whether or not an Item from the api was found that matches the specified Auction Identifiers.
                // 1  {string}  &listing_id          The Listing ID
                // 2  {string}  &listing_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #listing_price       The Current Listing Price
                // 4  {number}  #listing_bids        The amount of Bids on the Listing
                // 5  {boolean} listing_ended        Whether or not the Listing has Ended
                // 6  {boolean} listing_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &listing_owner       The UUID of the Player that created this Listing
                // 8  {string}  &listing_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &listing_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &listing_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &listing_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #listing_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #listing_stack       The Stack Size of the Item that this Listing represents
                // 14 {number}  &listing_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #listing_end_time    The Timestamp of when this Auction will end.
            // Example:
                //    &listing_info[]    = auctionsGetListingInfo(%&auction_id%,%force%);
                //    listing_hit       := %&listing_info[0]%;
                //    &listing_id        = %&listing_info[1]%;
                //    &listing_type      = %&listing_info[2]%;
                //    #listing_price    := %&listing_info[3]%;
                //    #listing_bids     := %&listing_info[4]%;
                //    listing_ended     := %&listing_info[5]%;
                //    listing_claimed   := %&listing_info[6]%;
                //    &listing_owner     = %&listing_info[7]%;
                //    &listing_profile   = %&listing_info[8]%;
                //    &listing_sbid      = %&listing_info[9]%;
                //    &listing_name      = %&listing_info[10]%;
                //    &listing_mcid      = %&listing_info[11]%;
                //    #listing_data     := %&listing_info[12]%;
                //    #listing_stack    := %&listing_info[13]%;
                //    &listing_buyers    = %&listing_info[14]%;
                //    #listing_end_time := %&listing_info[15]%;
        function auctionsGetListingInfo(&auction_id,force=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:964
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9auctionsGetListingInfo&7";
                debug_log(%debug%,%&script_debug_name%,"Getting Listing Info, &&auction_id: '&d%&auction_id%&7'.");
            endif;
            
            // If we were provided with the Auction's ID, attempt to hit Cache with it.
            if(%&auction_id% != "");
                if(!%force%);
                    debug_log(%debug%,%&script_debug_name%,"Checking Cache for &&auction_id");
                    &cache_data[]  = auctionsCheckCache("ID: %&auction_id%");
                    cache_hit     := %&cache_data[0]%;
                    if(%cache_hit%);
                        return_hit        = true;
                        &return_id        = %&cache_data[1]%;
                        &return_type      = %&cache_data[2]%;
                        #return_price    := %&cache_data[3]%;
                        #return_bids     := %&cache_data[4]%;
                        return_ended     := %&cache_data[5]%;
                        return_claimed   := %&cache_data[6]%;
                        &return_owner     = %&cache_data[7]%;
                        &return_profile   = %&cache_data[8]%;
                        &return_sbid      = %&cache_data[9]%;
                        &return_name      = %&cache_data[10]%;
                        &return_mcid      = %&cache_data[11]%;
                        #return_data     := %&cache_data[12]%;
                        #return_stack    := %&cache_data[13]%;
                        &return_buyers    = %&cache_data[14]%;
                        #return_end_time := %&cache_data[15]%;
                    endif;
                else;
                    debug_log(%debug%,%&script_debug_name%,"Skipping cache for &&auction_id (force is true)");
                endif;
                
                if(!%cache_hit%);
                    debug_log(%debug%,%&script_debug_name%,"Did not hit Cache for &&auction_id, hitting API.");
                    &api_data[]       = auctionsGetListingInfoFromAPI("ID: %&auction_id%");
                    api_hit          := %&api_data[0]%;
                    &return_id        = %&api_data[1]%;
                    &return_type      = %&api_data[2]%;
                    #return_price    := %&api_data[3]%;
                    #return_bids     := %&api_data[4]%;
                    return_ended     := %&api_data[5]%;
                    return_claimed   := %&api_data[6]%;
                    &return_owner     = %&api_data[7]%;
                    &return_profile   = %&api_data[8]%;
                    &return_sbid      = %&api_data[9]%;
                    &return_name      = %&api_data[10]%;
                    &return_mcid      = %&api_data[11]%;
                    #return_data     := %&api_data[12]%;
                    #return_stack    := %&api_data[13]%;
                    &return_buyers    = %&api_data[14]%;
                    #return_end_time := %&api_data[15]%;
                    
                    if(%api_hit%);
                        debug_log(%debug%,%&script_debug_name%,"Got a valid hit from API for &&auction_id!");
                        return_hit = true;
                    else;
                        debug_error(%debug%,%&script_debug_name%,"Got no hit for &&auction_id from API, reading out &&api_data[] Array...");
                        &vars[] = split(" ","api_hit &return_id &return_type #return_price #return_bids return_ended return_claimed &return_owner &return_profile &return_sbid &return_name &return_mcid #return_data #return_stack &return_buyers");
                        foreach(&vars[],&var,#v);
                            &val    = "%%&var%%";
                            &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                            &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                            debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
                        next;
                        // debug_breakpoint(%debug%,%&script_debug_name%,"Waiting for review...");
                        debug_error(%debug%,%&script_debug_name%,"Waiting for review...");
                    endif;
                endif;
            endif;
            
            // If we haven't hit anything yet, try to get the Listing Data of whatever GUI we are currently in.
            if(!%return_hit%);
                debug_log(%debug%,%&script_debug_name%,"Haven't hit Cache or API yet, will try to get Data from GUI if we are in a GUI...");
                &listing_username_expr = "(?:\[.*?\] )?(\w{3,16})";
                &coins_expr            = "([\d,]+) coins";
                #listing_item_slot     = 13;
                do;
                    if((%GUI% == "GUICHEST") && ((%CONTAINERNAME% == "Auction View") || (%CONTAINERNAME% == "BIN Auction View")));
                        &listing_item = getslotitemnbt(%#listing_item_slot%,,#listing_stack,#listing_data,&listing_nbt);
                        &listing_nbt  = strip(%&listing_nbt%);
                        if(%&listing_item% != "air");
                            ifnotmatches(%&listing_nbt%,"Seller: Refreshing");
                                &cache_data[]  = auctionsIndexSlotData(%#listing_item_slot%,%force%);
                                debug_log(%debug%,%&script_debug_name%,"got return from auctionsCheckCache");
                                cache_hit     := %&cache_data[0]%;
                                if(%cache_hit%);
                                    return_hit        = true;
                                    &return_id        = %&cache_data[1]%;
                                    &return_type      = %&cache_data[2]%;
                                    #return_price    := %&cache_data[3]%;
                                    #return_bids     := %&cache_data[4]%;
                                    return_ended     := %&cache_data[5]%;
                                    return_claimed   := %&cache_data[6]%;
                                    &return_owner     = %&cache_data[7]%;
                                    &return_profile   = %&cache_data[8]%;
                                    &return_sbid      = %&cache_data[9]%;
                                    &return_name      = %&cache_data[10]%;
                                    &return_mcid      = %&cache_data[11]%;
                                    #return_data     := %&cache_data[12]%;
                                    #return_stack    := %&cache_data[13]%;
                                    &return_buyers    = %&cache_data[14]%;
                                    #return_end_time := %&cache_data[15]%;
                                endif;
                                break;
                            endif;
                        endif;
                    else;
                        break;
                    endif;
                    
                    wait("1t");
                while((%GUI% == "GUICHEST") && ((%CONTAINERNAME% == "Auction View") || (%CONTAINERNAME% == "BIN Auction View")));
            endif;
            
            &return_vars[] = split(", ","return_hit, &return_id, &return_type, #return_price, #return_bids, return_ended, return_claimed, &return_owner, &return_profile, &return_sbid, &return_name, &return_mcid, #return_data, #return_stack, &return_buyers, #return_end_time");
            debug_log(%debug%,%&script_debug_name%,"returning the following array:");
            foreach(&return_vars[],&var,#v);
                &val    = "%%&var%%";
                &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
            next;
            if(%debug%); log(" "); endif;
            
            foreach(&return_vars[],&return_var,#rvi);
                &return_array[%#rvi%] = %%&return_var%%;
            next;
            return(&return_array[]);
        endfunction;
    // auctions/actions/auctionsOpenListing
        // Opens up an Auction Listing GUI given the Auction Listing ID.
            // Params:
                // {string} <&auction_id>        The ID of the Auction Listing to open.
                // {string} [&listing_info[]]    The Array returned by auctionsGetListingInfo, if already called externally. If omitted, will call auctionsGetListingInfo
                //                               with the specified Auction ID.
                // {number} [#tick_wait=20]      Ticks to wait between Interactions.
                // {number} [#timeout_sec=30]    Maximum amount of Seconds the Function can run for before Timing Out. Set to <= 0 to disable timeouts.
            // Returns a String ENUM:
                // SUCCESS              Successfully entered the Auction Listing GUI.
                // ERROR_TIMEOUT        The Function exited early due to a timeout.
                // ERROR_UNAVAILABLE    The Function exited due to the Auction House being closed for some reason (i.e. Derpy is Mayor).
                // ERROR_NOT_FOUND      The Function exited due to not being able to find the Auction (can occur if the Auction ID
                //                      is invalid, or the Function was called with the Auction ID Parameter omitted without a Listing GUI open).
                // ERROR_EXPIRED        The function exited due to the Auction being expired by the time we went to go place the Bid for it.
                // ERROR_UNKNOWN        The function exited due to an unknown Error.
                // ERROR_SERVER         The function exited due to not being able to get onto SkyBlock.
            // Example
            //    &listing_opened = auctionsOpenListing(%&auction_id%,&listing_info[],%#tick_wait%,%#timeout_sec%);
            //    if(%&listing_opened% != "SUCCESS");
            //        if(%&listing_opened% == "ERROR_TIMEOUT");
            //        elseif(%&listing_opened% == "ERROR_UNAVAILABLE");
            //        elseif(%&listing_opened% == "ERROR_NOT_FOUND");
            //        elseif(%&listing_opened% == "ERROR_EXPIRED");
            //        elseif(%&listing_opened% == "ERROR_UNKNOWN");
            //        elseif(%&listing_opened% == "ERROR_SERVER");
            //        endif;
            //    endif;
        function auctionsOpenListing(&auction_id,&listing_info[],#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/actions.txt:28
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6auctionsOpenListing&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &enum_success      = "SUCCESS";
                &enum_timeout      = "ERROR_TIMEOUT";
                &enum_unavailable  = "ERROR_UNAVAILABLE";
                &enum_not_found    = "ERROR_NOT_FOUND";
                &enum_expired      = "ERROR_EXPIRED";
                &enum_unknown      = "ERROR_UNKNOWN";
                &enum_server       = "ERROR_SERVER";
                
                // Check if the Auction House is closed
                if(%TIMESTAMP% < %@#ah_closed_timestamp%);
                    debug_error(%debug%,%&script_debug_name%,"Auction House is currently closed, cannot place bids!");
                    &return_string = %&enum_unavailable%;
                    break;
                endif;
                
                // Get Auction Listing Info
                if(true);
                    #listing_info_sz = arraysize(&listing_info[]);
                    if(%#listing_info_sz% == 0);
                        &listing_info[] = auctionsGetListingInfo(%&auction_id%);
                    endif;
                    listing_hit      := %&listing_info[0]%;
                    &listing_id       = %&listing_info[1]%;
                    &listing_type     = %&listing_info[2]%;
                    #listing_price   := %&listing_info[3]%;
                    #listing_bids    := %&listing_info[4]%;
                    listing_ended    := %&listing_info[5]%;
                    listing_claimed  := %&listing_info[6]%;
                    &listing_owner    = %&listing_info[7]%;
                    &listing_profile  = %&listing_info[8]%;
                    &listing_sbid     = %&listing_info[9]%;
                    &listing_name     = %&listing_info[10]%;
                    &listing_mcid     = %&listing_info[11]%;
                    #listing_data    := %&listing_info[12]%;
                    #listing_stack   := %&listing_info[13]%;
                    &listing_buyers   = %&listing_info[14]%;
                    
                    if(!%listing_hit%);
                        debug_error(%debug%,%&script_debug_name%,"Failed to get Listing Info for ID: &d%&auction_id%&7.");
                        return(%&enum_not_found%);
                    endif;
                    
                    &listing_gui = "Auction View";
                    if(%&listing_type% == "BIN");
                        &listing_gui = "BIN Auction View";
                    endif;
                endif;
            endif;
            
            // Loop Actions until we are in the Auctions GUI.
            if(true);
                &init_unset_pointers[] = split(", ","@cannot_use_ah, @auction_house_error, @ah_failure, @&ah_failure_string");
                &fail_pointers[]       = split(", ","@ah_failure, @cannot_use_ah, @auction_house_error");
                foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                    unset(%&init_unset_pointer%);
                next;
                
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Check if we are in the correct GUI.
                    if(true);
                        if((%GUI% == "GUICHEST") && (%CONTAINERNAME% == %&listing_gui%));
                            // 2a. Get the Listing GUI Data and compare to Initial Listing Variables.
                            if(true);
                                &current_info[]  = auctionsGetListingInfo();
                                current_hit     := %&current_info[0]%;
                                &current_id      = %&current_info[1]%;
                                if((%current_hit%) && (%&current_id% == %&auction_id%));
                                    debug_log(%debug%,%&script_debug_name%,"Got into correct Listing GUI.");
                                    &return_string = %&enum_success%;
                                    break;
                                endif;
                            endif;
                        endif;
                        
                        // 2b. If we haven't already broken above, we are in an invalid GUI. Exit any GUIs we might be in and try to get into the correct one.
                        can_do_action = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                        if(%can_do_action%);
                            if(%GUI% != "NONE");
                                localGUI("NONE");
                            endif;
                            
                            // 2c.    Get onto SkyBlock. If we have a Booster Cookie active, then we can use the /viewauction command regardless of where we are on SB.
                            //        If we do not have the Booster Cookie active, we need to make sure that we are on a SKYBLOCK_HUB server in order to use the /viewauction command.
                            if(true);
                                #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                on_skyblock        = gotoServer("SKYBLOCK",%#tick_wait%,%#recursive_timeout%);
                                if(!%on_skyblock%);
                                    debug_error(%debug%,%&script_debug_name%,"Not on a SkyBlock Server!");
                                    &return_string = %&enum_server%;
                                    break;
                                endif;
                                
                                cookie_active = isEffectEnabled("COOKIE",%#timeout_sec%);
                                if(!%cookie_active%);
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    on_skyblock        = gotoServer("SKYBLOCK_HUB",%#tick_wait%,%#recursive_timeout%);
                                    if(!%on_skyblock%);
                                        debug_error(%debug%,%&script_debug_name%,"Failed to get onto a SkyBlock Hub Server.");
                                        &return_string = %&enum_server%;
                                        break;
                                    endif;
                                endif;
                            endif;
                            
                            // 2d.    If we made it to this point, we are on a SkyBlock Server and we can use the /viewauction <auction_id> command. Do so.
                            echo("/viewauction %&auction_id%");
                        endif;
                    endif;
                    
                    // 3. Check if Chat Filter has returned a Failure
                    if(true);
                        for(action_loop,0,1);
                            if(!%action_loop%);
                                // 3b. Check if the Auction House is now closed
                                if(%TIMESTAMP% < %@#ah_closed_timestamp%);
                                    debug_error(%debug%,%&script_debug_name%,"Auction House is currently closed, cannot place bids!");
                                    &return_string = %&enum_unavailable%;
                                    break;
                                endif;
                                
                                unset(&failed_pointers[]);
                                unset(&string_pointers[]);
                                failed_pointer  = false;
                                &failure_string = %@&ah_failure_string%;
                                
                                foreach(&fail_pointers[],&fail_pointer,#fp);
                                    fail_value    := "%%&fail_pointer%%";
                                    &safe_pointer  = regexreplace(&fail_pointer,"(?<!&)&\w","&$1");
                                    &push_string   = "&7%&safe_pointer%&7: '&8false&7'";
                                    if(%fail_value%);
                                        failed_pointer     = true;
                                        &failed_pointers[] = %&fail_if_set_pointer%;
                                        &push_string       = "&7%&safe_pointer%&7: '&4true&7'";
                                    endif;
                                    
                                    &string_pointers[] = %&push_string%;
                                next;
                            elseif(%failed_pointer%);
                                &error_type                = "UNKNOWN";    // UNKNOWN, INVALID_AUCTION, INVALID_BID
                                &error_action              = "RETRY";      // CANCEL, RETRY
                                &string_pointers           = join(", ",&string_pointers[]);
                                #cannot_use_ah_index       = indexof(&failed_pointers[],,"@cannot_use_ah");
                                #auction_house_error_index = indexof(&failed_pointers[],,"@auction_house_error");
                                #ah_failure_index          = indexof(&failed_pointers[],,"@ah_failure");
                                debug_error(%debug%,%&script_debug_name%,"a failure pointer is set! Pointer values: %&string_pointers%");
                                
                                if(%#ah_failure_index% != -1);
                                    // ifmatches(%&failure_string%,"There was an error with the auction house!.*(?:Error: |\()(?<auctionErrorCode>\w+)(?:\.|\))$",&failure_code,1);
                                    ifmatches(%&failure_string%,"(?:Failed to claim bid!|There was an error with the auction house!).*?(?:Error: |\()(\w+)(?:\.|\))",&failure_code,1);
                                        if((%&failure_code% == "NOT_FOUND_OR_ALREADY_CLAIMED") || (%&failure_code% == "AUCTION_EXPIRED_OR_NOT_FOUND"));
                                            // Auction is no longer valid
                                            &error_type   = "INVALID_AUCTION";
                                            &error_action = "CANCEL";
                                            debug_log(%debug%,%&script_debug_name%,"failure_code is '&4%&failure_code%&7', Auction is invalid. Will cancel.");
                                        else;
                                            debug_error(%debug%,%&script_debug_name%,"Unknown Error Code: '&4%&failure_code%&c'! Will do recursive call to self.");
                                            logto("ah_unknown_error_codes.txt","[%DATETIME%]: Error Code '%&failure_code%', Error String %&failure_string%");
                                            &error_type   = "UNKNOWN";
                                            &error_action = "RETRY";
                                        endif;
                                    elseifmatches(%&failure_string%,"There was an error with the auction house!");
                                        // Generic Error, cannot know what went wrong.
                                        &error_action = "RETRY";
                                        &error_type   = "UNKNOWN";
                                        debug_error(%debug%,%&script_debug_name%,"Generic Error: '&4%&failure_string%&c'! Will do recursive call to self.");
                                    elseifmatches(%&failure_string%,"You didn't participate in this auction!");
                                        // Auction is no longer valid.
                                        &error_type   = "INVALID_AUCTION";
                                        &error_action = "CANCEL";
                                        debug_log(%debug%,%&script_debug_name%,"Failure string is '&4%&failure_string%&7', Auction is Invalid. Will cancel.");
                                    elseifmatches(%&failure_string%,"(?:Invalid auction ID!|This auction wasn't found!|This player doesn't have any active auctions!)");
                                        // Auction is invalid
                                        &error_type   = "INVALID_AUCTION";
                                        &error_action = "CANCEL";
                                    endif;
                                elseif(%#cannot_use_ah_index% != -1);
                                    debug_error(%debug%,%&script_debug_name%,"Error type is '&4@cannot_use_ah&c', will try to change Servers and if successful, will do recursive call to self.");
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    &swap_result       = swapServers(%#tick_wait%,%#recursive_timeout%);
                                    
                                    if(%&swap_result% != "SUCCESS");
                                        debug_error(%debug%,%&script_debug_name%,"swapServers returned error '&4%&swap_result%&c', will return this error code.");
                                        &return_string = %&swap_result%;
                                        &error_action  = "CANCEL";
                                    else;
                                        &error_action  = "RETRY";
                                        debug_log(%debug%,%&script_debug_name%,"swapServers completed successfully. Will do recursive call to self.");
                                    endif;
                                elseif(%#auction_house_error_index% != -1);
                                    // Might just have to try again
                                    debug_error(%debug%,%&script_debug_name%,"An auction house error occurred. Will do recursive call to self.");
                                endif;
                                
                                debug_error(%debug%,%&script_debug_name%,"Error Action: '&e%&error_action%&c'. Error Type: '&4%&error_type%&c'. Error String: '&4%&failure_string%&c'.");
                                if((%&return_string% == "") && (%&error_action% == "CANCEL"));
                                    &error_enum_map_terms[]    = split(", ","UNKNOWN, INVALID_AUCTION");
                                    &error_enum_map_enums[]    = split(", ","%&enum_unknown%, %&enum_expired%");
                                    #error_enum_map_term_index = indexof(&error_enum_map_terms[],,%&error_type%);
                                    &return_string             = %&error_enum_map_terms[%#error_enum_map_term_index%]%;
                                    debug_log(%debug%,%&script_debug_name%,"will return error_enum '&4%&return_string%&7' due to encountering error_type '&4%&error_type%&7' with CANCEL action");
                                elseif(%&error_action% == "RETRY");
                                    debug_log(%debug%,%&script_debug_name%,"running self-recursion call, error_action is RETRY, type is '&4%&error_type%&7'.");
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    &return_string     = call("auctionsOpenListing",%&auction_id%,&listing_info[],%#tick_wait%,%#recursive_timeout%);
                                    debug_log(%debug%,%&script_debug_name%,"got return_string '&e%&return_string%&7' from recursion call, breaking");
                                endif;
                            endif;
                        next;
                        
                        if(%&return_string% != "");
                            break;
                        endif;
                    endif;
                    
                    wait("1t");
                    inc(#waited_ticks);
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"returning '&e%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // auctions/collect/auctionsCollectListing
        // Given any number of an Auction's Identifiers, finds an Auction that matches the specified Identifiers and collects it.
            // Params:
                // {number} [#tick_wait=20]                Amount of Ticks to wait between repeated Actions. Passed along to called Functions.
                // {number} [#timeout_sec=30]              Amount of Seconds Function can run for before timing out and returning an Error.
                // {string} <...&auction_identifiers[]>    An Array of Auction Identifiers in format: '<ID_TYPE>: <ID_DATA>'. If multiple instances of a given
                //                                         ID_TYPE are encountered, the one that appears latest in the Array is used. Valid ID_TYPE Prefixes are
                //                                         at the end of this Comment.
            // Valid ID_TYPE Prefixes:
                // {string} ID          The Listing ID
                // {string} TYPE        The Listing Type (one of: BIN, AUCTION)
                // {number} PRICE       The Current Listing Price
                // {number} BIDS        The amount of Bids on the Listing
                // {boolean} ENDED      Whether or not the Listing has Ended
                // {boolean} CLAIMED    Whether or not the Listing has been claimed
                // {string} OWNER       The UUID of the Player that created this Listing
                // {string} PROFILE     The Profile ID the Owner of this Listing was using to create this Listing
                // {string} SBID        The SkyBlock ID of the Item that this Listing represents
                // {string} NAME        The Display Name of the Item that this Listing represents
                // {string} MCID        The Minecraft Item ID that this Listing represents
                // {number} DATA        The Data Value of the Item that this Listing represents
                // {number} STACK       The Stack Size of the Item that this Listing represents
                // {string} BUYER       A UUID(s) of a Player who purchased/claimed this Listing. If giving multiple, join them with ~.
            // Returns a String ENUM:
                // SUCCESS                The Function executed as expected and was successful.
                // ERROR_TIMEOUT          Exited early due to a timeout.
                // ERROR_UNAVAILABLE      Auction House was closed for some reason (i.e. Derpy is Mayor).
                // ERROR_NOT_FOUND        Exited due to not being able to find a Listing that matched the specified Identifiers
                // ERROR_NOT_FOUND_GUI    Exited due to having found the Listing in Cache / API, but not being able to find the Auction in the GUI
                // ERROR_UNKNOWN          Exited due to an unknown Error.
                // ERROR_SERVER           Exited due to not being able to get onto SkyBlock.
                // ERROR_INVENTORY        Not enough space in the Inventory to successfully collect the Auction.
            // Example:
                //    &collected_listing = auctionsCollectListing(%#tick_wait%,%#timeout_sec%,...&auction_identifiers[]);
                //    if(%&collected_listing% != "SUCCESS");
                //        if(%&collected_listing% == "ERROR_TIMEOUT");
                //        elseif(%&collected_listing% == "ERROR_UNAVAILABLE");
                //        elseif(%&collected_listing% == "ERROR_NOT_FOUND");
                //        elseif(%&collected_listing% == "ERROR_NOT_FOUND_GUI");
                //        elseif(%&collected_listing% == "ERROR_UNKNOWN");
                //        elseif(%&collected_listing% == "ERROR_SERVER");
                //        elseif(%&collected_listing% == "ERROR_INVENTORY");
                //        endif;
                //    endif;
        function auctionsCollectListing(#tick_wait=20,#timeout_sec=30,...&auction_identifiers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/collect.txt:44
            // Setup Function Variables
            if(true);
                debug               = true;
                &script_debug_name  = "&9auctionsCollectListing&7";
                do_timeout          = %#timeout_sec% > 0;
                #start_time         = %TIMESTAMP%;
                &enum_success       = "SUCCESS";
                &enum_timeout       = "ERROR_TIMEOUT";
                &enum_not_found     = "ERROR_NOT_FOUND";
                &enum_not_found_gui = "ERROR_NOT_FOUND_GUI";
                &enum_unknown       = "ERROR_UNKNOWN";
                &enum_server        = "ERROR_SERVER";
                &enum_inventory     = "ERROR_INVENTORY";
                
                if(%#tick_wait% < 100);
                    #collect_wait = 100;
                else;
                    #collect_wait = %#tick_wait%;
                endif;
            endif;
            
            // Find the specified Auction
            if(true);
                // 1. Check if the Auction is Cached
                if(true);
                    &cache_data[]   = auctionsCheckCache(...&auction_identifiers[]);
                    cache_hit      := %&cache_data[0]%;
                    &cache_id       = %&cache_data[1]%;
                    &cache_type     = %&cache_data[2]%;
                    #cache_price   := %&cache_data[3]%;
                    #cache_bids    := %&cache_data[4]%;
                    cache_ended    := %&cache_data[5]%;
                    cache_claimed  := %&cache_data[6]%;
                    &cache_owner    = %&cache_data[7]%;
                    &cache_profile  = %&cache_data[8]%;
                    &cache_sbid     = %&cache_data[9]%;
                    &cache_name     = %&cache_data[10]%;
                    &cache_mcid     = %&cache_data[11]%;
                    #cache_data    := %&cache_data[12]%;
                    #cache_stack   := %&cache_data[13]%;
                    &cache_buyers   = %&cache_data[14]%;
                endif;
                
                if(!%cache_hit%);
                    &identifers = join("&c,&4 ");
                    debug_error(%debug%,%&script_debug_name%,"Could not find Auction with Identifiers: &4%&identifers%&c. Returning '&4%&enum_not_found%&c'.");
                    return(%&enum_not_found%);
                endif;
            endif;
            
            // Loop actions until we have completed the Action, or an un-correctable Error is encountered.
            if(true);
                // Setup Auction State Terms
                if(true);
                    //    PURCHASED_ITEM
                        &auction_state_terms[] = "PURCHASED_ITEM";
                        &auction_state_mcids[] = "gold_block";
                        &auction_state_names[] = "Collect Auction";
                        &auction_state_regex[] = "Click to pick up item!";
                    //    PURCHASED_COINS
                        &auction_state_terms[] = "PURCHASED_COINS";
                        &auction_state_mcids[] = "gold_block";
                        &auction_state_names[] = "Collect Auction";
                        &auction_state_regex[] = "Click to collect coins!";
                    //    EXPIRED_COINS
                        &auction_state_terms[] = "EXPIRED_COINS";
                        &auction_state_mcids[] = "gold_nugget";
                        &auction_state_names[] = "Collect Auction";
                        &auction_state_regex[] = "Click to collect bid coins!";
                    //    EXPIRED_ITEM
                        &auction_state_terms[] = "EXPIRED_ITEM";
                        &auction_state_mcids[] = "stained_hardened_clay";
                        &auction_state_names[] = "Cancel Auction";
                        &auction_state_regex[] = "Click to cancel auction!";
                endif;
                #waited_ticks = 0;
                
                &init_unset_pointers[] = split(", ","@ah_failure, @ah_confirm, @&ah_failure_string, @&ah_confirm_string");
                &fail_ifset_pointers[] = split(", ","@ah_failure");
                &okay_ifset_pointers[] = split(", ","@ah_confirm");
                &check_bool_pointers[] = split(", ","@ah_confirm, @ah_failure");
                
                foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                    unset(%&init_unset_pointer%);
                next;
                
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. If we have already clicked on the item, check to see whether or not we have any Pointers set.
                    if(%check_pointers%);
                        foreach(&check_bool_pointers[],&check_bool_pointer,#cbp);
                            check_bool_state := "%%&check_bool_pointer%%";
                            if(%check_bool_state%);
                                if(%&check_bool_pointer% == "@ah_failure");
                                    // debug_breakpoint(%debug%,%&script_debug_name%,"Error Pointer @ah_failure is set!");
                                    debug_error(%debug%,%&script_debug_name%,"Error Pointer @ah_failure is set!");
                                    &return_string = %&enum_unknown%;
                                    break;
                                elseif(%&check_bool_pointer% == "@ah_confirm");
                                    // debug_breakpoint(%debug%,%&script_debug_name%,"Success Pointer @ah_confirm is set!");
                                    debug_log(%debug%,%&script_debug_name%,"Success Pointer @ah_confirm is set!");
                                    &return_string = %&enum_success%;
                                    break;
                                endif;
                            endif;
                        next;
                        
                        if(%&return_string% != "");
                            // debug_breakpoint(%debug%,%&script_debug_name%,"About to exit with return_string: '&d%&return_string%&7'...");
                            debug_log(%debug%,%&script_debug_name%,"About to exit with return_string: '&d%&return_string%&7'...");
                            break;
                        elseif((%TIMESTAMP% - %#check_pointer_timestamp%) >= 3);
                            debug_breakpoint(%debug%,%&script_debug_name%,"About to disable pointer check...");
                            check_pointers = false;
                        endif;
                        wait("1t");
                    else;
                        // 2. Open the Auction GUI, if we are not already in it.
                        if(true);
                            // 2a. Save the state of all our Pointers before we run the Function.
                            foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                                &saved_states[%#iup%] = %%&init_unset_pointer%%;
                            next;
                            
                            #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            &listing_opened    = auctionsOpenListing(%&cache_id%,&cache_data[],%#tick_wait%,%#recursive_timeout%);
                            if(%&listing_opened% != "SUCCESS");
                                debug_error(%debug%,%&script_debug_name%,"Received an Error Code from auctionsOpenListing: '&4%&listing_opened%&c'. Will return this Error Code.");
                                &return_string = %&listing_opened%;
                                break;
                            endif;
                            
                            // 2b. Revert the state of all our Pointers to their former State.
                            foreach(&saved_states[],&saved_state,#ss);
                                set(%&init_unset_pointers[%#ss%]%,%&saved_state%);
                            next;
                        endif;
                        
                        // 3. Check if we can collect the Auction Listing.
                        if(true);
                            // 3a. Find the Auction Listing Type (PURCHASED_ITEM, PURCHASED_COINS, EXPIRED_COINS, EXPIRED_ITEM).
                            if(true);
                                &found_state_term = "";
                                foreach(&auction_state_terms[],&auction_state_term,#ast);
                                    &auction_state_mcid  = %&auction_state_mcids[%#ast%]%;
                                    &auction_state_name  = %&auction_state_names[%#ast%]%;
                                    &auction_state_regex = %&auction_state_regex[%#ast%]%;
                                    #auction_state_slot  = findItemContainer(false,"MCID: %&auction_state_mcid%","NAME: %&auction_state_name%","NBT: r$%&auction_state_regex%");
                                    if(%#auction_state_slot% != -1);
                                        &found_state_term = %&auction_state_term%;
                                        break;
                                    endif;
                                next;
                                
                                // Break and return early after logging the contents of the Inventory, Mouse, and Container to file if we were not able to determine the Auction State.
                                if(%&found_state_term% == "");
                                    &log_path = containerLog("~/liteconfig/common/macros/logs/auctionFailures/%TIMESTAMP%-auctionNBT.txt",false,"Caller: %&script_debug_name%");
                                    debug_error(%debug%,%&script_debug_name%,"Could not determine the Auction State Type! This may be because the auction is not owned by us, it has expired, and we did not bid on it, or the server is shutting down soon, or something else that is yet to be accounted for. Full GUI Data has been logged to '&d%&log_path%&c'.");
                                    &return_string = %&enum_unknown%;
                                    break;
                                endif;
                            endif;
                            
                            // 3b. If we found the Auction Listing Type, determine whether or not we will be able to collect it.
                            if(true);
                                auction_collectable = ((%&found_state_term% == "PURCHASED_ITEM") || (%&found_state_term% == "PURCHASED_COINS"));
                                if(!%auction_collectable%);
                                    #auction_placeholder_slot     = 13;
                                    &auction_placeholder_item     = getslotitemnbt(%#auction_placeholder_slot%,,#auction_placeholder_stack,#auction_placeholder_data,&auction_placeholder_nbt);
                                    &auction_placeholder_nbt      = strip(%&auction_placeholder_nbt%);
                                    &auction_placeholder_name     = getItemName(%&auction_placeholder_nbt%,%&auction_placeholder_item%);
                                    &auction_placeholder_sbid     = getItemSBID(%&auction_placeholder_nbt%);
                                    #sum_available_inventory_room = getStackRoomInventory(%&auction_placeholder_sbid%);
                                    auction_collectable           = %#sum_available_inventory_room% >= %#auction_placeholder_stack%;
                                    if(!%auction_collectable%);
                                        debug_error(%debug%,%&script_debug_name%,"Auction Listing is not collectable. Minimum required room in Inventory is &4%#auction_placeholder_stack%&c, but we only have &4%#sum_available_inventory_room%&c room available. Will return '&4%&enum_inventory%&c'.");
                                        &return_string = %&enum_inventory%;
                                        break;
                                    endif;
                                endif;
                            endif;
                            
                            // 3c. If the Auction is Collectable, attempt to Collect the Auction.
                            if(%auction_collectable%);
                                #waited_ticks   = 0;
                                entered_new_gui = false;
                                &init_gui       = getContainerString(false);
                                item_clicked    = false;
                                do;
                                    // 1. Check for Function Timeout
                                    if(%do_timeout%);
                                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        if(%func_timeout%);
                                            debug_error(%debug%,%&script_debug_name%,"Function timed out");
                                            &return_string = %&enum_timeout%;
                                            break;
                                        endif;
                                    endif;
                                    
                                    // 2. Check if we are still in the same GUI
                                    if(true);
                                        entered_new_gui = enteredNewGUI(%&init_gui%,false);
                                        if(%entered_new_gui%);
                                            if(%item_clicked%);
                                                // debug_breakpoint(%debug%,%&script_debug_name%,"Entered new GUI, clicked new Item, about to enter Pointer Check mode.");
                                                debug_log(%debug%,%&script_debug_name%,"Entered new GUI, clicked new Item, about to enter Pointer Check mode.");
                                                #check_pointer_timestamp = %TIMESTAMP%;
                                                check_pointers           = true;
                                            else;
                                                // debug_breakpoint(%debug%,%&script_debug_name%,"Entered new GUI, but have not yet clicked new Item. &cWill not be entering Pointer Check mode.");
                                                debug_error(%debug%,%&script_debug_name%,"Entered new GUI, but have not yet clicked new Item. &4Will not be entering Pointer Check mode.");
                                            endif;
                                            break;
                                        endif;
                                    endif;
                                    
                                    // 3. Check if we can click the Item
                                    if(true);
                                        can_click = canDoInteraction(%#waited_ticks%,%#collect_wait%);
                                        if(%can_click%);
                                            slotclick(%#auction_state_slot%,"right");
                                            item_clicked = true;
                                        endif;
                                    endif;
                                    
                                    // 4. Check if any of our pointers are set
                                    if(true);
                                        foreach(&check_bool_pointers[],&check_bool_pointer,#cbp);
                                            check_bool_state := "%%&check_bool_pointer%%";
                                            if(%check_bool_state%);
                                                if(%&check_bool_pointer% == "@ah_failure");
                                                    debug_error(%debug%,%&script_debug_name%,"Error Pointer @ah_failure is set!");
                                                    &return_string = %&enum_unknown%;
                                                    break;
                                                elseif(%&check_bool_pointer% == "@ah_confirm");
                                                    debug_log(%debug%,%&script_debug_name%,"Success Pointer @ah_confirm is set!");
                                                    &return_string = %&enum_success%;
                                                    break;
                                                endif;
                                            endif;
                                        next;
                                    endif;
                                    
                                    wait("1t");
                                    inc(#waited_ticks);
                                until((%&return_string% != "") || (%entered_new_gui%));
                            endif;
                        endif;
                    endif;
                until(%&return_string% != "");
            endif;
            
            return(%&return_string%);
        endfunction;
//! @mkb-import-end