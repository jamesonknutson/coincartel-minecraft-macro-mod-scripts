//! @mkb-import-begin
    // info/index/_matchExpressionNBT
        // Used by getItemName, getItemUUID, getItemSBID to extract a regular expression capture group from NBT Data.
            // Params:
            //      {string} <&haystack>    The string to extract the first capture group from.
            //      {string} <&expression>  The expression to test against <&haystack>, must have at least one capture group.
            //
            // Returns the first capture group's content from the <&expression> match, or an empty string if no match is found.
        function _matchExpressionNBT(&haystack,&expr);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:34
            &return_string = "";
            ifmatches(%&haystack%,%&expr%,&capture_group,1);
                &return_string = %&capture_group%;
            endif;
            return(%&return_string%);
        endfunction;
    // info/index/getItemSBID
        // Given the NBT Data of an Item, extracts the Item's SBID from the NBT Data.
            // Params:
            //      {string} <&nbt> The NBT Data to extract the Item SBID from.
            //
            // Returns the Item's SBID, or an empty string if one is not found.
        function getItemSBID(&nbt);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:103
            &nbt           = strip(%&nbt%);
            &return_string = _matchExpressionNBT(%&nbt%,"\bid\"?\s*:\"([A-Z_0-9:]+)\"");
            return(%&return_string%);
        endfunction;
    // string/index/convertENote
        // Converts a Number formatted in Exponential Notation (e.g. "3.172E10") to standard string decimal form.
            // Params:
                // {string} <&enote_string>    The E. Notation Number string to convert.
                //
            // Returns the Number coerced into a valid decimal float value. If a non-e-notation string is passed,
            // the input string is returned as-is.
        function convertENote(&convert_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:172
            debug              = true;
            &script_debug_name = "&9convertENote&7";
            &convert_string    = replace(&convert_string,",");
            &return_string     = %&convert_string%;
            ifmatches(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$");
                match(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$",{&m_sign_num,&m_leading_num,&m_trailing_num,&m_sign_exponent,&m_exponent_num});
                output_negative   = %&m_sign_num% == "-";
                exponent_negative = %&m_sign_exponent% == "-";
                
                // Convert Scientific Notation to a Real Number
                // Multiply the decimal number by 10 raised to the power indicated.
                // 3.456 x 10^4  = 3.456 x 10,000 = 34560
                // 3.456 x 10^-4 = 3.456 x .0001  = 0.0003456
                //
                
                //    Convert Scientific Notation without a Calculator
                //    We’ve shown you how to convert a number expressed in scientific notation to a decimal by solving,
                //    but this would get more difficult to do manually as the exponent gets larger. There’s an alternate
                //    way to convert to decimal without solving the equation.
                //
                //    If the exponent is positive, move the decimal point in the coefficient to the right one space for each
                //    value in the exponent.
                //
                //    For instance, if the exponent is two, then move the decimal point to the right two spaces. If the exponent
                //    is negative, then move the decimal point to the left.
                //
                //    For example, let’s convert 1.5 × 10^2 to a decimal using this method.
                //
                //    1.5 × 10^2 = 15.0  × 10^1
                //    1.5 × 10^2 = 150.0 × 10^0
                //    1.5 × 10^2 = 150.0
                
                //    For a Positive Exponent (moving decimal point to the right)
                    //    1.396       x    10^6    =    13.96        x 10^5
                    //    13.96       x    10^5    =    139.6        x 10^4
                    //    139.6       x    10^4    =    1396.0       x 10^3
                    //    1396.0      x    10^3    =    13960.0      x 10^2
                    //    13960.0     x    10^2    =    139600.0     x 10^1
                    //    139600.0    x    10^1    =    1396000.0    x 10^0
                    //    1.396       x    10^6    =    1396000.0
                //    For a Negative Exponent (moving decimal point to the left)
                    //    1.396          x    10^-6    = 0.1396         x    10^-5
                    //    0.1396         x    10^-5    = 0.01396        x    10^-4
                    //    0.01396        x    10^-4    = 0.001396       x    10^-3
                    //    0.001396       x    10^-3    = 0.0001396      x    10^-2
                    //    0.0001396      x    10^-2    = 0.00001396     x    10^-1
                    //    0.00001396     x    10^-1    = 0.000001396    x    10^ 0
                    //    0.000001396    x    10^-6    = 0.000001396
                
                #m_exponent_num  := %&m_exponent_num%;
                &m_joint_chars    = "%&m_leading_num%.%&m_trailing_num%";
                &m_joint_chars[]  = split("",%&m_joint_chars%);
                do(%#m_exponent_num%);
                    #m_joint_chars_sz   = arraysize(&m_joint_chars[]);
                    #m_joint_chars_len  = %#m_joint_chars_sz% - 1;
                    #curr_decimal_idx   = indexof(&m_joint_chars[],,".");
                    if(!%exponent_negative%);
                        #next_decimal_idx = %#curr_decimal_idx% + 1;
                        if(%#next_decimal_idx% <= %#m_joint_chars_len%);
                            &m_joint_chars[%#curr_decimal_idx%] = %&m_joint_chars[%#next_decimal_idx%]%;
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        else;
                            &m_joint_chars[%#curr_decimal_idx%] = "0";
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        endif;
                    else;
                        #next_decimal_idx = %#curr_decimal_idx% - 1;
                        if(%#next_decimal_idx% >= 0);
                            &m_joint_chars[%#curr_decimal_idx%] = %&m_joint_chars[%#next_decimal_idx%]%;
                            &m_joint_chars[%#next_decimal_idx%] = ".";
                        else;
                            unset(&tmp_joint_chars[]);
                            &m_joint_chars[%#curr_decimal_idx%] = "0";
                            push(&tmp_joint_chars[],".",&m_joint_chars[*]);
                            unset(&m_joint_chars[]);
                            push(&m_joint_chars[],&tmp_joint_chars[*]);
                        endif;
                    endif;
                loop;
                &return_string = join("",&m_joint_chars[]);
                &return_string = regexreplace(&return_string,"\.0*$");
                &return_string = regexreplace(&return_string,"^\.","0.");
                &return_string = "%&m_sign_num%%&return_string%";
            endif;
            return(%&return_string%);
        endfunction;
    // debug/index/debug_log
        // Logs a message to chat if debug is enabled.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_log(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:30
            // &matcher     = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement = "&$1";
            // &string      = regexreplace(&string,%&matcher%,%&replacement%);
            &out_string  = "&7%&script_debug_name%&7: %&string%";
            if(%debug_enabled%);
                log(%&out_string%);
            endif;
            return(%&out_string%);
        endfunction;
    // string/index/xEval
        // Identical to original `eval`, but passes the result of the function along to `convertENote` to ensure decimal values are conserved.
            // Params:
                // {string} <&expression>              The arithmetic expression to evaluate with `eval`.
                // {boolean} [coerce_integer=false]    If true, will attempt to coerce the result of the evaluation from a decimal value into an integer.
            // Returns the result of `eval` passed through `convertENote`, and optionally coerced into an Integer if [coerce_integer] is True.
        function xEval(&expression,coerce_integer=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:276
            debug              = false;
            &script_debug_name = "&9xEval&7";
            debug_log(%debug%,%&script_debug_name%,"evaluating '%&expression%', coerce_integer: %coerce_integer%.");
            &return_string     = eval(%&expression%);
            debug_log(%debug%,%&script_debug_name%,"got result: '&d%&return_string%&7', passing thru convertENote");
            &return_string     = convertENote(%&return_string%);
            debug_log(%debug%,%&script_debug_name%,"convertENote returned: '&d%&return_string%&7'");
            if(%coerce_integer%);
                debug_log(%debug%,%&script_debug_name%,"coercing '&d%&return_string%&7' to a number");
                &return_string = formatnumber(%&return_string%,0,true);
            endif;
            debug_log(%debug%,%&script_debug_name%,"returning '&d%&return_string%&7'");
            return(%&return_string%);
        endfunction;
    // misc/index/miscValidate
        // Validates that <&search_term> is found in the <&array[]>, and/or if it is not found in the <&array[]>, the value of the element
        // found at [#default_idx=0] is returned. Set [#default_idx] to -1 to indicate that no default value should be used.
            // Params:
            //      {array} <&elements[]>       The Array to search for <&search_term> in.
            //      {string} <&search_term>     The Search Term to check if exists in <&elements[]>.
            //      {number} [#default_idx=0]   The Index of the Element in <&elements[]> to use as the default return value
            //                                  if <&search_term> is not found within the Array. If -1, will be taken as no default
            //                                  value should be used.
            //
            // Returns the element from the <&elements[]> Array that <&search_term> matches, or if no match was found and [#default_idx]
            // is not -1, the element at [#default_idx] in the <&elements[]> Array. If [#default_idx] is -1, an empty string is returned.
        function miscValidate(&search_term,#default_idx=0,...&elements[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/index.txt:12
            #term_index = indexof(&elements[],,%&search_term%);
            if(%#term_index% != -1);
                &return_string = %&elements[%#term_index%]%;
            elseif(%#default_idx% != -1);
                &return_string = %&elements[%#default_idx%]%;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/coerceNumber
        // Coerces an input number string into a valid integer. The input number string can be in E Notation, or contain
        // commas, or contain decimal values, or any mix of the above.
            // Params:
                // {string} <&number_string>                The Number String to Convert into a valid Integer.
                // {string} [&rounding_strategy="ROUND"]    String ENUM that dictates how to handle decimal values. Valid values are:
                //                                          FLOOR (towards negative infinity), CEILING|CEIL (towards positive infinity),
                //                                          TRUNCATE|TRUNC (rounds up or down towards 0), ROUND (towards nearest integer).
                //                                          Defaults to ROUND if omitted or an invalid input is provided.
            // Returns the Number coerced into a valid Integer (real-integer type, not string type. If the input string is not
            // coercable at all, 0 will be returned). If the final value before coercion to integer contains decimals, the coerced value
            // will be rounded according to the [&rounding_strategy] parameter.
            // Example:
                //    Converting a comma split, float string into an Integer
                    //    &number_string     = "100,000.9171";
                    //    &rounding_strategy = "ROUND";
                    //    #number_integer    = coerceNumber(%&number_string%,%&rounding_strategy%);
                    //    log("#number_integer: %#number_integer%"); // '#number_integer: 100001'
                //    Replace the content in the Parameters as needed:
                    //    &number_string     = "Can contain commas, decimals, e. notation, or mix of all three.";
                    //    &rounding_strategy = "One of: FLOOR, CEILING|CEIL, TRUNCATE|TRUNC, ROUND, or empty string.";
                    //    #number_integer    = coerceNumber(%&number_string%,%&rounding_strategy%);
        function coerceNumber(&number_string,&rounding_strategy="ROUND");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:343
            &number_string = replace(&number_string,",");
            &number_string = convertENote(%&number_string%);
            ifcontains(%&number_string%,".");
                &rounding_strategy = miscValidate(%&rounding_strategy%,0,"ROUND","FLOOR","CEILING","CEIL","TRUNCATE","TRUNC");
                if(%&rounding_strategy% == "ROUND");
                    // Round the decimal value to the nearest integer.
                    &return_string = formatnumber(%&number_string%,0,true);
                elseif((%&rounding_strategy% == "TRUNCATE") || (%&rounding_strategy% == "TRUNC"));
                    // Exclude the decimal value entirely.
                    &return_string = regexreplace(&number_string,"\.\d*$");
                else;
                    // Use xEval to evaluate the number_string with the corresponding rounding_term. Instruct
                    // xEval to coerce the value into an integer for us, so any trailing ".0" is stripped from it's
                    // return value.
                    if((%&rounding_strategy% == "CEILING") || (%&rounding_strategy% == "CEIL"));
                        &rounding_term = "ceil";
                    elseif(%&rounding_strategy% == "FLOOR");
                        &rounding_term = "floor";
                    endif;
                    &return_string = xEval("%&rounding_term%(%&number_string%)",true);
                endif;
            else;
                // The Number does not contain a decimal value to begin with, return as usual.
                &return_string = %&number_string%;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/stringToNumber
        // Coerces a given String to a Number (no decimal points).
            // Params:
                // {string} <&convert_string>    The String to Convert.
                // {number} [#precision=0]       Decimal Precision
            // Returns the Number result of the coercion.
        function stringToNumber(&convert_string,#precision=0);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:113
            #convert_number = coerceNumber(%&convert_string%);
            return(%#convert_number%);
        endfunction;
    // string/index/isStringFormattedNumber
        // Checks if a String is a valid Float/Number (with commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Formatted Number.
        function isStringFormattedNumber(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:80
            ifmatches(%&check_string%,"^[\d-]+,[\d.,-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
    // string/index/isStringInteger
        // Checks if a String is a valid Integer.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Integer.
        function isStringInteger(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:58
            ifmatches(%&check_string%,"^[0-9-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
    // string/index/isStringFloat
        // Checks if a String is a valid Float (without commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringFloat(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:69
            ifmatches(%&check_string%,"^[0-9-]*\.[0-9]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
    // string/index/isStringNumber
        // Checks if a String is a valid Number, coercable to a Float of some sort.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringNumber(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:91
            &call_functions[] = split(", ","isStringInteger, isStringFloat, isStringFormattedNumber");
            foreach(&call_functions[],&call_function,#cfi);
                if(%&call_function% == "isStringInteger");
                    return_boolean = isStringInteger(%&check_string%);
                elseif(%&call_function% == "isStringFloat");
                    return_boolean = isStringFloat(%&check_string%);
                elseif(%&call_function% == "isStringFormattedNumber");
                    return_boolean = isStringFormattedNumber(%&check_string%);
                endif;
                if(%return_boolean%);
                    break;
                endif;
            next;
            return(%return_boolean%);
        endfunction;
    // info/index/getDatamapItemIndex
        // Given a Search Term (an entry from: sb_datamap_item_names, sb_datamap_item_sbids, or it's Index), looks up the Search Term in the aforementioned Arrays
        // until it finds the Index for the Item.
            // Params:
                // {string} <&search_term>    The Search Term to Search for. Should be the Index, SBID, or Default Display Name.
                //
            // Returns the Index where the Item can be found in the sb_datamap_item_ Arrays, or -1 if it could not be found.
        function getDatamapItemIndex(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:978
            #return_number   = -1;
            &search_arrays[] = split(", ","names, sbids");
            &search_prefix   = "@&sb_datamap_item_";
            foreach(&search_arrays[],&search_array_suffix,#sasi);
                &search_array = "%&search_prefix%%&search_array_suffix%[]";
                #search_index = indexof(%&search_array%,,%&search_term%);
                if(%#search_index% != -1);
                    #return_number = %#search_index%;
                    break;
                endif;
            next;
            if(%#return_number% == -1);
                is_number = isStringNumber(%&search_term%);
                if(%is_number%);
                    #index_number             = stringToNumber(%&search_term%);
                    #sb_datamap_item_names_sz = arraysize(@&sb_datamap_item_names[]);
                    #sb_datamap_item_names_sz = %#sb_datamap_item_names_sz% -1;
                    if((%#index_number% >= 0) && (%#index_number% <= %#sb_datamap_item_names_sz%));
                        #return_number = %#index_number%;
                    endif;
                endif;
            endif;
            return(%#return_number%);
        endfunction;
    // gui/getRoom/getStackRoomInventory
        // Calculates the amount of Room available for <&search_term> in the Inventory.
            // Params:
                // {string} <&search_term>    The Item's Default Display Name or SBID. Must be findable in the @&sb_datamap_item_... arrays.
                //
            // Returns the Integer amount of Room we have available for the <&search_term> in the Inventory. If <&search_term> cannot be resolved,
            // the default return value is always 0.
        function getStackRoomInventory(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/getRoom.txt:6
            #return_number = 0;
            #datamap_index = getDatamapItemIndex(%&search_term%);
            if(%#datamap_index% != -1);
                &r_json      = %@&sb_datamap_item_jsons[%#datamap_index%]%;
                #r_max_stack = jsonget("maxStack",%&r_json%);
                
                // Iterate over Static Inventory Slots
                if(true);
                    #r_start  = 9;
                    #r_end    = 43;
                    &r_item   = %@&sb_datamap_item_mcids[%#datamap_index%]%;
                    &r_sbid   = %@&sb_datamap_item_sbids[%#datamap_index%]%;
                    for(#r_slot,%#r_start%,%#r_end%);
                        #f_slot = %#r_slot%;
                        if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                            #r_offset = %#f_slot% + 1;
                            &f_item   = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                            if(%&f_item% == "air");
                                #return_number = %#return_number% + %#r_max_stack%;
                            else;
                                &f_nbt    = strip(%&f_nbt%);
                                &f_sbid   = getItemSBID(%&f_nbt%);
                                m_item    = ((!%&r_item%) || (%&r_item% == %&f_item%));
                                m_name    = ((!%&r_name%) || (%&r_name% == %&f_name%));
                                m_sbid    = ((!%&r_sbid%) || (%&r_sbid% == %&f_sbid%));
                                m_match   = ((%m_item%) && (%m_name%) && (%m_sbid%));
                                if(%m_match%);
                                    #stack_room    = %#r_max_stack% - %#f_stack%;
                                    #return_number = %#return_number% + %#stack_room%;
                                endif;
                            endif;
                        else;
                            break;
                        endif;
                    next;
                endif;
            endif;
            return(%#return_number%);
        endfunction;
    // gui/index/invslot_to_conslot
        // Takes input of a getslotiteminv indexed inventory slot (static, starts at 9 for top left inv, ends @ 44 bottom right inv)
        // and converts it to it's dynamic position in whatever GUI is currently opened.
            // Params:
            //      {number} <#slot>    The getslotiteminv indexed inventory slot to convert
            //
            // Returns <#slot>'s dynamic slot ID in whichever container is currently opened, or -1 if no container with CONTAINERSLOTS is opened.
        function invslot_to_conslot(#slot);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:62
            if(%CONTAINERSLOTS% >= 1);
                #conslot = (%CONTAINERSLOTS% - 45) + %#slot%;
                return(%#conslot%);
            else;
                return(-1);
            endif;
        endfunction;
    // info/index/getItemName
        // Given the NBT Data of an Item (and optionally it's base item), extracts the Display Name of the Item from the NBT Data.
            // Params:
            //      {string} <&nbt>         The NBT Data to extract the Name from.
            //      {string} [&item="air"]  The Item this NBT Data was collected from (only used in cases where the Item's Name cannot be found).
            //      {boolean} [strip=true]  Whether or not to strip formatting codes from the extracted Name.
            //
            // Returns the Display Name of the Item found from it's NBT Data, with formatting codes stripped if [strip] is true.
        function getItemName(&nbt,&item="air",strip=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:49
            ifmatches(%&nbt%,".*\bName\s*:\"\s*(.*?)\"",&found_name,1);
                if(%strip%);
                    &found_name = strip(%&found_name%);
                endif;
            elseif(%&item% == "air");
                &found_name = "Air";
            endif;
            return(%&found_name%);
        endfunction;
    // gui/containerLog/containerLog
                // {boolean} [append=false]            Whether or not to append the Data to the specified file.
                // {string} [...&context_strings[]]    Optional strings that will prepend the Container Data in the logged file.
                //
            // Returns the Path to the File where the Data was logged to.
        function containerLog(&log_path,append=false,...&context_strings[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/containerLog.txt:8
            if(!%&log_path%);
                &log_path = "~liteconfig/common/macros/logs/%TIMESTAMP%-containerNbt.txt";
            endif;
            
            &log_strings[] = "--- Begin Metadata ---";
            &log_strings[] = "";
            &log_strings[] = "Generation Time: %DATETIME%";
            &log_strings[] = "GUI: %GUI%";
            &log_strings[] = "CONTAINERSLOTS: %CONTAINERSLOTS%";
            &log_strings[] = "CONTAINERNAME: %CONTAINERNAME%";
            &log_strings[] = "";
            
            #context_strings_sz = arraysize(&context_strings[]);
            if(%#context_strings_sz%);
                &log_strings[] = "--- Begin Context Strings ---";
                &log_strings[] = "";
                push(&log_strings[],&context_strings[*]);
                &log_strings[] = "";
            endif;
            
            // Iterate over Static Inventory Slots
            if(true);
                &log_strings[] = "--- Begin Inventory ---";
                &log_strings[] = "";
                #r_start       = 9;
                #r_end         = 44;
                for(#f_slot,%#r_start%,%#r_end%);
                    &f_item        = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                    &f_nbt         = strip(%&f_nbt%);
                    &f_name        = getItemName(%&f_nbt%,%&f_item%);
                    &f_sbid        = getItemSBID(%&f_nbt%);
                    #c_slot        = invslot_to_conslot(%#f_slot%);
                    &log_strings[] = "Container Slot: %#c_slot% | Static Inventory Slot: %#f_slot%";
                    &log_strings[] = "MCID: %&f_item%:%#f_data%";
                    &log_strings[] = "Stack: %#f_stack%";
                    &log_strings[] = "Name: %&f_name%";
                    &log_strings[] = "SBID: %&f_sbid%";
                    &log_strings[] = "NBT: %&f_nbt%";
                    &log_strings[] = "";
                next;
            endif;
            
            // Iterate over Dynamic Container Slots
            if(%CONTAINERSLOTS%);
                &log_strings[] = "--- Begin Container ---";
                &log_strings[] = "";
                #r_start  = 0;
                #r_end    = %CONTAINERSLOTS% - 37;
                for(#f_slot,%#r_start%,%#r_end%);
                    &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                    &f_nbt    = strip(%&f_nbt%);
                    &f_name   = getItemName(%&f_nbt%,%&f_item%);
                    &f_sbid   = getItemSBID(%&f_nbt%);
                    &log_strings[] = "Container Slot: %#c_slot% | Static Inventory Slot: %#f_slot%";
                    &log_strings[] = "MCID: %&f_item%:%#f_data%";
                    &log_strings[] = "Stack: %#f_stack%";
                    &log_strings[] = "Name: %&f_name%";
                    &log_strings[] = "SBID: %&f_sbid%";
                    &log_strings[] = "NBT: %&f_nbt%";
                    &log_strings[] = "";
                next;
            endif;
            
            &file_path = writefile(%&log_path%,&log_strings[],%append%);
        endfunction;
    // misc/index/canDoInteraction
        // Checks if we can 'do' an Interaction by determining whether we have waited a whole amount of <#ticks_per_action> in <#waited_ticks>.
        // Basically a modulo operation. If return True, execute Action. If not, skip action and keep waiting.
            // Params:
                // {number} [#waited_ticks=0]    Amount of Ticks that have been waited thus far
                // {number} [#tick_wait=20]      Ticks to wait in between actions
            // Returns a Boolean
            // Example:
                //    can_do_action = canDoInteraction(%#waited_ticks%,%#tick_wait%);
        function canDoInteraction(#waited_ticks=0,#tick_wait=20);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/index.txt:43
            #actions_done  = %#waited_ticks% / %#tick_wait%;
            #ticks_to_next = %#waited_ticks% - (%#actions_done% * %#tick_wait%);
            can_do_action  = %#ticks_to_next% == 0;
            return(%can_do_action%);
        endfunction;
    // debug/index/debug_error
        // Logs a message to chat with an error prefix.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_error(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:49
            // &matcher       = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement   = "&$1";
            // &string        = regexreplace(&string,%&matcher%,%&replacement%);
            &error_message = "&4Error > &c%&string%";
            &error_message = regexreplace(&error_message,"&7","&c");
            &error_message = "&7%&script_debug_name%&7: %&error_message%";
            if(%debug_enabled%);
                log(%&error_message%);
            endif;
            return(%&error_message%);
        endfunction;
    // info/index/hasTimeExceeded
        // Used to determine whether to timeout a function.
            // Params:
                // {number} <#start_time>        The start timestamp to subtract from current timestamp
                // {number} <#timeout_sec>       The amount of seconds to check if difference between now & start is >=.
                // {number} [do_timeout=true]    If false, will always return false (used as shorthand for functions that
                //                               use this function to determine whether or not they have timed out).
            // Returns a boolean indicating whether or not <#start_timestamp> was >= <#seconds> ago.
            // Example:
                //    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
        function hasTimeExceeded(#start_time,#timeout_sec,do_timeout=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:10
            #elapsed_sec   = %TIMESTAMP% - #start_time;
            return_boolean = ((%do_timeout%) && (#elapsed_sec >= #timeout_sec));
            return(%return_boolean%);
        endfunction;
    // info/index/isInLimbo
        // Checks if the Player is in Limbo by reading the Dimension, as well as checking to see if there are any signs at the sign positions
        // where they normally are in Limbo.
            // Params:
            //      None
            //
            // Returns a boolean indicating whether or not the Player is in Limbo.
        function isInLimbo();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:475
            if((%YPOS% > 35) || (%DIMENSION% != "END"));
                return(False);
            endif;
            
            #limbo_x = -20;
            #limbo_y = 32;
            #limbo_z = 21;
            
            if((%XPOS% == #limbo_x) && (%YPOS% == #limbo_y) && (%ZPOS% == #limbo_z));
                return(True);
            endif;
            
            &armor_vars[] = split(", ","ITEM, BOOTSID, LEGGINGSID, CHESTPLATEID, HELMID");
            all_air       = true;
            foreach(&armor_vars[],&armor_var);
                &armor_val = "%%&armor_var%%";
                if(%&armor_val% != "air");
                    all_air = false;
                    break;
                endif;
            next;
            if((%SLOTSFULL% == 0) && (%all_air%));
                return(True);
            endif;
            
            #sign_x   = -21;
            #sign_y[] = split(", ","31, 32, 33");
            #sign_z[] = split(", ","20, 21, 22");
            foreach(#sign_y[],#sign_y);
                foreach(#sign_z[],#sign_z);
                    &block_id = getid(%#sign_x%,%#sign_y%,%#sign_z%);
                    if(&block_id == "wall_sign");
                        in_limbo = true;
                        break;
                    endif;
                next;
            next;
        endfunction;
    // info/index/getHypixelGamemodeFromScoreboard
        // Attempts to read the Scoreboard (foreach("teams") ... prefix + suffix ... next) to find the Player's location on Hypixel
            // Params:
            //      None
            //
            // Returns one of the following strings: 'LOBBY', 'SKYBLOCK', or 'OTHER'. 'OTHER' indicates that the function
            // was not able to determine which area the Player is located in.
        function getHypixelGamemodeFromScoreboard();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:382
            &return_string = "OTHER";
            
            // Setup indicator strings
            if(true);
                &match_expr[] = "Games in this lobby are"; // Only shown in Prototype Lobby Servers
                &match_area[] = "LOBBY";
                
                &match_expr[] = "^Achievements: .+$"; // Only shown in Hypixel Main Lobby Servers
                &match_area[] = "LOBBY";
                
                &match_expr[] = "^Purse: [0-9,.]+"; // Only shown in SkyBlock Servers
                &match_area[] = "SKYBLOCK";
                
                &match_expr[] = "^Bits: [0-9,.]+"; // Only shown in SkyBlock Servers
                &match_area[] = "SKYBLOCK";
            endif;
            
            foreach("teams");
                &joint_team = strip("%TEAMPREFIX%%TEAMSUFFIX%");
                &joint_team = trim(%&joint_team%);
                &joint_team = regexreplace(&joint_team,"^\s*","");
                foreach(&match_expr[],&match_expr,#mei);
                    ifmatches(%&joint_team%,%&match_expr%);
                        &return_string = %&match_area[%#mei%]%;
                        break;
                    endif;
                next;
            next;
            
            return(%&return_string%);
        endfunction;
    // info/index/getSkyBlockPlayerListInfo
        // Returns an Array of information extracted from the Hypixel SkyBlock PlayerList.
            // Params:
            //      {string} [...&extract_vars[]]   The variables to extract from the Player List. Valid values are:
            //                                      'AREA', 'SERVER', 'PROFILE', 'BANK', 'SKILLS', 'SPEED', 'STRENGTH',
            //                                      'CRIT_CHANCE', 'CRIT_DAMAGE', 'ATTACK_SPEED'. If no values are provided,
            //                                      will return variables 'AREA', and 'PROFILE' by default.
            //
            // Returns an Array of the extracted variables indexed in the order they were passed to the Function,
            // or if no variables were able to be extracted, the first element of this Array will be -1.
        function getSkyBlockPlayerListInfo(...&extract_vars[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:258
            // Setup valid variables
            if(true);
                &valid_vars[]  = split(", ","AREA, SERVER, PROFILE, BANK, SKILLS, SPEED, STRENGTH, CRIT_CHANCE, CRIT_DAMAGE, ATTACK_SPEED");
                #extract_len   = arraysize(&extract_vars[]);
                assign_default = #extract_len == 0;
                if(!%assign_default%);
                    foreach(&valid_vars[],&valid_var);
                        #extract_idx = indexof(&extract_vars[],,%&valid_var%);
                        if(#extract_idx != -1);
                            &use_out_vars[] = %&valid_var%;
                            #use_out_idxs[] = %#extract_idx%;
                            matched[]       = false;
                        endif;
                    next;
                    #use_out_len   = arraysize(&use_out_vars[]);
                    assign_default = #use_out_len == 0;
                endif;
                
                if(!%assign_default%);
                    sort("ASC",#use_out_idxs[],&use_out_vars[]);
                else;
                    &use_out_vars[] = split(", ","AREA, PROFILE");
                    matched[]       = split(", ","false, false");
                endif;
            endif;
            
            // Compile matches
            if(true);
                #return_index = indexof(&use_out_vars[],,"AREA");
                if(#index_area != -1);
                    &match_names[] = "!C-b";
                    &match_exprs[] = "Area: (.+)"; // Area: Private Island
                endif;
                
                #return_index = indexof(&use_out_vars[],,"SERVER");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!C-c";
                    &match_exprs[%#return_index%] = "Server: (.+)"; // Server: mini787Q
                endif;
                
                #return_index = indexof(&use_out_vars[],,"PROFILE");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!D-b";
                    &match_exprs[%#return_index%] = "Profile: (.+)"; // Profile: Pineapple
                endif;
                
                #return_index = indexof(&use_out_vars[],,"BANK");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!D-d";
                    &match_exprs[%#return_index%] = "Bank: (.+)"; // Bank: 50/50
                endif;
                
                #return_index = indexof(&use_out_vars[],,"SKILLS");
                if(#return_index != -1);
                    &match_names[%#return_index%] = "!D-g";
                    &match_exprs[%#return_index%] = "Skills: (.+)"; // Skills: Foraging 17: 24.1%
                endif;
                
                #return_index = indexof(&use_out_vars[],,"SPEED");
                if(#return_index != -1);
                    &tmp_expr_char                = char("10022");
                    &match_names[%#return_index%] = "!D-h";
                    &match_exprs[%#return_index%] = "Speed: %&tmp_expr_char%(.+)"; // Speed: ✦220
                endif;
                
                #return_index = indexof(&use_out_vars[],,"STRENGTH");
                if(#return_index != -1);
                    &tmp_expr_char                = char("10049");
                    &match_names[%#return_index%] = "!D-i";
                    &match_exprs[%#return_index%] = "Strength: %&tmp_expr_char%(.+)"; // Strength: ❁149
                endif;
                
                #return_index = indexof(&use_out_vars[],,"CRIT_CHANCE");
                if(#return_index != -1);
                    &tmp_expr_char                = char("9763");
                    &match_names[%#return_index%] = "!D-j";
                    &match_exprs[%#return_index%] = "Crit Chance: %&tmp_expr_char%(.+)"; // Crit Chance: ☣64
                endif;
                
                #return_index  = indexof(&use_out_vars[],,"CRIT_DAMAGE");
                if(#return_index != -1);
                    &tmp_expr_char                = char("9760");
                    &match_names[%#return_index%] = "!D-k";
                    &match_exprs[%#return_index%] = "Crit Damage: %&tmp_expr_char%(.+)"; // Crit Damage: ☠130
                endif;
                
                #return_index  = indexof(&use_out_vars[],,"ATTACK_SPEED");
                if(#return_index != -1);
                    &tmp_expr_char                = char("9876");
                    &match_names[%#return_index%] = "!D-l";
                    &match_exprs[%#return_index%] = "Attack Speed: %&tmp_expr_char%(.+)"; // Attack Speed: ⚔0
                endif;
            endif;
            
            foreach("players");
                #line_index = indexof(&match_names[],,%PLAYERNAME%);
                if(#line_index != -1);
                    matched[%#line_index%] = true;
                    &line_text             = strip(%PLAYERDISPLAYNAME%);
                    &line_text             = trim(%&line_text%);
                    ifmatches(%&line_text%,%&match_exprs[%#line_index%]%,&capture_group,1);
                        &return_array[%#line_index%] = %&capture_group%;
                        #non_matched_var_index       = indexof(matched[],,false);
                        if(#non_matched_var_index == -1);
                            break;
                        endif;
                    endif;
                endif;
            next;
            
            #return_len = arraysize(&return_array[]);
            if(#return_len == 0);
                &return_array[] = -1;
            endif;
            return(&return_array[]);
        endfunction;
    // info/index/getHypixelGamemode
        // Gets the current Gamemode / Gametype that the Player is in by reading the Scoreboard, etc.
        // Params:
        //      None
        //
        // Returns one of: 'LOBBY', 'LIMBO', 'SKYBLOCK', or 'OTHER'.
        function getHypixelGamemode();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:520
            if(true);
                do(3);
                    // Check to see if we can read the Gamemode from the 9th Hotbar Slot.
                    if(true);
                        #static_hb_end = 44;
                        &found_item    = getslotiteminv(%#static_hb_end%,,#found_stack,#found_data,&found_nbt);
                        &found_nbt     = strip(%&found_nbt%);
                        &found_name    = getItemName(%&found_nbt%,%&found_item%);
                        
                        &known_names[] = split(", ","Lobby Selector (Right Click), SkyBlock Menu (Right Click)");
                        &known_areas[] = split(", ","LOBBY, SKYBLOCK");
                        #known_index   = indexof(&known_names[],,%&found_name%);
                        if(%#known_index% != -1);
                            &return_string = %&known_areas[%#known_index%]%;
                            break;
                        endif;
                    endif;
                    
                    // Cant find the Gamemode from the 9th Hotbar Slot, have to read additional Data. Check to see if we can find any Data from the Playerlist.
                    &skyblock_area = getSkyBlockPlayerListInfo("AREA");
                    if(%&skyblock_area% != "-1");
                        &return_string = "SKYBLOCK";
                        break;
                    endif;
                    
                    // Try to read the location from the Scoreboard.
                    &scoreboard_location = getHypixelGamemodeFromScoreboard();
                    if(%&scoreboard_location% != "OTHER");
                        &return_string = %&scoreboard_location%;
                        break;
                    endif;
                    
                    // Check if we are in Limbo as a last resort
                    in_limbo = isInLimbo();
                    if(%in_limbo%);
                        &return_string = "LIMBO";
                        break;
                    endif;
                    
                    wait("1000ms");
                loop;
            endif;
            
            if(%&return_string% != "");
                return(%&return_string%);
            endif;
            return("OTHER");
        endfunction;
    // info/index/getServerID
        // Gets the Current Server ID.
            // REQUIRES CHATFILTER EXPRESSIONS:
                //    elseifmatches(%CHATCLEAN%,"^You are currently (?:connected to server|in) (.+)$",&current_server_id);
                //        @&current_server_id = ucase(%&current_server_id%);
                //        if(%debug%);
                //            log("&7%&script_debug_name%&7: Updated '&e@&&current_server_id&7' to '&d%@&current_server_id%&7'.");
                //        endif;
                //    elseifmatches(%CHATCLEAN%,"^Unknown command. Type \"/help\" for help.$");
                //        @chatfilter_unknown_cmd = true;
            // Params:
                // {number} [#wait_ticks=20]     Amount of Ticks to wait between actions
                // {number} [#timeout_sec=30]    Maximum amount of Seconds the Function can execute for before timing out and returning ERROR_TIMEOUT.
            // Returns the Server ID, or an Error String ENUM:
                // ERROR_TIMEOUT    Function timed out
                // ERROR_UNKNOWN    Function failed for an unknown reason
                // ERROR_COMMAND    Function failed because Command was not available on our Server somehow
        function getServerID(#wait_ticks=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:1020
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9getServerID&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &enum_timeout      = "ERROR_TIMEOUT";
                &enum_unknown      = "ERROR_UNKNOWN";
                &enum_command      = "ERROR_COMMAND";
            endif;
            
            // 1. Check to see if we can grab the Server ID from the Tablist and/or checking to see if we are in Limbo.
            if(true);
                // 1a. Check the Tablist
                if(true);
                    debug_log(%debug%,%&script_debug_name%,"Trying to get Server ID from SkyBlock Tablist...");
                    &server_id = getSkyBlockPlayerListInfo("SERVER");
                    &server_id = ucase(%&server_id%);
                    debug_log(%debug%,%&script_debug_name%,"Returned Server ID is '&d%&server_id%&7'.");
                    if((%&server_id% != "") && (%&server_id% != "-1"));
                        @&current_server_id = %&server_id%;
                        debug_log(%debug%,%&script_debug_name%,"Got a valid Server ID from the Tab List: '&d%&server_id%&7'. Returning it.");
                        return(%&server_id%);
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"Did not get a valid Server ID from the Tab List. Checking if we are in Limbo...");
                endif;
                
                // 1b. Check if we are in Limbo
                if(true);
                    &current_gamemode = getHypixelGamemode();
                    if(%&current_gamemode% == "LIMBO");
                        debug_log(%debug%,%&script_debug_name%,"We are in Limbo. Returning '&dLIMBO&7'.");
                        @&current_server_id = "LIMBO";
                        return("LIMBO");
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"We are not in Limbo. Trying /whereami Command...");
                endif;
            endif;
            
            // 2. Loop command '/whereami' until we find out what Server we are on, or we encounter an Error we cannot recover from.
            if(true);
                unset(@&current_server_id);
                unset(@chatfilter_unknown_cmd);
                #waited_ticks = 0;
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Check if we have a Server ID, or if we are on a Server where this Command is not available somehow.
                    if((%message_sent%) && ((%@&current_server_id% != "") || (%@chatfilter_unknown_cmd%)));
                        if(%@&current_server_id% != "");
                            debug_log(%debug%,%&script_debug_name%,"Got a valid Current Server ID: '&d%@&current_server_id%&7'.");
                            &return_string = %@&current_server_id%;
                        elseif(%@chatfilter_unknown_cmd%);
                            debug_error(%debug%,%&script_debug_name%,"Somehow, we cannot use the Command &4/whereami&c on whichever Server we are on.");
                            &return_string = %&enum_command%;
                        endif;
                        break;
                    endif;
                    
                    // 3. Check to see if we can send the Chat Command
                    do_command = canDoInteraction(%#waited_ticks%,%#wait_ticks%);
                    if(%do_command%);
                        echo("/whereami");
                        message_sent = true;
                    endif;
                    
                    inc(#waited_ticks);
                    wait("1t");
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning: '&d%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // info/index/getSkyblockAreaFromWTFMAP
        // Attempts to read the SkyBlock Area from the /wtfmap command + chatfilter.
            // Params:
            //      {number} [#timeout_sec=30]  Max amount of seconds to wait for Chat Filter to read the wtfmap output.
            //                                  Set to -1 to disable timeout.
            //      {number} [#wait_ticks=60]   Amount of ticks to wait between attempts to issue the command.
            //
            // Returns the String returned from the Command (i.e. "SkyBlock Dynamic"), or "-1" if cannot be found/timed out.
        function getSkyblockAreaFromWTFMAP(#timeout_sec=30,#wait_ticks=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:422
            debug              = true;
            &script_debug_name = "&3getSkyBlockAreaFromWTFMAP&7";
            
            @cannot_use_wtfmap = false;
            @&wtfmap           = "";
            #start_time        = %TIMESTAMP%;
            do_timeout         = #timeout_sec != -1;
            &return_string     = "-1";
            do;
                func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                if(%func_timeout%);
                    break;
                endif;
                    
                debug_log(%debug%,%&script_debug_name%,"echoing '/wtfmap'...");
                echo("/wtfmap");
                do(%#wait_ticks%);
                    wait("1t");
                    got_response   = ((%@&wtfmap% != "") || (%@cannot_use_wtfmap%));
                until(%got_response%);
                if((%got_response%) && (%@&wtfmap% != ""));
                    &return_string = %@&wtfmap%;
                    break;
                endif;
            until((%got_response%) || (%func_timeout%));
            return(%&return_string%);
        endfunction;
    // info/index/getScoreboardSkyBlockArea
        // Attempts to read the Scoreboard to find the Player's AREA on Hypixel SkyBlock (i.e. 'Private Island', 'Hub', 'Bank', etc).
            // Params:
            //      None
            //
            // Returns the string found on the Scoreboard following the Gem Character, or "-1" if not able to be parsed.
        function getScoreboardSkyBlockArea();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:456
            &return_string = -1;
            foreach("teams");
                &joint_team = strip("%TEAMPREFIX%%TEAMSUFFIX%");
                &joint_team = trim(%&joint_team%);
                &joint_team = regexreplace(&joint_team,"^\s*","");
                ifmatches(%&joint_team%,"\u23E3 (.+)",&found_area,1);
                    &return_string = %&found_area%;
                endif;
            next;
            return(%&return_string%);
        endfunction;
    // info/index/getSkyBlockArea
        // Gets the SkyBlock Server Type that we are currently connected to. Returns SKYBLOCK_HUB, SKYBLOCK_HOME, or OTHER. OTHER is only returned if
        // the Function cannot determine whether it is on a SkyBlock Server, or if it is not on a SkyBlock Server.
            // Params:
            //      None
            //
            // Returns one of the following strings: 'SKYBLOCK_HUB', 'SKYBLOCK_HOME', 'OTHER'. 'OTHER' is returned if none of the functions return any
            // parseable values.
        function getSkyBlockArea();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:577
            &playerlist_area = getSkyBlockPlayerListInfo("AREA");
            if(%&playerlist_area% == "-1");
                &scoreboard_area = getScoreboardSkyBlockArea();
                if(%&scoreboard_area% == "-1");
                    &wtfmap_area = getSkyBlockAreaFromWTFMAP();
                    if(%&wtfmap_area% == "SkyBlock Hub");
                        return("SKYBLOCK_HUB");
                    elseif(%&wtfmap_area% == "SkyBlock Dynamic");
                        return("SKYBLOCK_HOME");
                    endif;
                    return("OTHER");
                elseif(%&playerlist_area% == "Your Island");
                    return("SKYBLOCK_HOME");
                else;
                    return("SKYBLOCK_HUB");
                endif;
            elseif(%&playerlist_area% == "Private Island");
                return("SKYBLOCK_HOME");
            else;
                return("SKYBLOCK_HUB");
            endif;
        endfunction;
    // movement/index/gotoServer
        // Given a Server type to get to, gets to the Server type from wherever we are. Returns a boolean indicating
        // whether or not the action was successful.
            // Params:
            //      {string} [&target_server="SKYBLOCK_HOME"]   The target server to get to. Valid values are: 'SKYBLOCK',
            //                                                  'SKYBLOCK_HUB', 'SKYBLOCK_HOME. Defaults to 'SKYBLOCK_HOME'.
            //                                                  If set to 'SKYBLOCK', will accept any SkyBlock server.
            //      {number} [#command_wait_ticks=100]          Amount of ticks to wait between issuing each command needed.
            //      {number} [#timeout_sec=300]                 Amount of seconds to attempt this action before timing out and
            //                                                  returning false. Set to -1 to make the action try to go on indefinitely.
            //                                                  Defaults to 300 (5 minutes).
            //      {boolean} [force_cmd=false]                 If set to true, will force the function to send a command to try and
            //                                                  get to the correct server regardless of whether or not it is already on it
            //                                                  at time of function call.
            //
            // Returns a boolean indicating whether or not the Player is on the [&target_server] at the time of function exit.
        function gotoServer(&target_server="SKYBLOCK_HOME",#command_wait_ticks=100,#timeout_sec=300,force_cmd=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:339
            debug              = true;
            &script_debug_name = "&4gotoServer";
            
            &target_server = miscValidate(%&target_server%,0,"SKYBLOCK_HOME","SKYBLOCK_HUB","SKYBLOCK");
            do_timeout     = #timeout_sec > 0;
            #start_time    = %TIMESTAMP%;
            &encode_vars[] = split(", ","@&auto-restarts-case, @world_changed, BIOME, DIMENSION, XPOS, YPOS, ZPOS"); // Variables used to detect a world change event.
            first_loop     = false;
            #min_tick_wait = %#command_wait_ticks% / 2; // used to ensure we do not spam requests if we switch servers quickly
            
            do;
                if(%do_timeout%);
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                        break;
                    endif;
                endif;
                
                // Figure out what type of command we are going to need to issue.
                if(!%do_override%);
                    &hypixel_gamemode = getHypixelGamemode(); // 'LOBBY', 'LIMBO', 'SKYBLOCK', or 'OTHER'.
                    debug_log(%debug%,%&script_debug_name%,"force_cmd: %force_cmd%, target_server: %&target_server%, hypixel_gamemode: %&hypixel_gamemode%");
                    if(%&hypixel_gamemode% == "SKYBLOCK");
                        return_boolean = %&target_server% == "SKYBLOCK";
                        if((%return_boolean%) && ((!%force_cmd%) || (%first_loop%)));
                            debug_log(%debug%,%&script_debug_name%,"Got to target_server 'SKYBLOCK'.");
                            break;
                        endif;
                        
                        &skyblock_area = getSkyBlockArea(); // 'SKYBLOCK_HUB', 'SKYBLOCK_HOME', 'OTHER'
                        debug_log(%debug%,%&script_debug_name%,"force_cmd: %force_cmd%, target_server: %&target_server%, hypixel_gamemode: %&hypixel_gamemode%, skyblock_area: %&skyblock_area%");
                        return_boolean = %&target_server% == %&skyblock_area%;
                        if((%return_boolean%) && ((!%force_cmd%) || (%first_loop%)));
                            debug_log(%debug%,%&script_debug_name%,"Got to target_server '%&skyblock_area%'.");
                            break;
                        endif;
                        
                        if(%&skyblock_area% == "SKYBLOCK_HUB");
                            if((%force_cmd%) && (%&target_server% == "SKYBLOCK_HUB"));
                                &echo_command = "/warp hub";
                            else;
                                &echo_command = "/warp home";
                            endif;
                        elseif(%&skyblock_area% == "SKYBLOCK_HOME");
                            &echo_command = "/warp hub";
                        elseif(%&skyblock_area% == "OTHER");
                            &echo_command = "/lobby";
                        endif;
                    elseif(%&hypixel_gamemode% == "LIMBO");
                        &echo_command = "/lobby";
                    elseif(%&hypixel_gamemode% == "LOBBY");
                        &echo_command = "/play skyblock";
                    elseif(%&hypixel_gamemode% == "OTHER");
                        &echo_command = "/lobby";
                    endif;
                else;
                    // Issue the override "/lobby" command to break out of the "Cannot send chat message" loop.
                    &echo_command = "/lobby";
                    do_override   = false;
                endif;
                debug_log(%debug%,%&script_debug_name%,"echo_command: &d%&echo_command%");
                
                // Issue the command and wait for an update in our environment variables.
                if(true);
                    if((#waited_ticks > 0) && (#waited_ticks < #command_wait_ticks));
                        do;
                            wait("1t");
                            inc(#waited_ticks);
                        until(%#waited_ticks% >= %#command_wait_ticks%);
                    endif;
                
                    foreach(&encode_vars[],&encode_var,#evi);
                        ifmatches(%&encode_var%,"(?-i:[a-z])"); // Unset any global variables, i.e. '@world_changed'.
                            unset(%&encode_var%);
                        endif;
                        &initial_vals[%#evi%] = "%%&encode_var%%";
                    next;
                    
                    debug_log(%debug%,%&script_debug_name%,"running %&echo_command%");
                    echo(%&echo_command%);
                    env_updated   = false;
                    #waited_ticks = 0;
                    do(%#command_wait_ticks%);
                        wait("1t");
                        inc(#waited_ticks);
                        foreach(&encode_vars[],&encode_var,#evi);
                            &encode_val = "%%&encode_var%%";
                            if(%&initial_vals[%#evi%]% != %&encode_val%);
                                env_updated = true; // Break early as soon as we detect some sort of change in our environment.
                                break;
                            endif;
                        next;
                    until(%env_updated%);
                    
                    // Check to see if we hit the @&auto-restarts-case ("Cannot send chat message")
                    if(%@&auto-restarts-case% != "");
                        do_override = true;
                    endif;
                endif;
                
                first_loop = true;
            until((%func_timeout%) || ((%return_boolean%) && ((!%force_cmd%) || (%first_loop%))));
            
            return(%return_boolean%);
        endfunction;
    // misc/index/getNewTimeoutSec
        // Adjusts <#timeout_sec> to be <#timeout_sec> minus amount of seconds elapsed since <#start_time>.
            // Params:
                // {number} <#start_time>         Timestamp of fn start in caller script
                // {number} <#timeout_sec>        Timeout seconds passed to caller script
                // {boolean} [do_timeout=true]    Whether or not the timeout is active (if it is, the function will always
                //                                return a positive number. If it is not, it will allow <= 0 numbers).
            // Returns the new Timeout in Seconds
            // Example:
                //    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
        function getNewTimeoutSec(#start_time,#timeout_sec,do_timeout=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/index.txt:59
            #recursive_timeout = %#timeout_sec%;
            if(%do_timeout%);
                #recursive_timeout = %#timeout_sec% - (%TIMESTAMP% - %#start_time%);
                if(%#recursive_timeout% <= 0);
                    #recursive_timeout = 1;
                endif;
            endif;
            return(%#recursive_timeout%);
        endfunction;
    // movement/index/swapServers
        // Swaps the Server we are currently connected to by switching to the Hub if we are at Home, or Home if we are at Hub.
        // REQUIRES CHATFILTER LINES:
            // ifmatches(%CHATCLEAN%,"^You are currently connected to server (.+)$",@&current_server_id);
            // Params:
                // {number} [#timeout_sec=30]    Amount of Seconds Function can run for before timing out.
                // {number} [#wait_ticks=100]    Amount of Ticks to wait in between calling Commands.
                //
            // Returns a String ENUM:
                // SUCCESS          Successfully swapped Servers.
                // ERROR_TIMEOUT    Function timed out.
                // ERROR_SERVER     Could not get onto a SkyBlock Server.
        function swapServers(#wait_ticks=100,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:1049
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9swapServers&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &enum_success      = "SUCCESS";
                &enum_timeout      = "ERROR_TIMEOUT";
                &enum_server       = "ERROR_SERVER";
                &enum_unknown      = "ERROR_UNKNOWN";
            endif;
            
            // Loop getting the Initial Server ID and Type followed by switching to the opposing Server until we are on a Server with a different Server ID, or an Error is encountered.
            if(true);
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out. (err code &&enum_timeout: '&4%&enum_timeout%&7'.)");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Get Initial Server ID and Type
                    if(true);
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &init_server_id    = getServerID(%#wait_ticks%,%#recursive_timeout%);
                        ifmatches(%&init_server_id%,"^ERROR_");
                            debug_error(%debug%,%&script_debug_name%,"(INIT) Got an ERROR response from &9getServerID&7: '&4%&init_server_id%&7'.");
                            if((%&init_server_id% == %&enum_unknown%) || (%&init_server_id% == %&enum_server%) || (%&init_server_id% == %&enum_timeout%));
                                debug_error(%debug%,%&script_debug_name%,"Err code &&init_server_id: '&4%&init_server_id%&7'.");
                                &return_string = %&init_server_id%;
                            else;
                                debug_error(%debug%,%&script_debug_name%,"Err code &&enum_unknown: '&4%&enum_unknown%&7'.");
                                &return_string = %&enum_unknown%;
                            endif;
                            break;
                        endif;
                    
                        // Make sure we are on a SkyBlock Server to begin with.
                        if(true);
                            #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            on_skyblock        = gotoServer("SKYBLOCK",%#wait_ticks%,%#recursive_timeout%);
                            if(!%on_skyblock%);
                                debug_error(%debug%,%&script_debug_name%,"Could not get onto a valid SkyBlock Server! (err code &&enum_server: '&4%&enum_server%&7'.)");
                                &return_string = %&enum_server%;
                                break;
                            endif;
                        endif;
                        
                        &init_server_type = getSkyBlockArea();
                    endif;
                    
                    // 3. Swap Servers to the Opposite of our Current Server, then check if the Server ID is different.
                    if(true);
                        if(%&init_server_type% == "SKYBLOCK_HUB");
                            &goto_server_type = "SKYBLOCK_HOME";
                        elseif(%&init_server_type% == "SKYBLOCK_HOME");
                            &goto_server_type = "SKYBLOCK_HUB";
                        else;
                            debug_error(%debug%,%&script_debug_name%,"&9getSkyBlockArea&7 returned '&4%&init_server_type%&7'! (err code &&enum_server: '&4%&enum_server%&7'.)");
                            &return_string = %&enum_server%;
                            break;
                        endif;
                        
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        on_skyblock        = gotoServer(%&goto_server_type%,%#wait_ticks%,%#recursive_timeout%);
                        if(!%on_skyblock%);
                            debug_error(%debug%,%&script_debug_name%,"Could not get onto the &&goto_server_type: '&4%&goto_server_type%&c' Server Type! (err code &&enum_server: '&4%&enum_server%&7'.)");
                            &return_string = %&enum_server%;
                            break;
                        endif;
                        
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &post_server_id    = getServerID(%#wait_ticks%,%#recursive_timeout%);
                        ifmatches(%&post_server_id%,"^ERROR_");
                            debug_error(%debug%,%&script_debug_name%,"(POST) Got an ERROR response from &9getServerID&7: '&4%&post_server_id%&7'.");
                            if((%&post_server_id% == %&enum_unknown%) || (%&post_server_id% == %&enum_server%) || (%&post_server_id% == %&enum_timeout%));
                                &return_string = %&post_server_id%;
                            else;
                                &return_string = %&enum_unknown%;
                            endif;
                            break;
                        endif;
                        
                        if(%&post_server_id% != %&init_server_id%);
                            debug_log(%debug%,%&script_debug_name%,"Updated Server ID from (init) &8%&init_server_id%&7 to (post) &e%&post_server_id%&7.");
                            &return_string = %&enum_success%;
                            break;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Init Server ID (init: '&8%&init_server_id%&7') is the same as Post Server ID (post: '&e%&post_server_id%&7'). Trying again...");
                        endif;
                    endif;
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning &&return_string: '&d%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // array/index/arrayDelete
        // Removes the Element at <#index> from <&array[]> (different from calling unset, completely clears the entry from the Array).
            // Params:
            //        {array} <&array[]>    The Array to unset the specified index from.
            //        {number} <#index>     The Index to unset in the Source Array. If negative, will be taken
            //                              as an offset from the end of the Array (i.e. -1 = array.length - 1).
            //                              If the Index is greater than the length of the Source Array, no element
            //                              will be removed.
        function arrayDelete(&array[],#index);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:295
            #array_size = arraysize(&array[]);
            #array_len  = #array_size - 1;
            if(%#array_size% == 0);
                return(&array[]);
            else;
                if(%#index% < 0);
                    #index = #array_len + #index;
                endif;
                
                if((%#index% >= 0) && (%#index% <= %#array_len%));
                    foreach(&array[],&element,#i);
                        if(%#i% != %#index%);
                            &out_array[] = %&element%;
                        endif;
                    next;
                endif;
            endif;
            return(&out_array[]);
        endfunction;
    // string/index/xJsonGet
        // Identical to original `jsonget`, but passes the result of the function along to `convertENote` to ensure decimal values are conserved.
            // Params:
                // {string} <&string_a>    The Key to get in the JSON Object, or the JSON Object itself.
                // {string} <&string_b> The Key to get in the JSON Object, or the JSON Object itself. Must be the other value compared to <&string_a>
            // Returns the value provided by `jsonget`, processed thru `convertENote`. Identical results, only difference is preservation of silently coerced Numbers.
        function xJsonGet(&string_a,&string_b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:265
            &return_string = jsonget(%&string_a%,%&string_b%);
            &return_string = convertENote(%&return_string%);
            return(%&return_string%);
        endfunction;
    // array/index/arrayLength
        // Returns the zero-indexed length of an Array.
            // Params:
            //        <array> <&array[]>    The Array to measure the length of.
            //
            // Returns the zero-indexed length of the Array (arraysize - 1).
        function arrayLength(&array[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:6
            #array_size   = arraysize(&array[]);
            #array_length = #array_size - 1;
            return(%#array_length%);
        endfunction;
    // api/minecraft/getMinecraftProfileCacheIndex
        // Checks if a Minecraft Profile is available in the Cached Arrays (@&cached_mc_ [split_ids, joint_ids, usernames, change_ts]).
        // If it is, and the Cache is not invalid, the index the entry can be found at is returned. Otherwise, -1 is returned.
                // Params:
                //        <string>  &search_term   : The term to search for. Can be the username, dashed UUID, or joint UUID.
                //      [boolean] check_validity : True to return the index only if it is valid, false to return the index regardless of it's validity.
                //
                // Returns the index the Profile can be found at in the Cache.
        function getMinecraftProfileCacheIndex(&search_term,check_validity=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/minecraft.txt:8
            &script_debug_name = "&9getMinecraftProfileCacheIndex&7";
            debug              = true;
        
            // Check if the search term can be found in any of the caches.
            if(true);
                #lookup_index  = -1;
                #cache_index[] = indexof(@&cached_mc_split_uuids[],,%&search_term%);
                #cache_index[] = indexof(@&cached_mc_joint_uuids[],,%&search_term%);
                #cache_index[] = indexof(@&cached_mc_usernames[],,%&search_term%);
                foreach(#cache_index[],#cache_index);
                    if(%#cache_index% != -1);
                        #lookup_index = %#cache_index%;
                        break;
                    endif;
                next;
        
                // If we hit a valid cache entry, check if it is valid.
                if(%#lookup_index% != -1);
                    #valid_before = %@#cached_mc_valid_until[%#lookup_index%]%;
                    if((!%check_validity%) || (%#valid_before% >= %TIMESTAMP%));
                        // Player can't change name yet, the cache is valid.
                        return(%#lookup_index%);
                    endif;
                endif;
            endif;
        
            return(-1);
        endfunction;
    // api/minecraft/getMinecraftProfile
        // Gets a User's Minecraft Profile from playerdb.co.
            // Params:
                // {string} &search_term : The term to search for. Can be the username, dashed UUID, or joint UUID.
                //
            // Returns an Array:
                // 0 {boolean} success     : Whether or not the request was successful
                // 1 {string}  &username   : The player's username
                // 2 {string}  &joint_uuid : The player's joint UUID
                // 3 {string}  &split_uuid : The player's split UUID
            // Example:
                //    &minecraft_profile[]   = getMinecraftProfile(%&search_term%);
                //    minecraft_profile     := %&minecraft_profile[0]%;
                //    &minecraft_username    = %&minecraft_profile[1]%;
                //    &minecraft_joint_uuid  = %&minecraft_profile[2]%;
                //    &minecraft_split_uuid  = %&minecraft_profile[3]%;
        function getMinecraftProfile(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/minecraft.txt:53
            &script_debug_name = "&9getMinecraftProfile&7";
            debug              = false;
        
            // If we are checking the current player, we can skip requests altogether.
            &player_split_uuid = %UUID%;
            &player_joint_uuid = regexreplace(&player_split_uuid,"-","");
            &player_identity[] = split(", ","%&player_split_uuid%, %&player_joint_uuid%, %PLAYER%");
            #player_index      = indexof(&player_identity[],,%&search_term%);
            if(%#player_index% != -1);
                &player_username   = %PLAYER%;
                &player_joint_uuid = %&player_joint_uuid%;
                &player_split_uuid = %UUID%;
                success            = true;
            else;
                // Not checking current player, do API calls.
                #cache_index  = getMinecraftProfileCacheIndex(%&search_term%,false);
                #valid_before = %@#cached_mc_valid_until[%#cache_index%]%;
                if((%#valid_before% >= %TIMESTAMP%) && (%#cache_index% != -1));
                    // Entry is cached, we can skip the request.
                    &player_username   = %@&cached_mc_usernames[%#cache_index%]%;
                    &player_joint_uuid = %@&cached_mc_joint_uuids[%#cache_index%]%;
                    &player_split_uuid = %@&cached_mc_split_uuids[%#cache_index%]%;
                    success            = true;
                else;
                    // Search term is not cached, try the API.
                    if(true);
                        setrequestheader("accept","application/json");
                        setrequestheader("user-agent","MC_API")
                        &api_url  = "https://playerdb.co/api/player/minecraft/%&search_term%";
                        &api_resp = httpget(%&api_url%,,#api_code);
                        &api_code = jsonget("code",%&api_resp%);
                        if(%&api_code% == "player.found");
                            &player_username   = jsonget("data.player.username",%&api_resp%);
                            &player_joint_uuid = jsonget("data.player.raw_id",%&api_resp%);
                            &player_split_uuid = jsonget("data.player.id",%&api_resp%);
                            success            = true;
                        elseif(%debug%);
                            &vars[] = split(" ","&api_url &api_resp &api_code #api_code");
                            foreach(&vars[],&var,#v);
                                &var_ = regexreplace(&var,"&","&&");
                                &val  = "%%&var%%";
                            next;
                        endif;
                    endif;
        
                    // Update the cache entry.
                    if(true);
                        if(%success%);
                            // Search term (could be UUID or Username) was valid and found on a Player.
                            // Update or initialize the Cache entry for the UUID.
                            &player_name_hist      = jsonget("data.player.meta.name_history",%&api_resp%);
                            &player_name_changes[] = getjsonasarray(%&player_name_hist%);
                            #player_name_changes   = arraylength(&player_name_changes[]);
                            if(%#player_name_changes% == 1);
                                &latest_change_time = 0;
                            else;
                                &latest_change_time = xJsonGet("changedToAt",%&player_name_changes[%#player_name_changes%]%);
                                &latest_change_time = match(%&latest_change_time%,"(^.{10})",1);
                            endif;
        
                            // A player can change their name every 30 days since their most recent name change.
                            // Set the 'cache invalidation' timestamp for this entry to be the latest change time + ms in 30 days.
                            #latest_change_time := %&latest_change_time%;
                            #can_change_name_at  = %#latest_change_time% + (60 * 60 * 24 * 30);
                            
                            #uuid_index = indexof(@&cached_mc_split_uuids[],,%&player_split_uuid%);
                            if(%#uuid_index% == -1);
                                @&cached_mc_split_uuids[] = %&player_split_uuid%;
                                @&cached_mc_joint_uuids[] = %&player_joint_uuid%;
                                @&cached_mc_usernames[]   = %&player_username%;
                                @#cached_mc_valid_until[] = %#can_change_name_at%;
                            else;
                                @&cached_mc_usernames[%#uuid_index%]   = %&player_username%;
                                @#cached_mc_valid_until[%#uuid_index%] = %#can_change_name_at%;
                            endif;
                        elseif(%#cache_index% != -1);
                            // Search term (has to be Username) was a previously valid Username on another User, but they have since
                            // changed their Username. We can be certain of this because the Cache was hit successfully, but the request
                            // did not pull up any valid Account.
                            //
                            // Clear the invalid entry from the Cache.
                            //
                            
                            @&cached_mc_split_uuids[] = arrayDelete(@&cached_mc_split_uuids[],%#cache_index%);
                            @&cached_mc_joint_uuids[] = arrayDelete(@&cached_mc_joint_uuids[],%#cache_index%);
                            @&cached_mc_usernames[]   = arrayDelete(@&cached_mc_usernames[],%#cache_index%);
                            @#cached_mc_valid_until[] = arrayDelete(@#cached_mc_valid_until[],%#cache_index%);
                        endif;
                    endif;
                endif;
            endif;
            return(%success%,%&player_username%,%&player_joint_uuid%,%&player_split_uuid%);
        endfunction;
    // string/index/xFormatNumber
        // Identical to original `formatnumber`, but passes the input_string through `convertENote` before passing it into `formatnumber`.
            // Params:
                // {string} <&input_string>          The Number or String to Format into a Number. If this Number includes Commas, they will be stripped
                //                                   from the string passed to `formatnumber`.
                // {string} [&decimal_precision]     The desired level of precision following the decimal. If omitted or an empty string, will
                //                                   include the amount of decimals included in the <&input_string>. If provided, should be an integer >= 0.
                //                                   If set to 0, will not include a decimal character or trail at all. Providing a value that is incoherent
                //                                   to the level of decimal precision present in the <&input_string> will result in the output being rounded
                //                                   to the desired level of precision.
                // {boolean} [strip_commas=false]    Whether or not to strip commas when formatting the Number. If set to True, and [&decimal_precision]
                //                                   is set to "0", this Function will return a valid Integer.
            // Returns the result of the `formatnumber` expression.
            // Examples:
                // Converting a formatted string Number to a valid Integer:
                    //    &input_string      = "1009.0131";
                    //    &decimal_precision = "0";
                    //    strip_commas       = true;
                    //    #output_integer    = xFormatNumber(%&input_string%,%&decimal_precision%,%strip_commas%);
                // Converting a valid Integer to a formatted (comma split) string:
                    //    &input_string      = "10000";
                    //    &decimal_precision = "";
                    //    strip_commas       = false;
                    //    &output_string     = xFormatNumber(%&input_string%,%&decimal_precision%,%strip_commas%);
        function xFormatNumber(&input_string,&decimal_precision,strip_commas=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:315
            &return_string = replace(&input_string,",");
            &return_string = convertENote(%&return_string%);
            &return_string = formatnumber(%&return_string%,%&decimal_precision%,%strip_commas%);
            return(%&return_string%);
        endfunction;
    // string/index/convertToMetric
        // Takes an input of a Number String and formats it into a Metric String (K, M, B, or T as suffix).
            // Params:
                // {string} <&convert_string>         The Number String to convert.
                // {number} [#decimal_precision=1]    Amount of sig. figs to round the conversion off to. If set to <= -1, will just
                //                                    format the number as-is (it will keep as many decimal places as it had in the first place).
            // Returns a String.
            // Example:
                //    &metric_string = convertToMetric("151091.501",1);
                //    log(%&metric_string%); // 151.1 K
        function convertToMetric(&convert_string,#decimal_precision=1);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:566
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9convertToMetric&7";
                debug_log(%debug%,%&script_debug_name%,"called, args are &&convert_string='&e%&convert_string%&7', #decimal_precision=&e%#decimal_precision%");
            endif;
            &metric_chars[] = split(", ","K, M, B, T");
            &metric_ratio[] = split(", ","1000, 1000000, 1000000000, 1000000000000");
            &return_string  = %&convert_string%;
            ifmatches(%&convert_string%,"^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)",&integer_portion,2);
                log("&7matched expression '&d^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)&7' against string ")
                #component_a_len = strlen(%&integer_portion%);
                debug_log(%debug%,%&script_debug_name%,"matched expression '&d^(-|\+)?0*([1-9]\d*)(?:\.\d+$|$)&7' against &&convert_string='&e%&convert_string%&7', extracted &&integer_portion='&e%&integer_portion%&7' with length=&e%#component_a_len%&7.");
                #metric_index    = -1;
                foreach(&metric_ratio[],&metric_ratio,#mr);
                    #metric_ratio_len = strlen(%&metric_ratio%);
                    if(%#component_a_len% >= %#metric_ratio_len%);
                        debug_log(%debug%,%&script_debug_name%,"metric_ratio_len=&e%#metric_ratio_len%&7 >= #component_a_len=&e%#component_a_len%&7, setting metric_index=&e%#mr%");
                        #metric_index = %#mr%;
                    endif;
                next;
                
                if(%#metric_index% >= 0);
                    &metric_char   = %&metric_chars[%#metric_index%]%;
                    &metric_ratio  = %&metric_ratio[%#metric_index%]%;
                    &return_string = xEval("%&convert_string% / %&metric_ratio%");
                    if(%#decimal_precision% <= -1);
                        &return_string = xFormatNumber(%&return_string%);
                    else;
                        &return_string = xFormatNumber(%&return_string%,%#decimal_precision%);
                    endif;
                    &return_string = "%&return_string% %&metric_char%";
                endif;
            endif;
            return(%&return_string%);
        endfunction;
    // string/index/convertMetricString
        // Takes an input of a string with metric numbers in it (e.g. '10K, '10.5M', etc) and parses out the metric character
        // then converts the input into a number and returns it. Supports K, M, B, T suffixes.
            // Params:
                // {string} <&metric_string>               The String to Parse
                // {number} [#decimal_precision=-1]        Amount of sig. figs to round the conversion off to. If set to <= -1, will just
                //                                         format the number as-is (it will keep as many decimal places as it had in the first place).
                // {boolean} [format_with_commas=false]    Whether or not to format the conversion with commas every 3 characters.
            // Returns an Empty String if no conversion were able to be done, or a (possibly formatted) Number otherwise.
            // Example:
                //    #converted_units = convertMetricString("10K",2,true);
                //    log(%#converted_units%); // 10,000.00
        function convertMetricString(&metric_string,#decimal_precision=-1,format_with_commas=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:529
            &base_expression = "([\d,.-]+)(?:.*?\b|\B)";
            &metric_chars[]  = split(", ","K, M, B, T");
            &metric_ratio[]  = split(", ","1000, 1000000, 1000000000, 1000000000000");
            &return_string   = "0";
            match_found      = false;
            foreach(&metric_chars[],&metric_char,#mc);
                &metric_expr = "%&base_expression%%&metric_char%";
                ifmatches(%&metric_string%,%&metric_expr%,&amount_units,1);
                    match_found    = true
                    &amount_units  = replace(&amount_units,",");
                    &return_string = xEval("%&return_string% + (%&amount_units% * %&metric_ratio[%#mc%]%)");
                endif;
            next;
            
            if(%match_found%);
                strip_commas = !%format_with_commas%;
                if(%#decimal_precision% <= -1);
                    &return_string = xFormatNumber(%&return_string%,"",%strip_commas%);
                else;
                    &return_string = xFormatNumber(%&return_string%,%#decimal_precision%,%strip_commas%);
                endif;
                return(%&return_string%);
            else;
                return("");
            endif;
        endfunction;
    // string/index/isMetricString
        // Checks if a String is a Metric String
            // Params:
                // {string} <&metric_string>    The String to check for a Metric Suffix (and/or Metric Suffixes)
                //
            // Returns a Boolean indicating whether or not the String is a Metric String
            // Example:
                //    is_metric = isMetricString(%&metric_string%);
        function isMetricString(&metric_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:510
            &base_expression = "([\d,.-]+)(?:.*?\b|\B)(K|M|B|T)";
            ifmatches(%&metric_string%,%&base_expression%);
                return_boolean = true;
            endif;
            return(%return_boolean%);
        endfunction;
    // array/index/miscComparator
        // Evaluates whether <&left> is <&operator> to <&right> (executes a variable comparison). Returns a boolean.
            // Params:
            //        {string} <&left>        The Left Hand side of the Comparison.
            //        {string} <&operator>    The Operator to apply the Condition against each Element with. Has to be one of:
            //                                '==', '!=', '>', '<', '>=', '<=', 'eq', 'ne', 'gte', 'lte', 'gt', or 'lt'. If a
            //                                number comparison operator is used, the values in the Array will be coerced to a
            //                                number so long as the condition is an integer. If the condition is a float value,
            //                                they will be evaluated using float math (eval).
            //        {string} <&right>       The Right Hand side of the Comparison
            //
            // Returns a boolean indicating the outcome of the evaluation.
        function miscComparator(&left,&operator,&right);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/array/index.txt:88
            &sign_operators[] = split(", ","==, !=, >=, <=, >, <");
            #sign_op_index    = indexof(&sign_operators[],,%&operator%);
            if(%#sign_op_index% == -1);
                &char_operators[] =    split(", ","eq, ne, gte, lte, gt, lt");
                #char_op_index    = indexof(&char_operators[],,%&operator%);
                if(%#char_op_index% == -1);
                    return(&return_array[]);
                endif;
                
                &operator = %&sign_operators[%#char_op_index%]%;
            endif;
        
            if(%&operator% == "==");
                if(%&left% == %&right%);
                    return_boolean = true;
                endif;
            elseif(&operator% == "!=");
                if(%&left% != %&right%);
                    return_boolean = true;
                endif;
            else;
                ifmatches(%&right%,"^(\d+)$",#right,1);
                    // Doing Integer Evaluation
                    #left := %&left%;
                    if((%&operator% == ">=") && (%#left% >= %#right%));
                        return_boolean = true;
                    elseif((%&operator% == ">") && (%#left% > %#right%));
                        return_boolean = true;
                    elseif((%&operator% == "<=") && (%#left% <= %#right%));
                        return_boolean = true;
                    elseif((%&operator% == "<") && (%#left% < %#right%));
                        return_boolean = true;
                    endif;
                elseifmatches(%&right%,"^[0-9.-]+");
                    // Doing Float Evaluation
                    &float_diff = eval("%&left% - %&right%");
                    ifmatches(%&float_diff%,"^-");
                        // <left> - <right> = negative number, left was less than right
                        if((%&operator% == "<=") || (%&operator% == "<"));
                            return_boolean = true;
                        endif;
                    else;
                        // <left> - <right> = positive or 0, left was greater than or equal to right
                        ifmatches(%&float_diff%,"[0.]+");
                            // <left> - <right> = 0, left was equal to right
                            if((%&operator% == ">=") || (%&operator% == "<="));
                                return_boolean = true;
                            endif;
                        elseif((%&operator% == ">=") || (%&operator% == ">"));
                            // <left> - <right> = greater than 0, left was greater than right
                            return_boolean = true;
                        endif;
                    endif;
                endif;
            endif;
            return(%return_boolean%);
        endfunction;
    // math/index/number
        // Normalizes any type of input Number into the Type.
            // Params:
                // {string} <&number>             The Number to Format. Can be integer, decimal, negative, positive, metric, e-notation, whatever.
                // {string} [...&formatting[]]    The Formatting Options to apply. Settings are provided in '<KEY>: <VALUE>' notation. Valid Options:
                                                //    ['F'|'T'|'S'|'TYPE'|'STYLE'|'FORMAT']:
                                                //        - ['I'|'N'|'INT'|'INTEGER'|'NUM'|'NUMBER']           : Formats the output as an Integer.
                                                //        - ['D'|'F'|'L'|'DECIMAL'|'FLOAT'|'LONG'|'DOUBLE']    : Formats the output as a Decimal Number.
                                                //        - ['E'|'ENOTE'|'EXP'|'EXPONENT']                     : Formats the output in Exponentional Notation.
                                                //        - ['M'|'METRIC']                                     : Formats the output as a Metric Suffixed Number.
                                                //    ['P'|'PLACE'|'PLACES'|'PRECISION'] (Only available if Type is Decimal or Metric or equivalent):
                                                //        - ['S'|'SIG'|'SIGFIG'|'SIGNIFICANT']    : Applies the default amount of Decimal Places (the Sig. Figs in the converted value).
                                                //        - <NUMBER >= 0>                         : Applies <NUMBER> amount of Decimal Places (setting this to 0 is the same as using F: INT, R: ROUND).
                                                //    ['R'|'ROUND'|'ROUNDING'] (Only available if Precision is not 'SIG' or equivalent):
                                                //        - ['R'|'ROUND'|'D'|'DEFAULT'|'STD'|'STANDARD'|'NEAR'|'NEAREST'|'INT'|'NUM'|'INTEGER'|'NUMBER']    : Round using 'ROUND' (towards nearest integer).
                                                //        - ['F'|'FLOOR'|'DOWN'|'D'|'<'|'LESSER'|'LT']                                                      : Round using 'FLOOR' (towards negative infinity).
                                                //        - ['C'|'CEIL'|'CEILING'|'UP'|'>'|'GREATER'|'GT']                                                  : Round using 'CEIL' (towards positive infinity).
                                                //        - ['T'|'TRUNCATE'|'TRUNC']                                                                        : Rounds up or down towards 0
                                                //        - ['N'|'NONE']                                                                                    : Does not round the output.
                                                //    ['C'|'COMMA'|'COMMAS'|'DELIMIT'|'DELIMITER'|'SPACE'|'SPACER']:
                                                //        - <BOOLEAN>          : Enables (or disables) formatting the output with Commas every 3 sig. figs (e.g. 100000 -> 100,000)
                                                //        - <STRING>           : Enables formatting the output with <STRING> as the delimiter every 3 sig. figs
                                                //        - ['N'|'NONE'|'']    : Disables formatting the output with delimiters.
                                                //    The Default Values for each Setting are as follows:
                                                //        FORMAT       : FLOAT
                                                //        PRECISION    : SIGNIFICANT
                                                //        ROUNDING     : NONE
                                                //        DELIMITER    : FALSE
            // Returns the Number specified formatted according to the Rules specified in [...&formatting[]].
            // Example:
                //    &number = number("100,000,000.192");
                //    log("number: %&number%"); // 'number: 100000000.192' (default formatting rules were applied)
        function number(&number="0",...&formatting[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:198
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6mathNumber&7";
                exponent_ready     = false;
                
                // Parse Formatting Options
                if(true);
                    // Wrap Formatting Keys, Valid Values and Default Values
                    if(true);
                        if(true); // Wrap '&opt_format' Formatting Option
                            &valid_formatting_vars[]        = "&opt_format";
                            &valid_formatting_keys[]        = "F|T|S|TYPE|STYLE|FORMAT";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            if(%exponent_ready%);
                                &valid_formatting_vals[] = "INTEGER|I|N|INT|NUM|NUMBER~FLOAT|D|F|L|DECIMAL|LONG|DOUBLE~EXPONENT|E|ENOTE|EXP~METRIC|M";
                                &valid_formatting_expr[] = "INTEGER|r$^[\d]+$~FLOAT|r$^[\d]*\.\d+$~EXPONENT|r$(?:e|\^)";
                            else;
                                &valid_formatting_vals[] = "INTEGER|I|N|INT|NUM|NUMBER~FLOAT|D|F|L|DECIMAL|LONG|DOUBLE~METRIC|M";
                                &valid_formatting_expr[] = "INTEGER|r$^[\d]+$~FLOAT|r$^[\d]*\.\d+$";
                            endif;
                            &opt_format = "FLOAT";
                        endif;
                        
                        if(true); // Wrap '&opt_precision' Formatting Option
                            &valid_formatting_vars[]        = "&opt_precision";
                            &valid_formatting_keys[]        = "P|PLACE|PLACES|PRECISION";
                            &valid_formatting_vals[]        = "SIGNIFICANT|SIGFIG|SIG|S";
                            &valid_formatting_expr[]        = "CUSTOM|r$^\d+$";
                            &valid_formatting_validation[]  = ">= 0";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_precision                  = "SIGNIFICANT";
                        endif;
                        
                        if(true); // Wrap '&opt_rounding' Formatting Option
                            &valid_formatting_vars[]        = "&opt_rounding";
                            &valid_formatting_keys[]        = "ROUNDING|ROUND|R";
                            &valid_formatting_vals[]        = "ROUND|INT|NUM|NUMBER|NEAREST|NEAR|STD|STANDARD|DEFAULT|D|INTEGER|R~FLOOR|F|DOWN|D|<|LESSER|LT~CEIL|CEILING|C|UP|>|GREATER|GT~NONE|N~TRUNCATE|TRUNC|T";
                            &valid_formatting_expr[]        = "";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_rounding                   = "NONE";
                        endif;
                        
                        if(true); // Wrap '&opt_delimiter' Formatting Option
                            &valid_formatting_vars[]        = "&opt_delimiter";
                            &valid_formatting_keys[]        = "DELIMITER|C|COMMA|COMMAS|DELIMIT|SPACE|SPACER|SPACES|SPACERS|DELIMITERS";
                            &valid_formatting_vals[]        = "TRUE|1~FALSE|0~NONE|N"
                            &valid_formatting_expr[]        = "CUSTOM|r$^.+$";
                            &valid_formatting_validation[]  = "";
                            valid_formatting_custom_input[] = false;
                            valid_formatting_def_override[] = false;
                            &opt_delimiter                  = "false";
                        endif;
                    endif;
                    
                    // Parse Options
                    if(true);
                        #formatting_sz = arraysize(&formatting[]);
                        if(%#formatting_sz% >= 1);
                            foreach(&formatting[],&formatting,#f);
                                ifmatches(%&formatting%,"^(.*?):\s*?(.*)$");
                                    match(%&formatting%,"^(.*?):\s*?(.*)$",{&custom_key,&custom_val});
                                    &check_key_index_for = ucase(%&custom_key%);
                                    &check_val_index_for = ucase(%&custom_val%);
                                    foreach(&valid_formatting_keys[],&valid_formatting_keys_str,#vfk);
                                        if(!%valid_formatting_def_override[%#vfk%]%);
                                            &valid_formatting_keys_arr[] = split("|",%&valid_formatting_keys_str%);
                                            #check_key_index_for         = indexof(&valid_formatting_keys_arr[],,%&check_key_index_for%);
                                            debug_log(%debug%,%&script_debug_name%,"checking key for '&d%&check_key_index_for%&7' index is '&e%#check_key_index_for%&7'.");
                                            if(%#check_key_index_for% != -1);
                                                &valid_formatting_val_types_arrs[] = split("~",%&valid_formatting_vals[%#vfk%]%);
                                                foreach(&valid_formatting_val_types_arrs[],&valid_formatting_val_type_str,#vfvt);
                                                    &valid_formatting_val_types_arr[] = split("|",%&valid_formatting_val_type_str%);
                                                    #check_val_index_for              = indexof(&valid_formatting_val_types_arr[],,%&check_val_index_for%);
                                                    debug_log(%debug%,%&script_debug_name%,"checking val index for '&d%&check_val_index_for%&7' index is '&e%#check_val_index_for%&7'.");
                                                    if(%#check_val_index_for% != -1);
                                                        &set_var = %&valid_formatting_vars[%#vfk%]%;
                                                        &set_val = %&valid_formatting_val_types_arr[0]%;
                                                        debug_log(%debug%,%&script_debug_name%,"setting value of &%&set_var%='&e%&set_val%&7'");
                                                        set(%&set_var%,%&set_val%);
                                                        set(valid_formatting_def_override[%#vfk%],true);
                                                        break;
                                                    endif;
                                                next;
                                                
                                                // If we found a match for the Key, but not for the Value, check to see if this Option allows Custom Input.
                                                // If it does, check if the provided Value passes the Regular Expression Validation, and then if this Option
                                                // also has a further Validation Check, ensure it passes that further Validation Check as well.
                                                if((!%valid_formatting_def_override[%#vfk%]%) && (%&valid_formatting_expr[%#vfk%]% != ""));
                                                    &input_validation_expr_groups[]      = split("~",%&valid_formatting_expr[%#vfk%]%);
                                                    &input_validation_expr_validations[] = split("~",%&valid_formatting_validation[%#vfk%]%);
                                                    input_passes_validation              = false;
                                                    foreach(&input_validation_tests[],&input_validation_test_string,#ivt);
                                                        ifmatches(%&input_validation_test_string%,"^(.+?)\|r\$(.+)$");
                                                            match(%&input_validation_test_string%,"^(.+?)\|r\$(.+)$",{&matched_value,&matched_expr});
                                                            ifmatches(%&custom_val%,%&matched_expr%);
                                                                input_passes_validation = true;
                                                                if(%&input_validation_expr_validations[%#ivt%]% != "");
                                                                    &validation_params[]    = split(" ",%&input_validation_expr_validations[%#ivt%]%);
                                                                    &validation_op          = %&validation_params[0]%;
                                                                    &validation_rhs         = %&validation_params[1]%;
                                                                    input_passes_validation = miscComparator(%&custom_val%,%&validation_op%,%&validation_rhs%);
                                                                endif;
                                                                
                                                                if(%input_passes_validation%);
                                                                    &set_var = %&valid_formatting_vars[%#vfk%]%;
                                                                    &set_val = ucase(%&matched_value%);
                                                                    if(%&set_val% == "CUSTOM");
                                                                        &set_val = %&custom_val%;
                                                                        set(valid_formatting_custom_input[%#vfk%],true);
                                                                    endif;
                                                                    set(%&set_var%,%&set_val%);
                                                                    set(valid_formatting_def_override[%#vfk%],true);
                                                                    debug_log(%debug%,%&script_debug_name%,"set value of &%&set_var%='&e%&set_val%&7'");
                                                                    break;
                                                                endif;
                                                            endif;
                                                        endif;
                                                    next;
                                                endif;
                                                
                                                if(%valid_formatting_def_override[%#vfk%]%);
                                                    break;
                                                endif;
                                            endif;
                                        endif;
                                    next;
                                endif;
                                
                                #non_overriden_index = indexof(valid_formatting_def_override[],,false);
                                if(%#non_overriden_index% == -1);
                                    break;
                                endif;
                            next;
                        endif;
                    endif;
                endif;
            endif;
            
            // Parse the Number into Standardized Format.
            if(true);
                ifnotmatches(%&number%,"\d");
                    &number = "0";
                endif;
                
                &read_number = replace(&number,",");
                ifmatches(%&convert_string%,"^(-)?(\d+)\.(\d+)(?:E|e)(-|\+)?(\d+)$");
                    &read_number = convertENote(%&number%);
                else;
                    &read_number = %&number%;
                endif;
                debug_log(%debug%,%&script_debug_name%,"Conversion of &&number (&5'%&number%&7') from Exp. Notation to Decimal returned &&read_number ('&d%&read_number%&7').");
                
                is_metric = isMetricString(%&read_number%);
                if(%is_metric%);
                    &before_metric = %&read_number%;
                    &read_number   = convertMetricString(%&read_number%,"-1");
                    ifmatches(%&read_number%,"^([\d.-]+)\.0*$",&first_portion,1);
                        debug_log(%debug%,%&script_debug_name%,"Conversion of &&read_number ('&5%&before_metric%&7') from Metric returned insignificant digits, cutting off (setting &&read_number to: '&e%&first_portion%&7' from '&d%&read_number%&7').");
                        &read_number = %&first_portion%;
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"Conversion of &&read_number ('&5%&before_metric%&7') from Metric returned '&d%&read_number%&7'.");
                elseif(%debug%);
                    debug_log(%debug%,%&script_debug_name%,"&&read_number ('&5%&read_number%&7') was not classified as being a Metric String.");
                endif;
                
                if(%debug%);
                    debug_log(%debug%,%&script_debug_name%,"Formatting Input Number '&d%&number%&7' (standardized: '&d%&read_number%&7')...");
                    &vars[] = split(" ","&number &read_number &opt_format &opt_precision &opt_rounding &opt_delimiter");
                    foreach(&vars[],&var,#v);
                        &val    = "%%&var%%";
                        &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                        &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                        debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
                    next;
                endif;
                
                // Apply the specified Rounding Option as defined in '&opt_rounding'
                if(true);
                    &before_round = %&read_number%;
                    if(%&opt_rounding% == "TRUNCATE");
                        debug_log(%debug%,%&script_debug_name%,"Truncating &&read_number ('&5%&before_round%&7') by cutting off all decimals.");
                        ifmatches(%&read_number%,"^([\d-]+)\.",&truncated_number,1);
                            &read_number = %&truncated_number%;
                            debug_log(%debug%,%&script_debug_name%,"Truncated &&read_number ('&5%&before_round%&7') to: '&d%&read_number%&7'.");
                        else;
                            debug_log(%debug%,%&script_debug_name%,"No decimal points to truncate in &&read_number ('&5%&before_round%&7').");
                        endif;
                    elseif(%&opt_rounding% != "NONE");
                        &read_number = xEval("%&opt_rounding%(%&read_number%)");
                        debug_log(%debug%,%&script_debug_name%,"Rounding &&read_number ('&5%&before_round%&7') with Method: '&e%&opt_rounding%&7' returned: &d'%&read_number%&7'.");
                    else;
                        debug_log(%debug%,%&script_debug_name%,"Not rounding &&read_number ('&5%&before_round%&7') at all, Rounding Method (&&opt_rounding: '&e%&opt_rounding%&7') is set to 'NONE'.");
                    endif;
                endif;
                
                // Apply the specified Formatting Option as defined in '&opt_format'
                if(true);
                    &before_formatting = %&read_number%;
                    
                    // Figure out the Formatting Rules to pass to xFormatNumber
                    if(true);
                        // Figure out the Decimal Places to include in the Result (if any)
                        if(true);
                            &format_precision = "0";
                            if(%&opt_format% != "INTEGER");
                                &format_precision = "";
                                #precision_index  = indexof(&valid_formatting_vars[],,"&opt_precision");
                                custom_precision  = %valid_formatting_custom_input[%#precision_index%]%;
                                if(%custom_precision%);
                                    &format_precision = %&opt_precision%;
                                endif;
                            endif;
                        endif;
                        
                        // Figure out the Delimiter to Use in the Result (if any)
                        if(true);
                            if((%&opt_format% != "EXPONENT") && (&opt_format% != "METRIC"));
                                opt_delimiter    := %&opt_delimiter%;
                                #delimiter_index  = indexof(&valid_formatting_vars[],,"&opt_delimiter");
                                custom_delimiter  = %valid_formatting_custom_input[%#delimiter_index%]%;
                                use_delimiter     = ((%custom_delimiter%) || (%opt_delimiter%));
                            endif;
                            exclude_commas = !%use_delimiter%;
                        endif;
                        
                        // Format the Number using xFormatNumber
                        if(true);
                            &before_xformat      = %&read_number%;
                            &formatted_number    = xFormatNumber(%&read_number%,%&format_precision%,false);
                            &pure_number         = replace(&formatted_number,",");
                            debug_log(%debug%,%&script_debug_name%,"Calling &bxFormatNumber&7 on &&read_number ('&5%&before_xformat%&7') returned '&d%&formatted_number%&7' (called &bxFormatNumber&7 with args: precision: '&e%&format_precision%&7', exclude_commas: '&cfalse&7'). Comma Stripped version is '&e%&pure_number%&7'.");
                            if(%&opt_format% == "METRIC");
                                &read_number = convertToMetric(%&pure_number%,-1);
                                debug_log(%debug%,%&script_debug_name%,"Calling &bconvertToMetric&7 on &&pure_number ('&5%&pure_number%&7') returned '&d%&read_number%&7' (called &bconvertToMetric&7 with args: precision: '&e-1&7').");
                            elseif(%use_delimiter%);
                                &read_number = %&formatted_number%;
                                &delim_char  = ",";
                                if(%custom_delimiter%);
                                    &delim_char  = %&opt_delimiter%;
                                    &read_number = replace(&read_number,",",%&delim_char%);
                                endif;
                                debug_log(%debug%,%&script_debug_name%,"Set &&read_number ('&5%&pure_number%&7') to be formatted using delimiter character (&&delim_char: '&e%&delim_char%&7'): '&d%&read_number%&7'.");
                            else;
                                &read_number = %&pure_number%;
                                debug_log(%debug%,%&script_debug_name%,"Set &&read_number ('&5%&read_number%&7') to be stripped of Delimiter Characters.");
                            endif;
                        endif;
                        
                        // If we are only returning sig. figs, do that.
                        if(%&opt_precision% == "SIGNIFICANT");
                            ifmatches(%&read_number%,"^(.*?)\.0*$",&first_portion,1);
                                &read_number = %&first_portion%;
                            endif;
                        endif;
                    endif;
                endif;
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning '&d%&read_number%&7' from input number '&5%&number%&7' (applied opts: format='&e%&opt_format%&7', precision='&e%&opt_precision%&7', rounding='&e%&opt_rounding%&7', delimiter='&e%&opt_delimiter%&7').");
            return(%&read_number%);
        endfunction;
    // auctions/getListingInfo/auctionsCheckCache
        // Given any number of an Auction's Identifiers, sifts through Cached Auctions and finds a Listing that matches all of the Identifiers.
            // Params:
                // {string} <...&auction_identifiers[]>    An Array of Auction Identifiers in format: '<ID_TYPE>: <ID_DATA>'. If multiple instances of a given
                //                                         ID_TYPE are encountered, the one that appears latest in the Array is used. Valid ID_TYPE Prefixes are
                //                                         at the end of this Comment.
            // Valid ID_TYPE Prefixes:
                // {string} ID          The Listing ID
                // {string} TYPE        The Listing Type (one of: BIN, AUCTION)
                // {number} PRICE       The Current Listing Price
                // {number} BIDS        The amount of Bids on the Listing
                // {boolean} ENDED      Whether or not the Listing has Ended
                // {boolean} CLAIMED    Whether or not the Listing has been claimed
                // {string} OWNER       The UUID of the Player that created this Listing
                // {string} PROFILE     The Profile ID the Owner of this Listing was using to create this Listing
                // {string} SBID        The SkyBlock ID of the Item that this Listing represents
                // {string} NAME        The Display Name of the Item that this Listing represents
                // {string} MCID        The Minecraft Item ID that this Listing represents
                // {number} DATA        The Data Value of the Item that this Listing represents
                // {number} STACK       The Stack Size of the Item that this Listing represents
                // {string} BUYER       A UUID(s) of a Player who purchased/claimed this Listing. If giving multiple, join them with ~.
            // Returns an Array:
                // 0  {boolean} cache_hit          Whether or not an Item from the Cache was found that matches the specified Auction Identifiers.
                // 1  {string}  &cache_id          The Listing ID
                // 2  {string}  &cache_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #cache_price       The Current Listing Price
                // 4  {number}  #cache_bids        The amount of Bids on the Listing
                // 5  {boolean} cache_ended        Whether or not the Listing has Ended
                // 6  {boolean} cache_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &cache_owner       The UUID of the Player that created this Listing
                // 8  {string}  &cache_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &cache_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &cache_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &cache_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #cache_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #cache_stack       The Stack Size of the Item that this Listing represents
                // 14 {string}  &cache_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #cache_end_time    The Timestamp of when this Listing will end
            // Example
                //    &cache_data[]    = auctionsCheckCache(...&auction_identifiers[]);
                //    cache_hit       := %&cache_data[0]%;
                //    &cache_id        = %&cache_data[1]%;
                //    &cache_type      = %&cache_data[2]%;
                //    #cache_price    := %&cache_data[3]%;
                //    #cache_bids     := %&cache_data[4]%;
                //    cache_ended     := %&cache_data[5]%;
                //    cache_claimed   := %&cache_data[6]%;
                //    &cache_owner     = %&cache_data[7]%;
                //    &cache_profile   = %&cache_data[8]%;
                //    &cache_sbid      = %&cache_data[9]%;
                //    &cache_name      = %&cache_data[10]%;
                //    &cache_mcid      = %&cache_data[11]%;
                //    #cache_data     := %&cache_data[12]%;
                //    #cache_stack    := %&cache_data[13]%;
                //    &cache_buyers    = %&cache_data[14]%;
                //    #cache_end_time := %&cache_data[15]%;
        function auctionsCheckCache(...&auction_identifiers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:56
            // Setup Function Variables
            if(true);
                debug                  = false;
                &script_debug_name     = "&5auctionsCheckCache&7";
                &identifier_prefixes[] = split(", ","ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK, BUYER, END_TIME");
                &identifier_types[]    = split(", ","string, string, number, number, boolean, boolean, string, string, string, string, string, number, number, string, number");
                &map_type_terms[]      = split(", ","string, number, boolean");
                &map_type_prefixes[]   = split(", ","&, #, ");
                &valid_prefixes        = join("|",&identifier_prefixes[]);
                &return_array[0]       = "false";
                
                // Create Array of Unique Identifiers to match against cache entries
                debug_log(%debug%,%&script_debug_name%,"creating array of unique auction identifiers...");
                foreach(&auction_identifiers[],&auction_identifier,#ai);
                    ifmatches(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$");
                        match(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$",{&identifier_prefix,&identifier_value});
                        #filter_key_index = indexof(&filter_keys[],,%&identifier_prefix%);
                        if(%#filter_key_index% == -1);
                            #prefix_index           = indexof(&identifier_prefixes[],,%&identifier_prefix%);
                            #map_type_index         = indexof(&map_type_terms[],,%&identifier_types[%#prefix_index%]%);
                            &filter_keys[]          = %&identifier_prefix%;
                            &filter_vals[]          = %&identifier_value%;
                            &filter_type_terms[]    = %&identifier_types[%#prefix_index%]%;
                            &filter_type_prefixes[] = %&map_type_prefixes[%#map_type_index%]%;
                        else;
                            &filter_vals[%#filter_key_index%]% = %&identifier_value%;
                        endif;
                    endif;
                next;
                
                #filter_keys_sz = arraysize(&filter_keys[]);
                debug_log(%debug%,%&script_debug_name%,"found a total of &d%#filter_keys_sz% unique identifiers, they are:");
                foreach(&filter_keys[],&filter_key,#fk);
                    debug_log(%debug%,%&script_debug_name%,"%#fk% > key: %&filter_key%, value: %&filter_vals[%#fk%]%");
                next;
            endif;
            
            // Loop over Cached Entries and try to find an Entry that has a match for all the Keys we are filtering for.
            if(%#filter_keys_sz% >= 1);
                // Correct the filter_key OWNER from Username to UUID, if OWNER is in the Filter Keys Array. Do the same for BUYER.
                if(true);
                    &check_for_keys[] = split(", ","OWNER, BUYER");
                    foreach(&check_for_keys[],&check_for_key,#cfk);
                        #key_index = indexof(&filter_keys[],,%&check_for_key%);
                        if(%#key_index% != -1);
                            &minecraft_profile[]  = getMinecraftProfile(%&filter_vals[%#key_index%]%);
                            minecraft_profile    := %&minecraft_profile[0]%;
                            if(%minecraft_profile%);
                                &minecraft_joint_uuid      = %&minecraft_profile[2]%;
                                debug_log(%debug%,%&script_debug_name%,"converted key &d%&check_for_key%&7 with value &d%&filter_vals[%#key_index%]%&7 to UUID &d%&minecraft_joint_uuid%&7.");
                                &filter_vals[%#key_index%] = %&minecraft_joint_uuid%;
                            else;
                                debug_error(%debug%,%&script_debug_name%,"failed to convert key &d%&check_for_key%&7 with value &d%&filter_vals[%#key_index%]%&7 to UUID!");
                            endif;
                        endif;
                    next;
                endif;
                
                // Iteratively loop over the Cache Array that maps to the First Element of the Filter Keys Array to record all Indexes
                // where we may find a match for all the Auction Identifiers in their source Arrays. We do this to cut down on the amount of Elements
                // that we must manually iterate over.
                if(true);
                    // Check if there is an ID or OWNER Key to use as the 'primary' key. If so, prefer to use that Key as the primary key. If not, use the first index.
                    if(true);
                        #primary_key_index = 0;
                        #id_index          = indexof(&filter_keys[],,"ID");
                        #owner_index       = indexof(&filter_keys[],,"OWNER");
                        if(%#id_index% != -1);
                            #primary_key_index = %#id_index%;
                        elseif(%#owner_index% != -1);
                            #primary_key_index = %#owner_index%;
                        endif;
                    endif;
                    
                    debug_log(%debug%,%&script_debug_name%,"finding possible indices");
                    &map_type_prefix           = %&filter_type_prefixes[%#primary_key_index%]%;
                    &primary_cache_search_term = %&filter_vals[%#primary_key_index%]%;
                    &primary_cache_arr_ptr     = lcase("@%&map_type_prefix%cached_listing_%&filter_keys[%#primary_key_index%]%");
                    #loop_augment              = 0;
                    #latest_index              = -1;
                    do;
                        if(%#latest_index% >= 0);
                            debug_log(%debug%,%&script_debug_name%,"have pushed at least one element (#latest_index: %#latest_index%)");
                            #subarray_start = %#check_indices[%#latest_index%]% + 1;
                            debug_log(%debug%,%&script_debug_name%,"element at index %#latest_index% in #check_indices array is &d%#check_indices[%#latest_index%]%&7, will create subarray starting from +1 from this element (&d%#subarray_start%&7).");
                        else;
                            debug_log(%debug%,%&script_debug_name%,"have not pushed any elements, subarray_start set to 0.");
                            #subarray_start = 0;
                        endif;
                        &subarray_string = "%&primary_cache_arr_ptr%[%#subarray_start%:]";
                        push(&primary_cache_subarray[],%&subarray_string%);
                        #primary_cache_index = indexof(&primary_cache_subarray[],,%&primary_cache_search_term%);
                        if(%#primary_cache_index% != -1);
                            #previous_index = %#latest_index%;
                            #latest_index   = %#latest_index% + 1;
                            #real_index     = %#primary_cache_index% + %#subarray_start%;
                            debug_log(%debug%,%&script_debug_name%,"found element at index %#primary_cache_index% in subarray, offset &d%#subarray_start%&7 from source array, source index is &d%#real_index%&7. Incrementing #latest_index from &c%#previous_index%&7 to &a%#latest_index%&7.");
                            #check_indices[] = %#real_index%;
                        else;
                            debug_log(%debug%,%&script_debug_name%,"cannot find any more elements, breaking");
                            break;
                        endif;
                        unset(&primary_cache_subarray[]);
                    until(%#primary_cache_index% == -1);
                endif;
                
                #check_indices_sz = arraysize(#check_indices[]);
                debug_log(%debug%,%&script_debug_name%,"found total of &d%#check_indices_sz%&7 possible indices");
                if(%#check_indices_sz% >= 1);
                    debug_log(%debug%,%&script_debug_name%,"iterating over possible indices to find entries");
                    foreach(#check_indices[],#check_index,#ci);
                        debug_log(%debug%,%&script_debug_name%,"%#ci%/%#check_indices_sz% - checking index %#check_index%");
                        index_matched = true;
                        foreach(&filter_keys[],&filter_key,#fk);
                            &filter_val         = %&filter_vals[%#fk%]%;
                            &filter_type_term   = %&filter_type_terms[%#fk%]%;
                            &filter_type_prefix = %&filter_type_prefixes[%#fk%]%;
                            &filter_cache_ptr   = lcase("@%&filter_type_prefix%cached_listing_%&filter_key%[%#check_index%]");
                            &filter_cache_val   = %%&filter_cache_ptr%%;
                            val_match           = %&filter_cache_val% == %&filter_val%;
                            if(%&filter_type_term% == "boolean");
                                filter_val  := %&filter_val%;
                                cached_val  := %&filter_cache_val%;
                                val_match    = %filter_val% == %cached_val%;
                            elseif(%&filter_type_term% == "number");
                                #filter_val := %&filter_val%;
                                #cached_val := %&filter_cache_val%;
                                val_match    = %#filter_val% == %#cached_val%;
                            endif;
                            
                            if(!%val_match%);
                                debug_log(%debug%,%&script_debug_name%,"cached_listing index &d%#check_index%&7 is disqualified, term &d%&filter_key%&7 expected value &a%&filter_val%&7, indexed value was &c%&filter_cache_val%&7.");
                                index_matched = false;
                                break;
                            endif;
                        next;
                        
                        if(%index_matched%);
                            debug_log(%debug%,%&script_debug_name%,"cached_listing index &d%#check_index%&7 is &amatched&7, all terms met expected values");
                            &return_array[0] = "true";
                            foreach(&identifier_prefixes[],&identifier_prefix,#ipi);
                                #map_type_term_index    = indexof(&map_type_terms[],,%&identifier_types[%#ipi%]%);
                                &identifier_type_prefix = %&map_type_prefixes[%#map_type_term_index%]%;
                                &prefix_cache_ptr       = lcase("@%&identifier_type_prefix%cached_listing_%&identifier_prefix%[%#check_index%]");
                                &return_array[]         = %%&prefix_cache_ptr%%;
                            next;
                            break;
                        endif;
                    next;
                endif;
            endif;
            
            return(&return_array[]);
        endfunction;
    // info/index/getItemInfoSB
        // Given an Item's Display Name or SBID, looks it up in the global arrays @&sb_datamap_item_names[] and/or
        // @&sb_datamap_item_sbids[], then returns the Data found at that index accordingly.
            // Params:
                //    {string}     <&search_term>               The Item's Display Name or SBID to search for.
                //    {boolean}    [return_collection=false]    Whether or not to append Collection information to the returned Array.
                //
            // Returns an Array -- first element will be -1 if no match was found.
                //    0    {string}     &found_name        The Display Name of the Item found
                //    1    {string}     &found_sbid        The SBID of the Item found
                //    2    {string}     &found_mcid        The MCID of the Item found
                //    3    {number}     #found_data        The Data value of the Item found (0 = no data).
                //    4    {number}     #found_sell        The Sell Price of the Item found (0 = not sellable).
                //    5    {number}     #found_stack       The maximum stack size of the Item found
                //    6    {string}     &found_tier        The Tier of this Item ("" = no Tier, valid strings = COMMON, UNCOMMON, RARE, EPIC, LEGENDARY, MYTHIC, SPECIAL)
                //    7    {string}     &found_category    The Category of this Item ("" = no Category, valid strings = ACCESSORY, ARROW, ARROW_POISON, AXE, BAIT, BOOTS,
                //                                         BOW, CHESTPLATE, COSMETIC, DRILL, DUNGEON_PASS, FISHING_ROD, FISHING_WEAPON, GAUNTLET, HELMET, HOE, LEGGINGS,
                //                                         PET_ITEM, PICKAXE, REFORGE_STONE, SHEARS, SPADE, SWORD, TRAVEL_SCROLL, WAND).
                //    8    {boolean}    found_bazaar       Whether or not the Item is available for trading on Bazaar.
                //
                //
                // The following elements will also be returned if [return_collection] is set to True.
                    //    9     {boolean}    has_collection         Whether or not the Item belongs to a Collection
                    //    10    {string}     &collection_name       The Name of the Collection this Item belongs to ("NULL" = no collection).
                    //    11    {string}     &collection_cmdname    The Command String (used in /viewcollection <&collection_cmdname>) to directly enter this Collection.
                    //                                              "NULL" = no collection.
                    //    12    {string}     &collection_sbid       The SBID of the Base Item in this Collection.
                    //    13    {number}     #collection_tier       The Tier of the Collection this Item belongs to (0 = no collection).
                    //    14    {number}     #collection_amt        The Amount of Items required to have been Collected in order for this Item to be unlocked.
                    //                                              0 = no collection.
            // Example:
                // Without Collection Appended
                    //    &item_data[]    = getItemInfoSB("ENCHANTED_DIAMOND_BLOCK");
                    //    &found_name     = %&item_data[0]%;
                    //    &found_sbid     = %&item_data[1]%;
                    //    &found_mcid     = %&item_data[2]%;
                    //    #found_data    := %&item_data[3]%;
                    //    #found_sell    := %&item_data[4]%;
                    //    #found_stack   := %&item_data[5]%;
                    //    &found_tier     = %&item_data[6]%;
                    //    &found_category = %&item_data[7]%;
                    //    found_bazaar   := %&item_data[8]%;
                // With Collection Appended
                    //    &item_data[]        = getItemInfoSB("ENCHANTED_DIAMOND_BLOCK",true);
                    //    &found_name         = %&item_data[0]%;
                    //    &found_sbid         = %&item_data[1]%;
                    //    &found_mcid         = %&item_data[2]%;
                    //    #found_data        := %&item_data[3]%;
                    //    #found_sell        := %&item_data[4]%;
                    //    #found_stack       := %&item_data[5]%;
                    //    &found_tier         = %&item_data[6]%;
                    //    &found_category     = %&item_data[7]%;
                    //    found_bazaar       := %&item_data[8]%;
                    //    has_collection     := %&item_data[9]%;
                    //    &collection_name    = %&item_data[10]%;
                    //    &collection_cmdname = %&item_data[11]%;
                    //    &collection_sbid    = %&item_data[12]%;
                    //    #collection_tier   := %&item_data[13]%;
                    //    #collection_amt    := %&item_data[14]%;
        function getItemInfoSB(&search_term,return_collection=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:167
            // Find the Index of the Data we are retrieving.
            if(true);
                #name_index = indexof(@&sb_datamap_item_names[],,%&search_term%);
                #sbid_index = indexof(@&sb_datamap_item_sbids[],,%&search_term%);
                if((#name_index == -1) && (#sbid_index == -1));
                    &return_array[] = "-1";
                    return(&return_array[]);
                elseif(%#sbid_index% != -1);
                    #use_index = %#sbid_index%;
                elseif(%#name_index% != -1);
                    #use_index = %#name_index%;
                endif;
            endif;
            
            // Extract Data from the JSON Element located at the found Index.
            if(true);
                &found_json      = %@&sb_datamap_item_jsons[%#use_index%]%;
                &return_array[0] = jsonget("name",%&found_json%);
                &return_array[1] = jsonget("sbid",%&found_json%);
                &return_array[2] = jsonget("mcid",%&found_json%);
                &return_array[3] = jsonget("data",%&found_json%);
                &return_array[4] = xJsonGet("sellPrice",%&found_json%);
                &return_array[5] = jsonget("maxStack",%&found_json%);
                &return_array[6] = jsonget("tier",%&found_json%);
                &return_array[7] = jsonget("category",%&found_json%);
                &return_array[8] = jsonget("onBazaar",%&found_json%);
                if(%return_collection%);
                    &collection_json = jsonget("collection",%&found_json%);
                    has_collection   = jsonget("hasCollection",%&collection_json%);
                    &return_array[9] = %has_collection%;
                    if(%has_collection%);
                        &collection_name  = jsonget("name",%&collection_json%);
                        &return_array[10]  = %&collection_name%;
                        #coll_ext_index   = indexof(@&sb_datamap_collection_names[],,%&collection_name%);
                        &coll_ext_json    = %@&sb_datamap_collection_jsons[%#coll_ext_index%]%;
                        &return_array[11]  = jsonget("cmdName",%&coll_ext_json%);
                        &return_array[12] = jsonget("sbid",%&coll_ext_json%);
                        #collection_tier  = jsonget("tier",%&collection_json%);
                        #collection_idx   = %#collection_tier% - 1;
                        &return_array[13] = %#collection_tier%;
                        &return_array[14] = xJsonGet("tiers.%#collection_idx%.amountRequired",%&coll_ext_json%);
                        return(&return_array[]);
                    endif;
                    &return_array[10]  = "NULL";
                    &return_array[11] = "NULL";
                    &return_array[12] = "NULL";
                    &return_array[13] = "0";
                    &return_array[14] = "0";
                    return(&return_array[]);
                endif;
                return(&return_array[]);
            endif;
        endfunction;
    // auctions/getListingInfo/auctionsDecodeItemData
        // Given an Auction's JSON Data, grabs the Auction's 'item_bytes.data' Field and submits it to the local NBT decoder API to convert it.
            // Params:
                // {string} <&auction_json>    The Auction JSON to extract Data from.
                //
            // Status String ENUMs:
                // SUCCESS               Successfully decoded the Data
                // ERROR_INVALID_DATA    Invalid Input Data
                // ERROR_SERVER          Decode API is Down
                // ERROR_UNKNOWN         Unknown Error occurred
            // Returns an Array:
                // 0 {string} &decoded_status    String ENUM describing the Status of the Decode Request. Possible values are defined above.
                // 1 {string} &decoded_sbid      The Auction Listing Item SBID
                // 2 {string} &decoded_mcid      The Auction listing Item MCID
                // 3 {string} &decoded_name      The Auction Listing Item Name
                // 4 {number} #decoded_data      The Auction Listing Item Data/Damage Value
                // 5 {number} #decoded_stack     The Stack Size of the Auction Listing Item
            // Example:
                //    &decoded_bytes[] = auctionsDecodeItemData(%&auction_json%);
                //    &decoded_status  = %&decoded_bytes[0]%;
                //    &decoded_sbid    = %&decoded_bytes[1]%;
                //    &decoded_mcid    = %&decoded_bytes[2]%;
                //    &decoded_name    = %&decoded_bytes[3]%;
                //    #decoded_data   := %&decoded_bytes[4]%;
                //    #decoded_stack  := %&decoded_bytes[5]%;
        function auctionsDecodeItemData(&auction_json);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:335
            // Setup Function Variables
            if(true);
                debug                    = true;
                &script_debug_name       = "&9auctionsDecodeItemData&7";
                &enum_success            = "SUCCESS";
                &enum_error_invalid_data = "ERROR_INVALID_DATA";
                &enum_error_server       = "ERROR_SERVER";
                &enum_error_unknown      = "ERROR_UNKNOWN";
                &decode_api_url          = "http://localhost:8080/";
                &decoded_status          = %&enum_error_unknown%;
                ifmatches(%&decode_api_url%,"localhost");
                    log("&4&lWARNING: auctionsDecodeItemData is using localhost decoder API! Change to remote hosted decoder API before release to Production.")
                endif;
                
                setrequestheader("User-Agent",%UUID%);
                setrequestheader("Content-Type","application/json");
            endif;
            
            // Handle the API Request.
            if(true);
                &encoded_data = jsonget("item_bytes.data",%&auction_json%);
                ifmatches(%&encoded_data%,"^ERROR_");
                    debug_error(%debug%,%&script_debug_name%,"Invalid Auction JSON Data passed to Function, cannot extract item_bytes.data Field: &4%&auction_json%&c.");
                    &decoded_status  = %&enum_error_invalid_data%;
                else;
                    &request_body    = "{\"data\":\"%&encoded_data%\"}";
                    &server_response = httppost(%&decode_api_url%,%&request_body%,#decoded_code);
                    if(%#decoded_code% == 200);
                        &decoded_status  = %&enum_success%;
                        &decoded_sbid    = getItemSBID(%&server_response%);
                        &decoded_data[]  = getItemInfoSB(%&decoded_sbid%);
                        &decoded_sbid    = %&decoded_data[1]%;
                        &decoded_mcid    = %&decoded_data[2]%;
                        #decoded_data   := %&decoded_data[3]%;
                        #decoded_stack   = jsonget("Count",%&server_response%);
                        &decoded_name    = jsonget("item_name",%&auction_json%);
                        &decoded_name    = strip(%&decoded_name%);
                    elseif(%#decoded_code% == -1);
                        &decoded_status  = %&enum_error_server%;
                    elseif(%#decoded_code% == 500);
                        &decoded_status  = %&enum_error_server%;
                    endif;
                endif;
                
                &vars[] = split(" ","&decoded_status &decoded_sbid &decoded_mcid &decoded_name #decoded_data #decoded_stack");
                foreach(&vars[],&var,#v);
                    &val = %%&var%%;
                    &logvar = regexreplace(&var,"(?<!&)&","&&");
                    debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar% : %&val%");
                next;
                
                &return_array[] = split(", ","%&decoded_status%, %&decoded_sbid%, %&decoded_mcid%, %&decoded_name%, %#decoded_data%, %#decoded_stack%");
            endif;
            return(&return_array[]);
        endfunction;
    // debug/index/debug_breakpoint
        // Logs a message to chat and halts until SHIFT is held.
            // Params:
            //      <boolean> debug_enabled      : The debug condition (if true, will log).
            //      <string>  &script_debug_name : The prefix for the debug log
            //      <string>  &string            : The debug message to print to chat
            //
            // Returns the printed message.
            //
        function debug_breakpoint(debug_enabled=true,&script_debug_name="&8DEBUG_LOG&7",&string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/debug/index.txt:70
            // &matcher       = "(?-i)(?<!&)(&[a-fk-r])(?=[a-z0-9_-]+)";
            // &replacement   = "&$1";
            // &string        = regexreplace(&string,%&matcher%,%&replacement%);
            &break_message = "&7%&script_debug_name%&7: &8Breakpoint (HOLD SHIFT)&7 > %&string%";
            if(%debug_enabled%);
                log(%&break_message%);
                do;wait("1t");until(%SHIFT%);
                do;wait("1t");while(%SHIFT%);
            endif;
            return(%&break_message%);
        endfunction;
    // auctions/getListingInfo/auctionsDecodeListingsData
        // Similar to auctionsDecodeItemData, except decodes an Array of Auction's 'item_bytes.data' Fields.
            // Params:
                // {string} <&all_auctions_json>    All of the Auction JSONs to extract Data from.
                //
            // Status String ENUMs:
                // SUCCESS               Successfully decoded the Data
                // ERROR_INVALID_DATA    Invalid Input Data
                // ERROR_SERVER          Decode API is Down
                // ERROR_UNKNOWN         Unknown Error occurred
            // Returns an Array where the first Element is the Decode Status ENUM, then the remaining are Tunnel Split Strings, where each String holds Data in Format:
                // 0 {string} &decoded_sbid     The Auction Listing Item SBID
                // 1 {string} &decoded_mcid     The Auction listing Item MCID
                // 2 {string} &decoded_name     The Auction Listing Item Name
                // 3 {number} #decoded_data     The Auction Listing Item Data/Damage Value
                // 4 {number} #decoded_stack    The Stack Size of the Auction Listing Item
            // Example:
                //    &decoded_auctions[] = auctionsDecodeListingsData(%&all_auctions_json%);
                //    foreach(&decoded_auctions[],&decoded_auction,#dai);
                //        if(%#dai% == 0);
                //            &decoded_status = %&decoded_auction%;
                //            if(%&decoded_status% == "SUCCESS");
                //            else;
                //                if(%&decoded_status% == "ERROR_INVALID_DATA");
                //                elseif(%&decoded_status% == "ERROR_SERVER");
                //                elseif(%&decoded_status% == "ERROR_UNKNOWN");
                //                endif;
                //            endif;
                //        else;
                //            &decoded_auction[]  = split("|",%&decoded_auction%);
                //            &decoded_sbid       = %&decoded_auction[0]%;
                //            &decoded_mcid       = %&decoded_auction[1]%;
                //            &decoded_name       = %&decoded_auction[2]%;
                //            #decoded_data      := %&decoded_auction[3]%;
                //            #decoded_stack     := %&decoded_auction[4]%;
                //        endif;
                //    next;
        function auctionsDecodeListingsData(&all_auctions_json);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:248
            // Setup Function Variables
            if(true);
                debug                    = false;
                &script_debug_name       = "&9auctionsDecodeListingsData&7";
                &enum_success            = "SUCCESS";
                &enum_error_invalid_data = "ERROR_INVALID_DATA";
                &enum_error_server       = "ERROR_SERVER";
                &enum_error_unknown      = "ERROR_UNKNOWN";
                &decode_api_url          = "http://localhost:8080/multi";
                &return_array[0]         = %&enum_error_unknown%;
                ifmatches(%&decode_api_url%,"localhost");
                    log("&4&lWARNING: auctionsDecodeListingsData is using localhost decoder API! Change to remote hosted decoder API before release to Production.")
                endif;
                
                setrequestheader("User-Agent",%UUID%);
                setrequestheader("Content-Type","application/json");
            endif;
            
            // Handle the API Request.
            if(true);
                // Compile the Listings
                do;
                    &encoded_data = jsonget("auctions.%#auction_index%.item_bytes.data",%&all_auctions_json%);
                    ifmatches(%&encoded_data%,"^ERROR_");
                        debug_log(%debug%,%&script_debug_name%,"final auction index is %#auction_index%");
                        #final_index = %#auction_index%;
                        break;
                    endif;
                    
                    &decode_strings[] = "\"%&encoded_data%\"";
                    inc(#auction_index);
                loop;
                
                #decode_strings_sz = arraysize(&decode_strings[]);
                if(%#decode_strings_sz% >= 1);
                    &decode_strings  = join(",",&decode_strings[]);
                    &request_body    = "{\"listings\":[%&decode_strings%]}";
                    &server_response = httppost(%&decode_api_url%,%&request_body%,#decoded_code);
                    if(%#decoded_code% == 200);
                        &return_array[0] = %&enum_success%;
                        for(#auction_index,0,%#final_index%);
                            &decoded_nbt     = jsonget(%#auction_index%,%&server_response%);
                            &decoded_sbid    = getItemSBID(%&decoded_nbt%);
                            &decoded_data[]  = getItemInfoSB(%&decoded_sbid%);
                            &decoded_sbid    = %&decoded_data[1]%;
                            &decoded_mcid    = %&decoded_data[2]%;
                            #decoded_data   := %&decoded_data[3]%;
                            #decoded_stack   = jsonget("Count",%&decoded_nbt%);
                            &decoded_name    = jsonget("auctions.%#auction_index%.item_name",%&all_auctions_json%);
                            &decoded_name    = strip(%&decoded_name%);
                            &return_array[]  = "%&decoded_sbid%|%&decoded_mcid%|%&decoded_name%|%#decoded_data%|%#decoded_stack%";
                        next;
                    elseif((%#decoded_code% == -1) || (%#decoded_code% == 500));
                        &return_array[0] = %&enum_error_server%;
                    endif;
                else;
                    debug_error(%debug%,%&script_debug_name%,"did not find any decode_strings in passed all_auctions_json!");
                endif;
            endif;
            return(&return_array[]);
        endfunction;
    // api/index/getHypixelAPIRequestLimit
        // Gets the limiting variables for the current Player.
            // Params:
            //        None
            //
            // Returns an Array:
            //        0 <integer> #reqs_in_last_min : Total requests in the last 60 seconds.
            //        1 <integer> #reqs_avail_now   : Total requests available now before hitting throttle.
            //        2 <integer> #wait_timestamp   : Timestamp to wait till before making the next request to avoid being throttled.
        function getHypixelAPIRequestLimit();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:45
            &script_debug_name = "&9getHypixelAPIRequestLimit&7";
            debug              = true;
            #max_req_per_min   = 120;
        
            #api_reqs = arraysize(@#api_req_ts[]);
            if(%#api_reqs% >= 1);
                #array_end = %#api_reqs% - 1;
                for(#i,%#array_end%,0);
                    #api_req_ts  = %@#api_req_ts[%#i%]%;
                    #elapsed_sec = %TIMESTAMP% - %#api_req_ts%;
                    if(%#elapsed_sec% <= 120);
                        #save_timestamps[] = %#api_req_ts%;
                    endif;
                next;
        
                unset(@#api_req_ts[]);
                push(@#api_req_ts[],#save_timestamps[*]);
        
            endif;
        
            #reqs_in_last_min = arraysize(#save_timestamps[]);
            #reqs_avail_now   = 120 - %#reqs_in_last_min%;
            #wait_timestamp   = %TIMESTAMP% + ((%#reqs_in_last_min% - 120) / 2);
            return(%#reqs_in_last_min%,%#reqs_avail_now%,%#wait_timestamp%);
        endfunction;
    // string/index/isStringUUID
        // Checks if a string matches UUID regex.
            // Params:
            //        <string> &check_string : The string to check
            //
            // Returns a boolean.
            //
        function isStringUUID(&check_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:28
            &script_debug_name = "&9isStringUUID&7";
            debug              = false;
            &split_uuid_expr   = "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$";
            &joint_uuid_expr   = "^[a-f0-9]{32}$";
            &uuid_exprs[]      = split(", ","%&split_uuid_expr%, %&joint_uuid_expr%");
            foreach(&uuid_exprs[],&uuid_expr);
                ifmatches(%&check_string%,%&uuid_expr%);
                    match_found = true;
                    break;
                endif;
            next;
            return(%match_found%);
        endfunction;
    // api/index/getHypixelAPIKey
        // Gets a new Hypixel API Key.
            // Params:
            //        None
            //
            // Returns the new API Key String.
        function getHypixelAPIKey();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:6
            &script_debug_name = "&9getHypixelAPIKey&7";
            debug              = false;
            &old_api_key       = %@&api_key%;
            
            // Check if we need to get onto a Hypixel Server (not in Limbo) before execution.
            &hy_gamemode = getHypixelGamemode();
            if(%&hy_gamemode% == "LIMBO");
                do;
                    on_server = gotoServer("SKYBLOCK");
                    if(%on_server%);
                        break;
                    endif;
                    wait("1t");
                until(%on_server%);
            endif;
            
            do;
                echo("/api new");
                do(20);
                    wait("1t");
                until(%&old_api_key% != %@&api_key%);
                if(%&old_api_key% != %@&api_key%);
                    &new_api_key  = %@&api_key%;
                    new_valid_key = isStringUUID(%&new_api_key%);
                    &old_api_key  = %&new_api_key%;
                endif;
            until(%new_valid_key%);
            return(%&new_api_key%);
        endfunction;
    // api/index/hypixelAPICall
        // Makes a Hypixel API Call.
            // Params:
                // {string}  <&api_url>                The endpoint to call
                // {string}  [&api_key=%@&api_key%]    The API Key to use with the request. Defaults to @&api_key
                // {boolean} [recursion=false]         True if this function was called by itself. Defaults to false
            // Returns an Array:
                // 0 {boolean}    req_success    True if we received response from API, false if we got throttled by CF.
                // 1 {boolean}    api_success    The value of the 'success' key in the API response.
                // 2 {integer}    #api_code      The HTTP Response Code from the API Request.
                // 3 {string}     &api_resp      The raw JSON data returned from the Server.
            // Example:
                // &api_data[]  = hypixelAPICall(%&api_url%);
                // req_success := %&api_data[0]%; // True if we received response from API, false if we got throttled by CF.
                // api_success := %&api_data[1]%; // The value of the 'success' key in the API response.
                // #api_code   := %&api_data[2]%; // The HTTP Response Code from the API Request.
                // &api_resp    = %&api_data[3]%; // The raw JSON data returned from the Server.
        function hypixelAPICall(&api_url,&api_key=%@&api_key%,recursion=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:88
            &script_debug_name = "&9hypixelAPICall&7";
            debug              = true;
            
            // Setup variables
            if(true);
                key_needed     = true;
                req_success    = false;
                api_success    = false;
                #api_code      = -1;
                &api_resp      = "";
                #retry_codes[] = split(", ","403, 429, 503"); // 403: invalid api key, 429: throttled, 503: data unavailable right now
        
                // Setup known API Endpoints
                if(true);
                    &api_endpoints[] = "false|skyblock/auctions_ended";
                    &api_endpoints[] = "true|skyblock/auctions";
                    &api_endpoints[] = "true|skyblock/profiles";
                    &api_endpoints[] = "true|skyblock/auction";
                    &api_endpoints[] = "true|skyblock/profile";
                    &api_endpoints[] = "false|skyblock/bazaar";
                    &api_endpoints[] = "true|punishmentstats";
                    &api_endpoints[] = "true|skyblock/news";
                    &api_endpoints[] = "true|leaderboards";
                    &api_endpoints[] = "true|recentgames";
                    &api_endpoints[] = "false|resources";
                    &api_endpoints[] = "true|boosters";
                    &api_endpoints[] = "true|friends";
                    &api_endpoints[] = "true|player";
                    &api_endpoints[] = "true|status";
                    &api_endpoints[] = "true|counts";
                    &api_endpoints[] = "true|guild";
                    &api_endpoints[] = "true|key";
                endif;
        
                // Find the endpoint we are hitting
                if(true);
                    &api_uri = regexreplace(&api_url,"https://api.hypixel.net/","");
                    &use_uri = "";
                    foreach(&api_endpoints[],&api_endpoint,#aei);
                        &this_data[]   = split("|",%&api_endpoint%);
                        this_key_req  := %&this_data[0]%;
                        &this_endpoint = %&this_data[1]%;
                        ifmatches(%&api_uri%,"^%&this_endpoint%");
                            &use_uri   = %&this_endpoint%;
                            key_needed = %this_key_req%;
                            break;
                        endif;
                    next;
                    skip_req = %&use_uri% == "";
                endif;
            endif;
        
            // Validate the API Key passed to the function, if we are going to be using one.
            if((!%skip_req%) && (%key_needed%));
                key_test = isStringUUID(%&api_key%);
                if(!%key_test%);
                    debug_error(%debug%,%&script_debug_name%,"Parameter 'api_key' is invalid UUID: &4%&api_key%&7. Attempting to fix");
                    global_test = isStringUUID(%@&api_key%);
                    if(%global_test%);
                        &api_key = %@&api_key%;
                        debug_log(%debug%,%&script_debug_name%,"Using environment api_key instead (&a%@&api_key%&7).");
                    else;
                        &new_key  = getHypixelAPIKey();
                        new_valid = isStringUUID(%&new_key%);
                        if(%new_valid%);
                            debug_log(%debug%,%&script_debug_name%,"Using new api_key instead (&a%&new_key%&7).");
                            &api_key = %&new_key%;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Failed to get a new valid API key to use.");
                        endif;
                    endif;
                    key_test = isStringUUID(%&api_key%);
                    skip_req = !%key_test%;
                endif;
            endif;
        
            // Make the request, if we are making the request.
            if(true);
                if(!%skip_req%);
                    if(%key_needed%);
                        setrequestheader("API-Key",%&api_key%);
                        #throttle_vars[]  = getHypixelAPIRequestLimit();
                        #reqs_in_last_min = %#throttle_vars[0]%;
                        #reqs_avail_now   = %#throttle_vars[1]%;
                        #wait_timestamp   = %#throttle_vars[2]%;
        
                        if(%#reqs_avail_now% <= 0);
                            #wait_seconds = %#wait_timestamp% - %TIMESTAMP%;
                            debug_log(%debug%,%&script_debug_name%,"Delaying request by &d%#wait_seconds% seconds&7 to avoid being limited by Hypixel API.");
                            wait("%#wait_seconds%s");
                            &return_array[] = call("hypixelAPICall",%&api_url%,%&api_key%);
                            return(&return_array[]);
                        endif;
                    endif;
        
                    // Add the base URL to the request URL if it was not provided.
                    ifmatches(%&api_url%,"^https://api.hypixel.net");else;
                        &api_parts[] = "https://api.hypixel.net"
                        ifmatches(%&api_url%,"^/");else;
                            &api_parts[] = "/";
                        endif;
                        &api_parts[] = %&api_url%;
                        &api_url     = join("",&api_parts[]);
                    endif;
        
                    @#api_req_ts[] = %TIMESTAMP%;
                    &api_resp      = httpget(%&api_url%,,#api_code);
                    &success       = jsonget("success",%&api_resp%);
                    ifmatches(%&success%,"ERROR_"); // If we got an unexpected error, it normally means we got throttled by CloudFlare.
                        &req_uuid      = %UNIQUEID%;
                        &log_strings[] = "-----"
                        &log_strings[] = "Request Date: %DATETIME%";
                        &log_strings[] = "Request UUID: %&req_uuid%";
                        &log_strings[] = "Request URL : %&api_url%";
                        &log_strings[] = "Request Key : %&api_key%";
                        &log_strings[] = " ";
                        &log_strings[] = "Response Code: %#api_code%";
                        &log_strings[] = "Response Body: %&api_resp%";
                        &log_strings[] = " ";
                        &log_strings[] = " ";
                        &log_path[]    = split(%FILESEPARATOR%,%MACROSCONFIGDIR%);
                        &log_path[]    = "logs";
                        &log_path[]    = "bad_requests.txt";
                        &log_path      = join(%FILESEPARATOR%,&log_path[]);
                        writefile(%&log_path%,&log_strings[],true);
                        debug_error(%debug%,%&script_debug_name%,"Got a bad request from the API call, response logged to file:");
                        &vars[] = split(" ","&req_uuid &log_path #api_code");
                        foreach(&vars[],&var,#v);
                            &_var = regexreplace(&var,"&","&&");
                            &val  = "%%&var%%";
                            debug_log(%debug%,%&script_debug_name%,"%#v% > %&_var%: &d%&val%&7.");
                        next;
                    else;
                        req_success  = true;
                        api_success := %&success%;
                        #retry_index = indexof(#retry_codes[],,%#api_code%);
        
                        // If the request was unsuccessful and the Response Code is an error that we can fix, attempt to do so.
                        if((!%api_success%) && (%#retry_index% != -1) && (!%recursion%));
                            if(%#api_code% == 403); // invalid api key
                                &api_key = getHypixelAPIKey();
                            elseif((%#api_code% == 429) || (%#api_code% == 503)); // throttled = 429, 503 = data unavailable right now
                                wait("10000ms");
                            endif;
        
                            skip_return_arr = true;
                            &return_array[] = call("hypixelAPICall",%&api_url%,%&api_key%,true);
                        endif;
                    endif;
                elseif(%&use_uri% == "");
                    debug_error(%debug%,%&script_debug_name%,"Could not find API Endpoint from URL: &4%&api_url%&7.");
                endif;
            endif;
        
            // Populate the return array, unless it was already populated.
            if(!%skip_return_arr%);
                &return_array[] = %req_success%;
                &return_array[] = %api_success%;
                &return_array[] = %#api_code%;
                &return_array[] = %&api_resp%;
            endif;
            return(&return_array[]);
        endfunction;
    // auctions/getListingInfo/auctionsGetListingInfoFromAPI
        // Given an Auction's ID, and/or the Auctioneer's Username and as much identifying information regarding the Item as is possible, finds the Auction
        // Listing from the API and returns it's Data.
            // Params:
                // {string} <...&auction_identifiers[]>    An Array of Auction Identifiers in format: '<ID_TYPE>: <ID_DATA>'. If multiple instances of a given
                //                                         ID_TYPE are encountered, the one that appears latest in the Array is used. Valid ID_TYPE Prefixes are
                //                                         at the end of this Comment.
            // Valid ID_TYPE Prefixes:
                // {string} ID          The Listing ID
                // {string} TYPE        The Listing Type (one of: BIN, AUCTION)
                // {number} PRICE       The Current Listing Price
                // {number} BIDS        The amount of Bids on the Listing
                // {boolean} ENDED      Whether or not the Listing has Ended
                // {boolean} CLAIMED    Whether or not the Listing has been claimed
                // {string} OWNER       The UUID of the Player that created this Listing
                // {string} PROFILE     The Profile ID the Owner of this Listing was using to create this Listing
                // {string} SBID        The SkyBlock ID of the Item that this Listing represents
                // {string} NAME        The Display Name of the Item that this Listing represents
                // {string} MCID        The Minecraft Item ID that this Listing represents
                // {number} DATA        The Data Value of the Item that this Listing represents
                // {number} STACK       The Stack Size of the Item that this Listing represents
                // {string} BUYER       A UUID of a Player who purchased/claimed this Listing.
                // {number} END_TIME    The Timestamp of when this Listing will end
            // Returns an Array:
                // 0  {boolean} api_hit          Whether or not an Item from the api was found that matches the specified Auction Identifiers.
                // 1  {string}  &api_id          The Listing ID
                // 2  {string}  &api_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #api_price       The Current Listing Price
                // 4  {number}  #api_bids        The amount of Bids on the Listing
                // 5  {boolean} api_ended        Whether or not the Listing has Ended
                // 6  {boolean} api_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &api_owner       The UUID of the Player that created this Listing
                // 8  {string}  &api_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &api_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &api_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &api_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #api_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #api_stack       The Stack Size of the Item that this Listing represents
                // 14 {string}  &api_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #api_end_time    The Timestamp of when this Listing will end
            // Example
                //    &api_data[]    = auctionsGetListingInfoFromAPI(...&auction_identifiers[]);
                //    api_hit       := %&api_data[0]%;
                //    &api_id        = %&api_data[1]%;
                //    &api_type      = %&api_data[2]%;
                //    #api_price    := %&api_data[3]%;
                //    #api_bids     := %&api_data[4]%;
                //    api_ended     := %&api_data[5]%;
                //    api_claimed   := %&api_data[6]%;
                //    &api_owner     = %&api_data[7]%;
                //    &api_profile   = %&api_data[8]%;
                //    &api_sbid      = %&api_data[9]%;
                //    &api_name      = %&api_data[10]%;
                //    &api_mcid      = %&api_data[11]%;
                //    #api_data     := %&api_data[12]%;
                //    #api_stack    := %&api_data[13]%;
                //    &api_buyers    = %&api_data[14]%;
                //    #api_end_time := %&api_data[15]%;
        function auctionsGetListingInfoFromAPI(...&auction_identifiers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:449
            // Setup Function Variables
            if(true);
                debug                  = false;
                &script_debug_name     = "&3auctionsGetListingInfoFromAPI&7";
                &identifier_paths[]    = split(", ","uuid, NULL, NULL, NULL, NULL, claimed, auctioneer, profile_id, NULL, item_name, NULL, NULL, NULL, NULL, NULL");
                &identifier_prefixes[] = split(", ","ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK, BUYER, END_TIME");
                &identifier_types[]    = split(", ","string, string, number, number, boolean, boolean, string, string, string, string, string, number, number, string, number");
                &map_type_terms[]      = split(", ","string, number, boolean");
                &map_type_prefixes[]   = split(", ","&, #, ");
                &valid_prefixes        = join("|",&identifier_prefixes[]);
                api_hit                = false;
                
                // Create Array of Unique Identifiers to match against cache entries
                foreach(&auction_identifiers[],&auction_identifier,#ai);
                    ifmatches(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$");
                        match(%&auction_identifier%,"^(%&valid_prefixes%):\s*(.+)$",{&identifier_prefix,&identifier_value});
                        #filter_key_index = indexof(&filter_keys[],,%&identifier_prefix%);
                        if(%#filter_key_index% == -1);
                            #prefix_index           = indexof(&identifier_prefixes[],,%&identifier_prefix%);
                            #map_type_index         = indexof(&map_type_terms[],,%&identifier_types[%#prefix_index%]%);
                            &filter_keys[]          = %&identifier_prefix%;
                            &filter_vals[]          = %&identifier_value%;
                            &filter_type_terms[]    = %&identifier_types[%#prefix_index%]%;
                            &filter_type_prefixes[] = %&map_type_prefixes[%#map_type_index%]%;
                            &filter_paths[]         = %&identifier_paths[%#prefix_index%]%;
                        else;
                            &filter_vals[%#filter_key_index%]% = %&identifier_value%;
                        endif;
                    endif;
                next;
                
                #filter_keys_sz = arraysize(&filter_keys[]);
            endif;
            
            // Loop over Cached Entries and try to find an Entry that has a match for all the Keys we are filtering for.
            if(%#filter_keys_sz% >= 1);
                // Determine the Method we will be using to find the Auction Listing (did we get an Auction ID, or the Auctioneer's UUID?)
                if(true);
                    #id_index      = indexof(&filter_keys[],,"ID");
                    #owner_index   = indexof(&filter_keys[],,"OWNER");
                    got_listing_id = %#id_index% != -1;
                    got_owner_id   = %#owner_index% != -1;
                    
                    if((%got_listing_id%) || (%got_owner_id%));
                        #buyer_index = indexof(&filter_keys[],,"BUYER");
                        if(%#buyer_index% != -1);
                            &split_buyers[] = split("~",%&filter_vals[%#buyer_index%]%);
                            foreach(&split_buyers[],&split_buyer,#sbi);
                                &buyer_profile[]   = getMinecraftProfile(%&split_buyer%);
                                buyer_profile     := %&buyer_profile[0]%;
                                if(%buyer_profile%);
                                    &buyer_joint_uuid    = %&buyer_profile[2]%;
                                    &fixed_buyer_uuids[] = %&buyer_joint_uuid%;
                                    do_fixed_buyer       = true;
                                endif;
                            next;
                            
                            if(%do_fixed_buyer%);
                                &filter_vals[%#buyer_index%] = join("~",&fixed_buyer_uuids[]);
                            else;
                                &filter_keys[]          = arrayDelete(&filter_keys[],%#buyer_index%);
                                &filter_vals[]          = arrayDelete(&filter_vals[],%#buyer_index%);
                                &filter_type_terms[]    = arrayDelete(&filter_type_terms[],%#buyer_index%);
                                &filter_type_prefixes[] = arrayDelete(&filter_type_prefixes[],%#buyer_index%);
                                &filter_paths[]         = arrayDelete(&filter_paths[],%#buyer_index%);
                            endif;
                        endif;
                    endif;
                endif;
                
                // Execute the branch corresponding to which Data Types we received.
                if(true);
                    debug_log(%debug%,%&script_debug_name%,"Making API Call...");
                    if(%got_listing_id%);
                        // Get the API Data
                        if(true);
                            &api_url     = "skyblock/auction?uuid=%&filter_vals[%#id_index%]%";
                            &api_data[]  = hypixelAPICall(%&api_url%);
                            req_success := %&api_data[0]%; // True if we received response from API, false if we got throttled by CF.
                            api_success := %&api_data[1]%; // The value of the 'success' key in the API response.
                            #api_code   := %&api_data[2]%; // The HTTP Response Code from the API Request.
                            &api_resp    = %&api_data[3]%; // The raw JSON data returned from the Server.
                            debug_log(%debug%,%&script_debug_name%,"Making API Call to %&api_url%, outcome req %req_success%, outcome api %api_success%, code %#api_code%");
                        endif;
                        
                        // If the API Data Request was successful, set the Auction JSON Match.
                        if((%req_success%) && (%api_success%));
                            &auction_json = jsonget("auctions.0",%&api_resp%);
                            ifnotmatches(%&auction_json%,"^ERROR_");
                                debug_log(%debug%,%&script_debug_name%,"Found Auction");
                                auction_found = true;
                            endif;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Did not get any usable Data from the API!");
                        endif;
                    elseif(%got_owner_id%);
                        // Get the Owner's UUID
                        if(true);
                            &owner_raw_input       = %&filter_vals[%#owner_index%]%;
                            &minecraft_profile[]   = getMinecraftProfile(%&owner_raw_input%);
                            minecraft_profile     := %&minecraft_profile[0]%;
                            &minecraft_username    = %&minecraft_profile[1]%;
                            &minecraft_joint_uuid  = %&minecraft_profile[2]%;
                            &minecraft_split_uuid  = %&minecraft_profile[3]%;
                        endif;
                        if(%minecraft_profile%);
                            // Get the API Data
                            if(true);
                                &filter_vals[%#owner_index%]  = %&minecraft_joint_uuid%;
                                &api_url                      = "skyblock/auction?player=%&minecraft_joint_uuid%";
                                &api_data[]                   = hypixelAPICall(%&api_url%);
                                req_success                  := %&api_data[0]%; // True if we received response from API, false if we got throttled by CF.
                                api_success                  := %&api_data[1]%; // The value of the 'success' key in the API response.
                                #api_code                    := %&api_data[2]%; // The HTTP Response Code from the API Request.
                                &api_resp                     = %&api_data[3]%; // The raw JSON data returned from the Server.
                            endif;
                            
                            // If the API Data Request was successful, iterate over all of the Owner's Auctions looking for a Match against all the Filtered Values.
                            if((%req_success%) && (%api_success%));
                                &decoded_auction_jsons[] = auctionsDecodeListingsData(%&api_resp%);
                                &decoded_status          = %&decoded_auction_jsons[0]%;
                                if(%&decoded_status% != "SUCCESS");
                                    debug_breakpoint(%debug%,%&script_debug_name%,"auctionsDecodeListingsData failed: &4%&decoded_status%&7.");
                                endif;
                                
                                auction_found            = false;
                                no_more_auctions         = false;
                                do;
                                    &auction_json = jsonget("auctions.%#loop_counter%",%&api_resp%);
                                    ifmatches(%&auction_json%,"^ERROR_");
                                        no_more_auctions = true;
                                        break;
                                    endif;
                                    
                                    #get_from_index   = %#loop_counter% + 1;
                                    &decoded_bytes[]  = split("|",%&decoded_auction_jsons[%#get_from_index%]%);
                                    &decoded_sbid     = %&decoded_bytes[0]%;
                                    &decoded_mcid     = %&decoded_bytes[1]%;
                                    &decoded_name     = %&decoded_bytes[2]%;
                                    #decoded_data    := %&decoded_bytes[3]%;
                                    #decoded_stack   := %&decoded_bytes[4]%;
                                    auction_found     = true;
                                    foreach(&filter_keys[],&filter_key,#fki);
                                        &filter_val    = %&filter_vals[%#fki%]%;
                                        &filter_type   = %&filter_type_terms[%#fki%]%;
                                        &filter_prefix = %&filter_type_prefixes[%#fki%]%;
                                        &filter_path   = %&filter_paths[%#fki%]%;
                                        filter_match   = false;
                                        
                                        // Check if the Auction's Data matches what we are filtering for with this Key.
                                        if(true);
                                            // ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK
                                            if(%&filter_path% != "NULL");
                                                &json_value  = xJsonGet(%&filter_path%,%&auction_json%);
                                                &json_value  = strip(%&json_value%);
                                                &json_value  = lcase(%&json_value%);
                                                &filter_val  = strip(%&filter_val%);
                                                &filter_val  = lcase(%&filter_val%);
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "TYPE");
                                                &json_value = jsonget("bin",%&auction_json%);
                                                ifmatches(%&json_value%,"^ERROR_");
                                                    &json_value = "AUCTION";
                                                else;
                                                    &json_value = "BIN";
                                                endif;
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "PRICE");
                                                #highest_bid = xJsonGet("highest_bid_amount",%&auction_json%);
                                                if(%#highest_bid% > 0);
                                                    &json_value = %#highest_bid%;
                                                else;
                                                    &json_value = xJsonGet("starting_bid",%&auction_json%);
                                                endif;
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "BIDS");
                                                &bids_array   = jsonget("bids",%&auction_json%);
                                                &bids_array[] = getjsonasarray(%&bids_array%);
                                                #bids_array   = arraysize(&bids_array[]);
                                                if(%#bids_array% > 1);
                                                    #bids_array = %#bids_array% - 1;
                                                endif;
                                                &json_value  = %#bids_array%;
                                                filter_match = %&filter_val% == %&json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&json_value%&7.");
                                            elseif(%&filter_key% == "ENDED");
                                                claimed_auction       = jsonget("claimed",%&auction_json%);
                                                &first_claimed_bidder = jsonget("claimed_bidders.0",%&auction_json%);
                                                &end_timestamp        = xJsonGet("end",%&auction_json%);
                                                setclipboard(%&auction_json%);
                                                
                                                if(%claimed_auction%);
                                                    debug_log(%debug%,%&script_debug_name%,"claimed_auction == true (%claimed_auction%) from auction_json. on clipboard");
                                                    json_value = true;
                                                elseifnotmatches(%&first_claimed_bidder%,"^ERROR_");
                                                    debug_log(%debug%,%&script_debug_name%,"first_claimed_bidder: &d%&first_claimed_bidder%&7.");
                                                    json_value = true;
                                                else;
                                                    #end_timestamp_rounded = xEval("ceil(%&end_timestamp% / 1000)",true);
                                                    json_value = %TIMESTAMP% >= %#end_timestamp_rounded%;
                                                    if(%json_value%);
                                                        debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) >= end_timestamp_rounded (%#end_timestamp_rounded%)");
                                                    else;
                                                        debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) < end_timestamp_rounded (%#end_timestamp_rounded%)");
                                                    endif;
                                                endif;
                                                
                                                filter_val   := %&filter_val%;
                                                filter_match  = %filter_val% == %json_value%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %filter_val%, have: &8%json_value%&7.");
                                            elseif(%&filter_key% == "SBID");
                                                filter_match  = %&decoded_sbid% == %&filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&decoded_sbid%&7.");
                                            elseif(%&filter_key% == "MCID");
                                                filter_match  = %&decoded_mcid% == %&filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %&filter_val%, have: &8%&decoded_mcid%&7.");
                                            elseif(%&filter_key% == "DATA");
                                                #filter_val  := %&filter_val%;
                                                filter_match  = %#decoded_data% == %#filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %#filter_val%, have: &8%#decoded_data%&7.");
                                            elseif(%&filter_key% == "STACK");
                                                #filter_val  := %&filter_val%;
                                                filter_match  = %#decoded_stack% == %#filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %#filter_val%, have: &8%#decoded_stack%&7.");
                                            elseif(%&filter_key% == "BUYER");
                                                &json_value = jsonget("claimed_bidders",%&auction_json%);
                                                ifnotmatches(%&json_value%,"^ERROR_");
                                                    #buyer_index = 0;
                                                    do;
                                                        &buyer_uuid = jsonget("claimed_bidders.%#buyer_index%",%&auction_json%);
                                                        ifmatches(%&buyer_uuid%,"^ERROR_");
                                                            break;
                                                        endif;
                                                        &buyer_uuids[] = %&buyer_uuid%;
                                                        &json_value    = "ARRAY";
                                                        inc(#buyer_index);
                                                    loop;
                                                else;
                                                    &json_value = "NULL";
                                                endif;
                                                
                                                if((%&json_value% == "NULL") && ((%&filter_val% == "NULL") || (%&filter_val% == "")));
                                                    filter_match = true;
                                                elseif((%&json_value% == "ARRAY") && ((%&filter_val% != "NULL") && (%&filter_val% != "")));
                                                    filter_match = true;
                                                    &split_buyers[] = split("~",%&filter_val%);
                                                    foreach(&split_buyers[],&split_buyer,#sbi);
                                                        #buyer_uuid_index = indexof(&buyer_uuids[],,%&split_buyer%);
                                                        if(%#buyer_uuid_index% == -1);
                                                            debug_error(%debug%,%&script_debug_name%,"cannot find buyer uuid '&4%&split_buyer%&c' in claimed_bidders array!");
                                                            filter_match = false;
                                                            break;
                                                        endif;
                                                    next;
                                                else;
                                                    debug_error(%debug%,%&script_debug_name%,"json_value and filter_val are out of sync (one is ARRAY, other is NULL)");
                                                    filter_match = false;
                                                endif;
                                            elseif(%&filter_key% == "END_TIME");
                                                &json_value  = jsonget("end",%&auction_json%);
                                                #end_ceiling = xEval("ceil(%&json_value% / 1000)",true);
                                                #filter_val := %&filter_val%;
                                                filter_match = %#end_ceiling% == %#filter_val%;
                                                debug_log(%debug%,%&script_debug_name%,"comparing key %&filter_key%, want: %#filter_val%, have: &8%#end_ceiling%&7.");
                                            endif;
                                        
                                            if(!%filter_match%);
                                                debug_log(%debug%,%&script_debug_name%,"auction json at index %#loop_counter% is invalid due to a failed match for key &d%&filter_key%&7!");
                                                auction_found = false;
                                                break;
                                            endif;
                                        endif;
                                    next;
                                    
                                    if(%auction_found%);
                                        break;
                                    endif;
                                    inc(#loop_counter);
                                until((%auction_found%) || (%no_more_auctions%));
                            endif;
                        endif;
                    else;
                        debug_error(%debug%,%&script_debug_name%,"Did not find an ID or OWNER Term in the auction_identifiers[] Array!");
                    endif;
                endif;
                
                if(%auction_found%);
                    // Set Default Values
                    if(true);
                        api_hit       = true;
                        &api_id       = jsonget("uuid",%&auction_json%);
                        &api_type     = "AUCTION";
                        #api_price    = xJsonGet("highest_bid_amount",%&auction_json%);
                        #api_bids     = 0;
                        api_ended     = jsonget("claimed",%&auction_json%);
                        api_claimed   = jsonget("claimed",%&auction_json%);
                        &api_owner    = jsonget("auctioneer",%&auction_json%);
                        &api_profile  = jsonget("profile_id",%&auction_json%);
                        &api_buyer    = jsonget("claimed_bidders",%&auction_json%);
                        &api_end_time = jsonget("end",%&auction_json%);
                        #api_end_time = xEval("ceil(%&api_end_time% / 1000)",true);
                        
                        use_decode_api  = true;
                        if(%use_decode_api%);
                            &decoded_bytes[] = auctionsDecodeItemData(%&auction_json%);
                            &decoded_status  = %&decoded_bytes[0]%;
                            decode_success   = %&decoded_status% == "SUCCESS";
                        endif;
                        
                        if(%decode_success%);
                            &api_sbid   = %&decoded_bytes[1]%;
                            &api_mcid   = %&decoded_bytes[2]%;
                            &api_name   = %&decoded_bytes[3]%;
                            #api_data  := %&decoded_bytes[4]%;
                            #api_stack := %&decoded_bytes[5]%;
                        else;
                            &api_sbid   = "NULL";
                            &api_mcid   = "NULL";
                            &api_name   = jsonget("item_name",%&auction_json%);
                            #api_data   = -1;
                            #api_stack  = -1;
                        endif;
                    endif;
                    
                    // Correct Values from Defaults if Needed
                    if(true);
                        // Correct API Type from Default if Needed
                        if(true);
                            &listing_type = jsonget("bin",%&auction_json%);
                            ifnotmatches(%&listing_type%,"^ERROR_");
                                &api_type = "BIN";
                            endif;
                        endif;
                        
                        // Correct API Price from Default if Needed
                        if(true);
                            if(%#api_price% <= 0);
                                #api_price = xJsonGet("starting_bid",%&auction_json%);
                            endif;
                        endif;
                        
                        // Correct API Bids
                        if(true);
                            &bids_array   = jsonget("bids",%&auction_json%);
                            &bids_array[] = getjsonasarray(%&bids_array%);
                            #bids_array   = arraysize(&bids_array[]);
                            if(%#bids_array% > 1);
                                #bids_array = %#bids_array% - 1;
                            endif;
                            #api_bids = %#bids_array%;
                        endif;
                        
                        // Correct API Ended if Needed
                        if(!%api_ended%);
                            claimed_auction       = jsonget("claimed",%&auction_json%);
                            &first_claimed_bidder = jsonget("claimed_bidders.0",%&auction_json%);
                            &end_timestamp        = xJsonGet("end",%&auction_json%);
                            
                            if(%claimed_auction%);
                                debug_log(%debug%,%&script_debug_name%,"claimed_auction == true (%claimed_auction%) from auction_json. on clipboard");
                                api_ended = true;
                            elseifnotmatches(%&first_claimed_bidder%,"^ERROR_");
                                api_ended(%debug%,%&script_debug_name%,"first_claimed_bidder: &d%&first_claimed_bidder%&7.");
                                api_ended = true;
                            else;
                                #end_timestamp_rounded = xEval("ceil(%&end_timestamp% / 1000)",true);
                                api_ended = %TIMESTAMP% >= %#end_timestamp_rounded%;
                                if(%api_ended%);
                                    debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) >= end_timestamp_rounded (%#end_timestamp_rounded%)");
                                else;
                                    debug_log(%debug%,%&script_debug_name%,"timestamp (%TIMESTAMP%) < end_timestamp_rounded (%#end_timestamp_rounded%)");
                                endif;
                            endif;
                        endif;
                        
                        &api_name = strip(%&api_name%);
                        
                        // Correct API SBID, MCID, DATA, and Stack, if possible.
                        if(!%decode_success%);
                            &nullable_keys[]  = split(", ","SBID, MCID, DATA, STACK");
                            &nullable_vars[]  = split(", ","&api_sbid, &api_mcid, #api_data, #api_stack");
                            &nullable_cache[] = split(", ","&cache_sbid, &cache_mcid, #cache_data, #cache_stack");
                            foreach(&nullable_keys[],&nullable_key,#nki);
                                #nullable_index        = indexof(&filter_keys[],,%&nullable_key%);
                                nullable_found[%#nki%] = %#nullable_index% != -1;
                                if(%#nullable_index% != -1);
                                    set(%&nullable_vars[%#nki%]%,%&filter_vals[%#nullable_index%]%);
                                endif;
                            next;
                            
                            #false_index = indexof(nullable_found[],,false);
                            if(%#false_index% != -1);
                                &cache_data[]  = auctionsCheckCache("ID: %&api_id%");
                                cache_hit     := %&cache_data[0]%;
                                if(%cache_hit%);
                                    &cache_sbid    = %&cache_data[9]%;
                                    &cache_mcid    = %&cache_data[11]%;
                                    #cache_data   := %&cache_data[12]%;
                                    #cache_stack  := %&cache_data[13]%;
                                    foreach(nullable_found[],nullable,#ni);
                                        if(!%nullable%);
                                            &nullable_var   = %&nullable_vars[%#ni%]%;
                                            &nullable_cache = %&nullable_cache[%#ni%]%;
                                            &nullable_val   = %%&nullable_cache%%;
                                            set(%&nullable_var%,%&nullable_val%);
                                        endif;
                                    next;
                                endif;
                            endif;
                        endif;
                        
                        // Correct API Buyer, if possible.
                        if(true);
                            ifnotmatches(%&api_buyer%,"^ERROR_");
                                #buyer_index = 0;
                                do;
                                    &buyer_uuid = jsonget("claimed_bidders.%#buyer_index%",%&auction_json%);
                                    ifmatches(%&buyer_uuid%,"^ERROR_");
                                        break;
                                    endif;
                                    api_buyer_found = true;
                                    &buyer_uuids[]  = %&buyer_uuid%;
                                    inc(#buyer_index);
                                loop;
                            endif;
                            
                            if(%api_buyer_found%);
                                &api_buyer = join("~",&buyer_uuids[]);
                            else;
                                &api_buyer = "NULL";
                            endif;
                        endif;
                    endif;
                    
                    // Setup Return Array
                    if(true);
                        &return_terms[] = split(", ","HIT, ID, TYPE, PRICE, BIDS, ENDED, CLAIMED, OWNER, PROFILE, SBID, NAME, MCID, DATA, STACK, BUYER, END_TIME");
                        #update_index   = indexof(@&cached_listing_id[],,%&api_id%);
                        if(%#update_index% == -1);
                            @&cached_listing_id[] = %&api_id%;
                            #update_index         = indexof(@&cached_listing_id[],,%&api_id%);
                        endif;
                        
                        foreach(&return_terms[],&return_term,#rti);
                            if(%&return_term% != "HIT");
                                #term_index     = indexof(&identifier_prefixes[],,%&return_term%);
                                &term_type      = %&identifier_types[%#term_index%]%;
                                #type_index     = indexof(&map_type_terms[],,%&term_type%);
                                &term_prefix    = %&map_type_prefixes[%#type_index%]%;
                                &term_cache     = lcase("@%&term_prefix%cached_listing_%&return_term%[%#update_index%]");
                                &term_pointer   = lcase("%&term_prefix%api_%&return_term%");
                                &term_value     = %%&term_pointer%%;
                                set(%&term_cache%,%&term_value%);
                            else;
                                &term_value = %api_hit%;
                            endif;
                            &return_array[] = %&term_value%;
                        next;
                    endif;
                else;
                    &return_array[] = false;
                endif;
            else;
                &return_array[] = false;
            endif;
            return(&return_array[]);
        endfunction;
    // auctions/indexAuctions/auctionsIndexSlotData
        // Indexes the Data from the Auction found at the specified Slot.
            // Params:
                // {number} [#listing_item_slot=13]    The Slot to Query for Auction Data (defaults to the Slot where it is found in AUCTION_VIEW GUIs)
                // {boolean} [force=false]             Whether or not to force an update of the Data that is returned from the API.
            // Throws Errors:
                // ERROR_API_LIMIT    Hit an API Limit.
                // ERROR_NOT_FOUND    Auction ID was not found, and/or was not in a valid Auction Listing GUI at time of Function Call.
            // Returns an Array:
                // 0  {boolean} listing_hit          Whether or not an Item from the api was found that matches the specified Auction Identifiers.
                // 1  {string}  &listing_id          The Listing ID
                // 2  {string}  &listing_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #listing_price       The Current Listing Price
                // 4  {number}  #listing_bids        The amount of Bids on the Listing
                // 5  {boolean} listing_ended        Whether or not the Listing has Ended
                // 6  {boolean} listing_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &listing_owner       The UUID of the Player that created this Listing
                // 8  {string}  &listing_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &listing_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &listing_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &listing_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #listing_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #listing_stack       The Stack Size of the Item that this Listing represents
                // 14 {number}  &listing_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #listing_end_time    The Timestamp of when this Auction will end.
            // Example:
                //    &listing_info[]    = auctionsIndexSlotData(%#listing_item_slot%);
                //    listing_hit       := %&listing_info[0]%;
                //    &listing_id        = %&listing_info[1]%;
                //    &listing_type      = %&listing_info[2]%;
                //    #listing_price    := %&listing_info[3]%;
                //    #listing_bids     := %&listing_info[4]%;
                //    listing_ended     := %&listing_info[5]%;
                //    listing_claimed   := %&listing_info[6]%;
                //    &listing_owner     = %&listing_info[7]%;
                //    &listing_profile   = %&listing_info[8]%;
                //    &listing_sbid      = %&listing_info[9]%;
                //    &listing_name      = %&listing_info[10]%;
                //    &listing_mcid      = %&listing_info[11]%;
                //    #listing_data     := %&listing_info[12]%;
                //    #listing_stack    := %&listing_info[13]%;
                //    &listing_buyers    = %&listing_info[14]%;
                //    #listing_end_time := %&listing_info[15]%;
        function auctionsIndexSlotData(#listing_item_slot=13,force=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/indexAuctions.txt:43
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&eauctionsIndexSlotData&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
            endif;
            
            &listing_username_expr = "(?:\[.*?\] )?(\w{3,16})";
            &coins_expr            = "([\d,]+) coins";
            
            do;
                listing_loading = false;
                &listing_item   = getslotitemnbt(%#listing_item_slot%,,#listing_stack,#listing_data,&listing_nbt);
                &listing_nbt    = strip(%&listing_nbt%);
                if(%&listing_item% != "air");
                    ifnotmatches(%&listing_nbt%,"Seller: Refreshing");
                        debug_log(%debug%,%&script_debug_name%,"Trying to get Listing Data from current GUI");
                        if(%CONTAINERNAME% == "Auction View");
                            &auction_identifiers[] = "TYPE: AUCTION";
                        elseif(%CONTAINERNAME% == "BIN Auction View");
                            &auction_identifiers[] = "TYPE: BIN";
                        else;
                            get_type = true;
                        endif;
                        
                        &listing_name = getItemName(%&listing_nbt%,%&listing_item%);
                        &listing_sbid = getItemSBID(%&listing_nbt%);
                        
                        ifmatches(%&listing_nbt%,"Seller: %&listing_username_expr%",&seller_username,1);
                            if(%&seller_username% == "Refreshing");
                                listing_loading = true;
                                setclipboard(%&listing_nbt%);
                                debug_breakpoint(%debug%,%&script_debug_name%,"Breakpoint (seller == 'refreshing') hit!");
                            endif;
                            &auction_identifiers[] = "OWNER: %&seller_username%";
                        endif;
                        
                        &auction_identifiers[] = "MCID: %&listing_item%";
                        &auction_identifiers[] = "STACK: %#listing_stack%";
                        &auction_identifiers[] = "DATA: %#listing_data%";
                        &auction_identifiers[] = "NAME: %&listing_name%";
                        &auction_identifiers[] = "SBID: %&listing_sbid%";
                        
                        ifmatches(%&listing_nbt%,"(?:Top bid|Sold for): %&coins_expr%",&auction_price,1);
                            #auction_price         := regexreplace(&auction_price,",","");
                            &auction_identifiers[]  = "PRICE: %#auction_price%";
                            if(%get_type%);
                                ifmatches(%&listing_nbt%,"Top bid");
                                    get_type               = false;
                                    &auction_identifiers[] = "TYPE: AUCTION";
                                endif;
                            endif;
                        endif;
                        
                        ifmatches(%&listing_nbt%,"Bids: ([\d,]+) bids",&auction_bids,1);
                            #auction_bids          := regexreplace(&auction_bids,",","");
                            &auction_identifiers[]  = "BIDS: %#auction_bids%";
                            if(%get_type%);
                                get_type               = false;
                                &auction_identifiers[] = "TYPE: AUCTION";
                            endif;
                        endif;
                        
                        ifmatches(%&listing_nbt%,"Status: (?:Sold|Ended)!");
                            &auction_identifiers[] = "ENDED: true";
                        else;
                            &auction_identifiers[] = "ENDED: false";
                        endif;
                        
                        if(!%force%);
                            &cache_data[]  = auctionsCheckCache(...&auction_identifiers[]);
                            cache_hit     := %&cache_data[0]%;
                            if(%cache_hit%);
                                return_hit        = true;
                                &return_id        = %&cache_data[1]%;
                                &return_type      = %&cache_data[2]%;
                                #return_price    := %&cache_data[3]%;
                                #return_bids     := %&cache_data[4]%;
                                return_ended     := %&cache_data[5]%;
                                return_claimed   := %&cache_data[6]%;
                                &return_owner     = %&cache_data[7]%;
                                &return_profile   = %&cache_data[8]%;
                                &return_sbid      = %&cache_data[9]%;
                                &return_name      = %&cache_data[10]%;
                                &return_mcid      = %&cache_data[11]%;
                                #return_data     := %&cache_data[12]%;
                                #return_stack    := %&cache_data[13]%;
                                &return_buyers    = %&cache_data[14]%;
                                #return_end_time := %&cache_data[15]%;
                            endif;
                        endif;
                        
                        if(!%cache_hit%);
                            &api_data[]  = auctionsGetListingInfoFromAPI(...&auction_identifiers[]);
                            api_hit     := %&api_data[0]%;
                            if(%api_hit%);
                                return_hit        = true;
                                &return_id        = %&api_data[1]%;
                                &return_type      = %&api_data[2]%;
                                #return_price    := %&api_data[3]%;
                                #return_bids     := %&api_data[4]%;
                                return_ended     := %&api_data[5]%;
                                return_claimed   := %&api_data[6]%;
                                &return_owner     = %&api_data[7]%;
                                &return_profile   = %&api_data[8]%;
                                &return_sbid      = %&api_data[9]%;
                                &return_name      = %&api_data[10]%;
                                &return_mcid      = %&api_data[11]%;
                                #return_data     := %&api_data[12]%;
                                #return_stack    := %&api_data[13]%;
                                &return_buyers    = %&api_data[14]%;
                                #return_end_time := %&api_data[15]%;
                            endif;
                        endif;
                        
                        break;
                    endif;
                else;
                    break;
                endif;
                wait("1t");
            loop;
            
            return(%return_hit%,%&return_id%,%&return_type%,%#return_price%,%#return_bids%,%return_ended%,%return_claimed%,%&return_owner%,%&return_profile%,%&return_sbid%,%&return_name%,%&return_mcid%,%#return_data%,%#return_stack%,%&return_buyers%,%#return_end_time%);
        endfunction;
    // auctions/getListingInfo/auctionsGetListingInfo
        // Given an Auction's ID (or if called while in a Listing GUI), fetches Data regarding that Listing.
            // Params:
                // {string} [&auction_id]     The Auction ID. If omitted, will fetch the Listing found in the Active GUI.
                // {boolean} [force=false]    Whether or not to force an API request. If false, will return values from the Cache
                //                            unless the Data is not yet Cached.
            // Throws Errors:
                // ERROR_API_LIMIT    Hit an API Limit.
                // ERROR_NOT_FOUND    Auction ID was not found, and/or was not in a valid Auction Listing GUI at time of Function Call.
            // Returns an Array:
                // 0  {boolean} listing_hit          Whether or not an Item from the api was found that matches the specified Auction Identifiers.
                // 1  {string}  &listing_id          The Listing ID
                // 2  {string}  &listing_type        The Listing Type (one of: BIN, AUCTION)
                // 3  {number}  #listing_price       The Current Listing Price
                // 4  {number}  #listing_bids        The amount of Bids on the Listing
                // 5  {boolean} listing_ended        Whether or not the Listing has Ended
                // 6  {boolean} listing_claimed      Whether or not the Listing has been claimed
                // 7  {string}  &listing_owner       The UUID of the Player that created this Listing
                // 8  {string}  &listing_profile     The Profile ID the Owner of this Listing was using to create this Listing
                // 9  {string}  &listing_sbid        The SkyBlock ID of the Item that this Listing represents
                // 10 {string}  &listing_name        The Display Name of the Item that this Listing represents
                // 11 {string}  &listing_mcid        The Minecraft Item ID that this Listing represents
                // 12 {number}  #listing_data        The Data Value of the Item that this Listing represents
                // 13 {number}  #listing_stack       The Stack Size of the Item that this Listing represents
                // 14 {number}  &listing_buyers      The UUID(s) of the Player that purchased this Listing, tilde (~) separated, or 'NULL' if no buyers.
                // 15 {number}  #listing_end_time    The Timestamp of when this Auction will end.
            // Example:
                //    &listing_info[]    = auctionsGetListingInfo(%&auction_id%,%force%);
                //    listing_hit       := %&listing_info[0]%;
                //    &listing_id        = %&listing_info[1]%;
                //    &listing_type      = %&listing_info[2]%;
                //    #listing_price    := %&listing_info[3]%;
                //    #listing_bids     := %&listing_info[4]%;
                //    listing_ended     := %&listing_info[5]%;
                //    listing_claimed   := %&listing_info[6]%;
                //    &listing_owner     = %&listing_info[7]%;
                //    &listing_profile   = %&listing_info[8]%;
                //    &listing_sbid      = %&listing_info[9]%;
                //    &listing_name      = %&listing_info[10]%;
                //    &listing_mcid      = %&listing_info[11]%;
                //    #listing_data     := %&listing_info[12]%;
                //    #listing_stack    := %&listing_info[13]%;
                //    &listing_buyers    = %&listing_info[14]%;
                //    #listing_end_time := %&listing_info[15]%;
        function auctionsGetListingInfo(&auction_id,force=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/getListingInfo.txt:964
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9auctionsGetListingInfo&7";
                debug_log(%debug%,%&script_debug_name%,"Getting Listing Info, &&auction_id: '&d%&auction_id%&7'.");
            endif;
            
            // If we were provided with the Auction's ID, attempt to hit Cache with it.
            if(%&auction_id% != "");
                if(!%force%);
                    debug_log(%debug%,%&script_debug_name%,"Checking Cache for &&auction_id");
                    &cache_data[]  = auctionsCheckCache("ID: %&auction_id%");
                    cache_hit     := %&cache_data[0]%;
                    if(%cache_hit%);
                        return_hit        = true;
                        &return_id        = %&cache_data[1]%;
                        &return_type      = %&cache_data[2]%;
                        #return_price    := %&cache_data[3]%;
                        #return_bids     := %&cache_data[4]%;
                        return_ended     := %&cache_data[5]%;
                        return_claimed   := %&cache_data[6]%;
                        &return_owner     = %&cache_data[7]%;
                        &return_profile   = %&cache_data[8]%;
                        &return_sbid      = %&cache_data[9]%;
                        &return_name      = %&cache_data[10]%;
                        &return_mcid      = %&cache_data[11]%;
                        #return_data     := %&cache_data[12]%;
                        #return_stack    := %&cache_data[13]%;
                        &return_buyers    = %&cache_data[14]%;
                        #return_end_time := %&cache_data[15]%;
                    endif;
                else;
                    debug_log(%debug%,%&script_debug_name%,"Skipping cache for &&auction_id (force is true)");
                endif;
                
                if(!%cache_hit%);
                    debug_log(%debug%,%&script_debug_name%,"Did not hit Cache for &&auction_id, hitting API.");
                    &api_data[]       = auctionsGetListingInfoFromAPI("ID: %&auction_id%");
                    api_hit          := %&api_data[0]%;
                    &return_id        = %&api_data[1]%;
                    &return_type      = %&api_data[2]%;
                    #return_price    := %&api_data[3]%;
                    #return_bids     := %&api_data[4]%;
                    return_ended     := %&api_data[5]%;
                    return_claimed   := %&api_data[6]%;
                    &return_owner     = %&api_data[7]%;
                    &return_profile   = %&api_data[8]%;
                    &return_sbid      = %&api_data[9]%;
                    &return_name      = %&api_data[10]%;
                    &return_mcid      = %&api_data[11]%;
                    #return_data     := %&api_data[12]%;
                    #return_stack    := %&api_data[13]%;
                    &return_buyers    = %&api_data[14]%;
                    #return_end_time := %&api_data[15]%;
                    
                    if(%api_hit%);
                        debug_log(%debug%,%&script_debug_name%,"Got a valid hit from API for &&auction_id!");
                        return_hit = true;
                    else;
                        debug_error(%debug%,%&script_debug_name%,"Got no hit for &&auction_id from API, reading out &&api_data[] Array...");
                        &vars[] = split(" ","api_hit &return_id &return_type #return_price #return_bids return_ended return_claimed &return_owner &return_profile &return_sbid &return_name &return_mcid #return_data #return_stack &return_buyers");
                        foreach(&vars[],&var,#v);
                            &val    = "%%&var%%";
                            &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                            &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                            debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
                        next;
                        // debug_breakpoint(%debug%,%&script_debug_name%,"Waiting for review...");
                        debug_error(%debug%,%&script_debug_name%,"Waiting for review...");
                    endif;
                endif;
            endif;
            
            // If we haven't hit anything yet, try to get the Listing Data of whatever GUI we are currently in.
            if(!%return_hit%);
                debug_log(%debug%,%&script_debug_name%,"Haven't hit Cache or API yet, will try to get Data from GUI if we are in a GUI...");
                &listing_username_expr = "(?:\[.*?\] )?(\w{3,16})";
                &coins_expr            = "([\d,]+) coins";
                #listing_item_slot     = 13;
                do;
                    if((%GUI% == "GUICHEST") && ((%CONTAINERNAME% == "Auction View") || (%CONTAINERNAME% == "BIN Auction View")));
                        &listing_item = getslotitemnbt(%#listing_item_slot%,,#listing_stack,#listing_data,&listing_nbt);
                        &listing_nbt  = strip(%&listing_nbt%);
                        if(%&listing_item% != "air");
                            ifnotmatches(%&listing_nbt%,"Seller: Refreshing");
                                &cache_data[]  = auctionsIndexSlotData(%#listing_item_slot%,%force%);
                                debug_log(%debug%,%&script_debug_name%,"got return from auctionsCheckCache");
                                cache_hit     := %&cache_data[0]%;
                                if(%cache_hit%);
                                    return_hit        = true;
                                    &return_id        = %&cache_data[1]%;
                                    &return_type      = %&cache_data[2]%;
                                    #return_price    := %&cache_data[3]%;
                                    #return_bids     := %&cache_data[4]%;
                                    return_ended     := %&cache_data[5]%;
                                    return_claimed   := %&cache_data[6]%;
                                    &return_owner     = %&cache_data[7]%;
                                    &return_profile   = %&cache_data[8]%;
                                    &return_sbid      = %&cache_data[9]%;
                                    &return_name      = %&cache_data[10]%;
                                    &return_mcid      = %&cache_data[11]%;
                                    #return_data     := %&cache_data[12]%;
                                    #return_stack    := %&cache_data[13]%;
                                    &return_buyers    = %&cache_data[14]%;
                                    #return_end_time := %&cache_data[15]%;
                                endif;
                                break;
                            endif;
                        endif;
                    else;
                        break;
                    endif;
                    
                    wait("1t");
                while((%GUI% == "GUICHEST") && ((%CONTAINERNAME% == "Auction View") || (%CONTAINERNAME% == "BIN Auction View")));
            endif;
            
            &return_vars[] = split(", ","return_hit, &return_id, &return_type, #return_price, #return_bids, return_ended, return_claimed, &return_owner, &return_profile, &return_sbid, &return_name, &return_mcid, #return_data, #return_stack, &return_buyers, #return_end_time");
            debug_log(%debug%,%&script_debug_name%,"returning the following array:");
            foreach(&return_vars[],&var,#v);
                &val    = "%%&var%%";
                &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
            next;
            if(%debug%); log(" "); endif;
            
            foreach(&return_vars[],&return_var,#rvi);
                &return_array[%#rvi%] = %%&return_var%%;
            next;
            return(&return_array[]);
        endfunction;
    // tablist/index/getGodPotionExpiryTimestamp
        // Reads the Tab List to find whether or not the Player has a God Potion effect enabled. If so,
        // returns the Seconds Timestamp of when that God Potion will expire. If not, returns -1.
            // Params:
            //      None
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function getGodPotionExpiryTimestamp();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:26
            &time_expression = "You have a God Potion active! (?:(\d+):)?(?:(\d+):)?(?:(\d+))";
            #expiry_ts       = -1;
            foreach("tablist");
                ifmatches(%CLEANLINE%,%&time_expression%);
                    match(%CLEANLINE%,%&time_expression%,{#hours,#minutes,#seconds});
                    #expiry_ts = %TIMESTAMP% + ((#days * 86400) + (#hours * 3600) + (#minutes * 60) + #seconds);
                    log("%#hours% hours, %#minutes% minutes, %#seconds% seconds")
                    break;
                endif;
            next;
            return(#expiry_ts);
        endfunction;
    // tablist/index/getCookieExpiryTimestamp
        // Reads the Tab List to find whether or not the Player has a Booster Cookie effect enabled. If so,
        // returns the Seconds Timestamp of when that Booster Cookie will expire. If not, returns -1.
            // Params:
            //      None
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function getCookieExpiryTimestamp();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:7
            &time_expression = "(?:(\d+)d\s*)?(?:(\d+)h\s*)?(?:(\d+)m\s*)?(?:(\d+)s)";
            #expiry_ts       = -1;
            foreach("tablist");
                ifmatches(%CLEANLINE%,"Cookie Buff\n(.+)",&cookie_buff_time,1);
                    match(%&cookie_buff_time%,%&time_expression%,{#days,#hours,#minutes,#seconds});
                    #expiry_ts = %TIMESTAMP% + ((#days * 86400) + (#hours * 3600) + (#minutes * 60) + #seconds);
                    break;
                endif;
            next;
            return(#expiry_ts);
        endfunction;
    // tablist/index/getEffectExpiryTimestamp
        // Wrapper that dynamically calls getCookieExpiryTimestamp or getGodPotionExpiryTimestamp based on input.
            // Params:
            //      {string} [&type="COOKIE"]   The Effect Type to get the Expiry Timestamp of. One of: 'COOKIE', 'GODPOT'.
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function getEffectExpiryTimestamp(&type="COOKIE");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:73
            &type      = miscValidate(%&type%,0,"COOKIE","GODPOT");
            #expiry_ts = -1;
            if(%&type% == "COOKIE");
                #expiry_ts = getCookieExpiryTimestamp();
            elseif(%&type% == "GODPOT");
                #expiry_ts = getGodPotionExpiryTimestamp();
            endif;
            return(%#expiry_ts%);
        endfunction;
    // tablist/index/isEffectEnabled
        // Wrapper that dynamically calls isCookieEnabled or isGodPotionEnabled based on input.
            // Params:
            //      {string} [&type="COOKIE"]       The Effect Type to get the Expiry Timestamp of. One of: 'COOKIE', 'GODPOT'.
            //      {number} [#expiry_offset_sec=0] An offset in seconds to apply to the real expiry timestamp used
            //                                      to report whether the effect should be considered 'active' or not.
            //                                      For example, if set to 300, if the cookie expires within 300 seconds / 5 min,
            //                                      will return false (when otherwise, it would return true.)
            //
            // Returns the Seconds Timestamp of when the Effect expires, or -1 if the Effect is not active.
        function isEffectEnabled(&type="COOKIE",#expiry_offset_sec=0);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:93
            #effect_expiry_ts = getEffectExpiryTimestamp(%&type%);
            effect_enabled    = %TIMESTAMP% < (#effect_expiry_ts - #expiry_offset_sec);
            return(%effect_enabled%);
        endfunction;
    // gui/index/localGUI
        // Changes the current GUI to a local GUI.
            // Params:
            //      {string} [&target_gui="NONE"]         - The Target GUI to switch to. Can be any of the following strings:
            //                                              "NONE", "GUIINVENTORY", "GUICHAT".
            //      {number} [#wait_ticks=@#def_wait_ticks]- Amount of ticks (1t = 50ms) to wait between each action (press/GUI).
            //
            // Returns a boolean indicating whether or not GUI == <&target_gui> at end of function.
        function localGUI(&target_gui="NONE",#wait_ticks=20);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:11
            &valid_guis[] = split(", ","NONE, GUIINVENTORY, GUICHAT");
            #valid_gui    = indexof(&valid_guis[],,%&target_gui%);
            if(#valid_gui == -1);
                #valid_gui = 0;
            endif;
            &target_gui = ucase(%&valid_guis[%#valid_gui%]%);
            
            do;
                if(%GUI% == %&target_gui%);
                    break;
                elseif(%GUI% != "NONE");
                    press("escape");
                    do(%#wait_ticks%);
                        wait("1t");
                    until(%GUI% == "NONE");
                else;
                    if(%&target_gui% == "GUIINVENTORY");
                        gui("inventory");
                    elseif(%&target_gui% == "GUICHAT");
                        gui("chat");
                    endif;
                    
                    do(%#wait_ticks%);
                        wait("1t");
                    until(%GUI% != "NONE");
                endif;
            until(%GUI% == %&target_gui%);
            return_boolean = %GUI% == %&target_gui%;
            return(%return_boolean%);
        endfunction;
    // auctions/actions/auctionsOpenListing
        // Opens up an Auction Listing GUI given the Auction Listing ID.
            // Params:
                // {string} <&auction_id>        The ID of the Auction Listing to open.
                // {string} [&listing_info[]]    The Array returned by auctionsGetListingInfo, if already called externally. If omitted, will call auctionsGetListingInfo
                //                               with the specified Auction ID.
                // {number} [#tick_wait=20]      Ticks to wait between Interactions.
                // {number} [#timeout_sec=30]    Maximum amount of Seconds the Function can run for before Timing Out. Set to <= 0 to disable timeouts.
            // Returns a String ENUM:
                // SUCCESS              Successfully entered the Auction Listing GUI.
                // ERROR_TIMEOUT        The Function exited early due to a timeout.
                // ERROR_UNAVAILABLE    The Function exited due to the Auction House being closed for some reason (i.e. Derpy is Mayor).
                // ERROR_NOT_FOUND      The Function exited due to not being able to find the Auction (can occur if the Auction ID
                //                      is invalid, or the Function was called with the Auction ID Parameter omitted without a Listing GUI open).
                // ERROR_EXPIRED        The function exited due to the Auction being expired by the time we went to go place the Bid for it.
                // ERROR_UNKNOWN        The function exited due to an unknown Error.
                // ERROR_SERVER         The function exited due to not being able to get onto SkyBlock.
            // Example
            //    &listing_opened = auctionsOpenListing(%&auction_id%,&listing_info[],%#tick_wait%,%#timeout_sec%);
            //    if(%&listing_opened% != "SUCCESS");
            //        if(%&listing_opened% == "ERROR_TIMEOUT");
            //        elseif(%&listing_opened% == "ERROR_UNAVAILABLE");
            //        elseif(%&listing_opened% == "ERROR_NOT_FOUND");
            //        elseif(%&listing_opened% == "ERROR_EXPIRED");
            //        elseif(%&listing_opened% == "ERROR_UNKNOWN");
            //        elseif(%&listing_opened% == "ERROR_SERVER");
            //        endif;
            //    endif;
        function auctionsOpenListing(&auction_id,&listing_info[],#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/actions.txt:28
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6auctionsOpenListing&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &enum_success      = "SUCCESS";
                &enum_timeout      = "ERROR_TIMEOUT";
                &enum_unavailable  = "ERROR_UNAVAILABLE";
                &enum_not_found    = "ERROR_NOT_FOUND";
                &enum_expired      = "ERROR_EXPIRED";
                &enum_unknown      = "ERROR_UNKNOWN";
                &enum_server       = "ERROR_SERVER";
                
                // Check if the Auction House is closed
                if(%TIMESTAMP% < %@#ah_closed_timestamp%);
                    debug_error(%debug%,%&script_debug_name%,"Auction House is currently closed, cannot place bids!");
                    &return_string = %&enum_unavailable%;
                    break;
                endif;
                
                // Get Auction Listing Info
                if(true);
                    #listing_info_sz = arraysize(&listing_info[]);
                    if(%#listing_info_sz% == 0);
                        &listing_info[] = auctionsGetListingInfo(%&auction_id%);
                    endif;
                    listing_hit      := %&listing_info[0]%;
                    &listing_id       = %&listing_info[1]%;
                    &listing_type     = %&listing_info[2]%;
                    #listing_price   := %&listing_info[3]%;
                    #listing_bids    := %&listing_info[4]%;
                    listing_ended    := %&listing_info[5]%;
                    listing_claimed  := %&listing_info[6]%;
                    &listing_owner    = %&listing_info[7]%;
                    &listing_profile  = %&listing_info[8]%;
                    &listing_sbid     = %&listing_info[9]%;
                    &listing_name     = %&listing_info[10]%;
                    &listing_mcid     = %&listing_info[11]%;
                    #listing_data    := %&listing_info[12]%;
                    #listing_stack   := %&listing_info[13]%;
                    &listing_buyers   = %&listing_info[14]%;
                    
                    if(!%listing_hit%);
                        debug_error(%debug%,%&script_debug_name%,"Failed to get Listing Info for ID: &d%&auction_id%&7.");
                        return(%&enum_not_found%);
                    endif;
                    
                    &listing_gui = "Auction View";
                    if(%&listing_type% == "BIN");
                        &listing_gui = "BIN Auction View";
                    endif;
                endif;
            endif;
            
            // Loop Actions until we are in the Auctions GUI.
            if(true);
                &init_unset_pointers[] = split(", ","@cannot_use_ah, @auction_house_error, @ah_failure, @&ah_failure_string");
                &fail_pointers[]       = split(", ","@ah_failure, @cannot_use_ah, @auction_house_error");
                foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                    unset(%&init_unset_pointer%);
                next;
                
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Check if we are in the correct GUI.
                    if(true);
                        if((%GUI% == "GUICHEST") && (%CONTAINERNAME% == %&listing_gui%));
                            // 2a. Get the Listing GUI Data and compare to Initial Listing Variables.
                            if(true);
                                &current_info[]  = auctionsGetListingInfo();
                                current_hit     := %&current_info[0]%;
                                &current_id      = %&current_info[1]%;
                                if((%current_hit%) && (%&current_id% == %&auction_id%));
                                    debug_log(%debug%,%&script_debug_name%,"Got into correct Listing GUI.");
                                    &return_string = %&enum_success%;
                                    break;
                                endif;
                            endif;
                        endif;
                        
                        // 2b. If we haven't already broken above, we are in an invalid GUI. Exit any GUIs we might be in and try to get into the correct one.
                        can_do_action = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                        if(%can_do_action%);
                            if(%GUI% != "NONE");
                                localGUI("NONE");
                            endif;
                            
                            // 2c.    Get onto SkyBlock. If we have a Booster Cookie active, then we can use the /viewauction command regardless of where we are on SB.
                            //        If we do not have the Booster Cookie active, we need to make sure that we are on a SKYBLOCK_HUB server in order to use the /viewauction command.
                            if(true);
                                #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                on_skyblock        = gotoServer("SKYBLOCK",%#tick_wait%,%#recursive_timeout%);
                                if(!%on_skyblock%);
                                    debug_error(%debug%,%&script_debug_name%,"Not on a SkyBlock Server!");
                                    &return_string = %&enum_server%;
                                    break;
                                endif;
                                
                                cookie_active = isEffectEnabled("COOKIE",%#timeout_sec%);
                                if(!%cookie_active%);
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    on_skyblock        = gotoServer("SKYBLOCK_HUB",%#tick_wait%,%#recursive_timeout%);
                                    if(!%on_skyblock%);
                                        debug_error(%debug%,%&script_debug_name%,"Failed to get onto a SkyBlock Hub Server.");
                                        &return_string = %&enum_server%;
                                        break;
                                    endif;
                                endif;
                            endif;
                            
                            // 2d.    If we made it to this point, we are on a SkyBlock Server and we can use the /viewauction <auction_id> command. Do so.
                            echo("/viewauction %&auction_id%");
                        endif;
                    endif;
                    
                    // 3. Check if Chat Filter has returned a Failure
                    if(true);
                        for(action_loop,0,1);
                            if(!%action_loop%);
                                // 3b. Check if the Auction House is now closed
                                if(%TIMESTAMP% < %@#ah_closed_timestamp%);
                                    debug_error(%debug%,%&script_debug_name%,"Auction House is currently closed, cannot place bids!");
                                    &return_string = %&enum_unavailable%;
                                    break;
                                endif;
                                
                                unset(&failed_pointers[]);
                                unset(&string_pointers[]);
                                failed_pointer  = false;
                                &failure_string = %@&ah_failure_string%;
                                
                                foreach(&fail_pointers[],&fail_pointer,#fp);
                                    fail_value    := "%%&fail_pointer%%";
                                    &safe_pointer  = regexreplace(&fail_pointer,"(?<!&)&\w","&$1");
                                    &push_string   = "&7%&safe_pointer%&7: '&8false&7'";
                                    if(%fail_value%);
                                        failed_pointer     = true;
                                        &failed_pointers[] = %&fail_if_set_pointer%;
                                        &push_string       = "&7%&safe_pointer%&7: '&4true&7'";
                                    endif;
                                    
                                    &string_pointers[] = %&push_string%;
                                next;
                            elseif(%failed_pointer%);
                                &error_type                = "UNKNOWN";    // UNKNOWN, INVALID_AUCTION, INVALID_BID
                                &error_action              = "RETRY";      // CANCEL, RETRY
                                &string_pointers           = join(", ",&string_pointers[]);
                                #cannot_use_ah_index       = indexof(&failed_pointers[],,"@cannot_use_ah");
                                #auction_house_error_index = indexof(&failed_pointers[],,"@auction_house_error");
                                #ah_failure_index          = indexof(&failed_pointers[],,"@ah_failure");
                                debug_error(%debug%,%&script_debug_name%,"a failure pointer is set! Pointer values: %&string_pointers%");
                                
                                if(%#ah_failure_index% != -1);
                                    // ifmatches(%&failure_string%,"There was an error with the auction house!.*(?:Error: |\()(?<auctionErrorCode>\w+)(?:\.|\))$",&failure_code,1);
                                    ifmatches(%&failure_string%,"(?:Failed to claim bid!|There was an error with the auction house!).*?(?:Error: |\()(\w+)(?:\.|\))",&failure_code,1);
                                        if((%&failure_code% == "NOT_FOUND_OR_ALREADY_CLAIMED") || (%&failure_code% == "AUCTION_EXPIRED_OR_NOT_FOUND"));
                                            // Auction is no longer valid
                                            &error_type   = "INVALID_AUCTION";
                                            &error_action = "CANCEL";
                                            debug_log(%debug%,%&script_debug_name%,"failure_code is '&4%&failure_code%&7', Auction is invalid. Will cancel.");
                                        else;
                                            debug_error(%debug%,%&script_debug_name%,"Unknown Error Code: '&4%&failure_code%&c'! Will do recursive call to self.");
                                            logto("ah_unknown_error_codes.txt","[%DATETIME%]: Error Code '%&failure_code%', Error String %&failure_string%");
                                            &error_type   = "UNKNOWN";
                                            &error_action = "RETRY";
                                        endif;
                                    elseifmatches(%&failure_string%,"There was an error with the auction house!");
                                        // Generic Error, cannot know what went wrong.
                                        &error_action = "RETRY";
                                        &error_type   = "UNKNOWN";
                                        debug_error(%debug%,%&script_debug_name%,"Generic Error: '&4%&failure_string%&c'! Will do recursive call to self.");
                                    elseifmatches(%&failure_string%,"You didn't participate in this auction!");
                                        // Auction is no longer valid.
                                        &error_type   = "INVALID_AUCTION";
                                        &error_action = "CANCEL";
                                        debug_log(%debug%,%&script_debug_name%,"Failure string is '&4%&failure_string%&7', Auction is Invalid. Will cancel.");
                                    elseifmatches(%&failure_string%,"(?:Invalid auction ID!|This auction wasn't found!|This player doesn't have any active auctions!)");
                                        // Auction is invalid
                                        &error_type   = "INVALID_AUCTION";
                                        &error_action = "CANCEL";
                                    endif;
                                elseif(%#cannot_use_ah_index% != -1);
                                    debug_error(%debug%,%&script_debug_name%,"Error type is '&4@cannot_use_ah&c', will try to change Servers and if successful, will do recursive call to self.");
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    &swap_result       = swapServers(%#tick_wait%,%#recursive_timeout%);
                                    
                                    if(%&swap_result% != "SUCCESS");
                                        debug_error(%debug%,%&script_debug_name%,"swapServers returned error '&4%&swap_result%&c', will return this error code.");
                                        &return_string = %&swap_result%;
                                        &error_action  = "CANCEL";
                                    else;
                                        &error_action  = "RETRY";
                                        debug_log(%debug%,%&script_debug_name%,"swapServers completed successfully. Will do recursive call to self.");
                                    endif;
                                elseif(%#auction_house_error_index% != -1);
                                    // Might just have to try again
                                    debug_error(%debug%,%&script_debug_name%,"An auction house error occurred. Will do recursive call to self.");
                                endif;
                                
                                debug_error(%debug%,%&script_debug_name%,"Error Action: '&e%&error_action%&c'. Error Type: '&4%&error_type%&c'. Error String: '&4%&failure_string%&c'.");
                                if((%&return_string% == "") && (%&error_action% == "CANCEL"));
                                    &error_enum_map_terms[]    = split(", ","UNKNOWN, INVALID_AUCTION");
                                    &error_enum_map_enums[]    = split(", ","%&enum_unknown%, %&enum_expired%");
                                    #error_enum_map_term_index = indexof(&error_enum_map_terms[],,%&error_type%);
                                    &return_string             = %&error_enum_map_terms[%#error_enum_map_term_index%]%;
                                    debug_log(%debug%,%&script_debug_name%,"will return error_enum '&4%&return_string%&7' due to encountering error_type '&4%&error_type%&7' with CANCEL action");
                                elseif(%&error_action% == "RETRY");
                                    debug_log(%debug%,%&script_debug_name%,"running self-recursion call, error_action is RETRY, type is '&4%&error_type%&7'.");
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    &return_string     = call("auctionsOpenListing",%&auction_id%,&listing_info[],%#tick_wait%,%#recursive_timeout%);
                                    debug_log(%debug%,%&script_debug_name%,"got return_string '&e%&return_string%&7' from recursion call, breaking");
                                endif;
                            endif;
                        next;
                        
                        if(%&return_string% != "");
                            break;
                        endif;
                    endif;
                    
                    wait("1t");
                    inc(#waited_ticks);
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"returning '&e%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // gui/index/decodeContainerString
        // Decodes a Container String into an Array of it's components.
            // Params:
            //      {string} <&container_string>    A container string generated by getContainerString
            //
            // Returns an Array:
            //  0 {string} &container_gui   The string value of "%GUI%" from the Container String
            //  1 {string} &container_name  The string value of "%CONTAINERNAME%" from the Container String
            //  2 {number} #container_slots The number value of "%CONTAINERSLOTS%" from the Container String
            //
            // If the Container String holds NBT Item Data, elements 3, ... are the ENCODED NBT strings.
            //
        function decodeContainerString(&container_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:358
            &decoded_string = decode(%&container_string%);
            &decoded_vars[] = split("$",%&decoded_string%);
            #decoded_length = arraysize(&decoded_vars[]);
            
            &decoded_data[] = split("|",%&decoded_vars[0]%);
            if(%#decoded_length% > 1);
                &encoded_nbt[] = split("~",%&decoded_vars[1]%);
                push(&decoded_data[],&encoded_nbt[*]);
            endif;
            return(&decoded_data[]);
        endfunction;
    // gui/index/getContainerString
        // Encodes the current values of GUI, CONTAINERNAME, CONTAINERSLOTS, and optionally Slot Data from each slot in the Container
        // into a string using encode(). Used to check if the GUI has updated.
            // Params:
            //      {boolean} [include_items=false] If true, will call indexGUI and append it's data to the Container String.
            //
            // Returns a string encoded with encode() in format 'GUI|CONTAINERNAME|CONTAINERSLOTS[$<slot_nbt>~<slot_nbt>~<...>]'.
            // The [$<slot_nbt>~<slot_nbt>~<...>] portion is only included if [include_items] is true.
        function getContainerString(include_items=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:274
            &env_var_str = "%GUI%|%CONTAINERNAME%|%CONTAINERSLOTS%";
            if(%include_items%);
                if(%CONTAINERSLOTS% > 0);
                    #container_start = 0;
                    #container_end   = %CONTAINERSLOTS% - 37;
                    #inventory_start = %CONTAINERSLOTS% - 36;
                    #inventory_end   = %CONTAINERSLOTS% - 1;
                    #range_start     = %#container_start%;
                    #range_end       = %#inventory_end%;
                    for(#slot,%#range_start%,%#range_end%);
                        &f_item     = getslotitemnbt(%#slot%,,#f_stack,#f_data,&f_nbt);
                        &f_nbt      = strip(%&f_nbt%);
                        &f_nbt      = encode(%&f_nbt%);
                        &out_data[] = "%&f_item%|%#f_stack%|%#f_data%|%&f_nbt%";
                    next;
                endif;
                &gui_items   = join("~",&out_data[]);
                &env_var_str = "%&env_var_str%$%&gui_items%";
            endif;
            &return_string = encode(%&env_var_str%);
            return(%&return_string%);
        endfunction;
    // gui/index/enteredNewGUI
        // Checks if we are in a new GUI by comparing the <&init_container_string> to the current Container String returned by getContainerString.
            // Params:
            //      {string} <&init_container_string>   A Container String generated when we were on the Initial GUI that we want to check for an Update from.
            //      {boolean} [include_items=false]     Set this to true if [include_items] was used on the Initial call to getContainerString.
            //
            // Returns a boolean indicating whether or not the GUI has changed.
        function enteredNewGUI(&init_container_string,include_items=false,allow_mouse_full=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:304
            &mouse_item = getmouseitem(,#mouse_stack,#mouse_data,&mouse_nbt);
            if((%&mouse_item% != "air") && (!%allow_mouse_full%));
                return(False);
            endif;
            
            &mouse_nbt             = strip(%&mouse_nbt%);
            &mouse_nbt             = encode(%&mouse_nbt%);
            &curr_container_string = getContainerString(%include_items%);
            if(&curr_container_string != &init_container_string);
                if(%include_items%);
                    &init_data[] = call("decodeContainerString",%&init_container_string%);
                    &curr_data[] = call("decodeContainerString",%&curr_container_string%);
                    foreach(&init_data[],&init_data,#dei);
                        &curr_data = %&curr_data[%#dei%]%;
                        if(%&curr_data% != %&init_data%);
                            if(%#dei% <= 2);
                                return_boolean = True;
                                break;
                            else;
                                &init_data_arr[] = split("|",%&init_data%);
                                &init_data_item  = %&init_data_arr[0]%;
                                &init_data_nbt   = %&init_data_arr[3]%;
                                &curr_data_arr[] = split("|",%&curr_data%);
                                &curr_data_item  = %&curr_data_arr[0]%;
                                &curr_data_nbt   = %&curr_data_arr[3]%;
                                mouse_match      = (((%&init_data_item% == "air") && (%&mouse_nbt% == %&curr_data_nbt%)) || ((%&curr_data_item% == "air") && (%&mouse_nbt% == %&init_data_nbt%)));
                                
                                if(!%mouse_match%);
                                    return_boolean = True;
                                    break;
                                endif;
                            endif;
                        endif;
                    next;
                    return(%return_boolean%);
                endif;
                
                return(True);
            endif;
            return(False);
        endfunction;
    // info/index/getItemUUID
        // Given the NBT Data of an Item, extracts the Item's UUID from the NBT Data.
            // Params:
            //      {string} <&nbt> The NBT Data to extract the Item UUID from.
            //
            // Returns the Item's UUID, or an empty string if one is not found.
        function getItemUUID(&nbt);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:92
            &nbt           = strip(%&nbt%);
            &return_string = _matchExpressionNBT(%&nbt%,"uuid:\"(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})\"");
            return(%&return_string%);
        endfunction;
    // string/index/regexEscape
        // string/index.txt
        // Counts occurences of a given string within another string.
            // Params:
            //        <string> &source_string : The string to count occurences of &search_string in.
            //        <string> &search_string : The string to count occurences of.
            //
            // Returns the integer amount of occurences found.
        function countOccurencesInString(&source_string,&search_string);
            &script_debug_name  = "&9countOccurencesInString&7";
            debug               = false;
            ifcontains(%&source_string%,%&search_string%);
                &split_source_arr[] = split(%&search_string%,%&source_string%);
                #occurences         = arraysize(&split_source_arr[]);
                if(%#occurences% == 0); // source string exclusively held repetitions of the search string
                    #source_length = strlen(%&source_string%);
                    #search_length = strlen(%&search_string%);
                    #occurences    = %#source_length% / %#search_length%;
                endif;
            endif;
            return(%#occurences%);
        endfunction;
        
        // Checks if a string matches UUID regex.
            // Params:
            //        <string> &check_string : The string to check
            //
            // Returns a boolean.
            //
        function isStringUUID(&check_string);
            &script_debug_name = "&9isStringUUID&7";
            debug              = false;
            &split_uuid_expr   = "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$";
            &joint_uuid_expr   = "^[a-f0-9]{32}$";
            &uuid_exprs[]      = split(", ","%&split_uuid_expr%, %&joint_uuid_expr%");
            foreach(&uuid_exprs[],&uuid_expr);
                ifmatches(%&check_string%,%&uuid_expr%);
                    match_found = true;
                    break;
                endif;
            next;
            return(%match_found%);
        endfunction;
        
        // Checks if a string matches Boolean regex
            // Params:
                // {string} <&check_string>    The String to Check
            // Returns a Boolean
        function isStringBoolean(&check_string);
            &check_string_lcase = lcase(%&check_string%);
            &boolean_values[]   = split(", ","true, false, 1, 0");
            return_boolean      = arrayincludes(&boolean_values[],%&check_string_lcase%);
            return(%return_boolean%);
        endfunction;
        
        // Checks if a String is a valid Integer.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Integer.
        function isStringInteger(&check_string);
            ifmatches(%&check_string%,"^[0-9-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
        
        // Checks if a String is a valid Float (without commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringFloat(&check_string);
            ifmatches(%&check_string%,"^[0-9-]*\.[0-9]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
        
        // Checks if a String is a valid Float/Number (with commas).
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Formatted Number.
        function isStringFormattedNumber(&check_string);
            ifmatches(%&check_string%,"^[\d-]+,[\d.,-]+$");
                bool = true
            endif;
            return(%bool%);
        endfunction;
        
        // Checks if a String is a valid Number, coercable to a Float of some sort.
            // Params:
                // {string} <&check_string> The String to Check
            // Returns a Boolean indicating whether or not the String can be coerced to a valid Float.
        function isStringNumber(&check_string);
            &call_functions[] = split(", ","isStringInteger, isStringFloat, isStringFormattedNumber");
            foreach(&call_functions[],&call_function,#cfi);
                if(%&call_function% == "isStringInteger");
                    return_boolean = isStringInteger(%&check_string%);
                elseif(%&call_function% == "isStringFloat");
                    return_boolean = isStringFloat(%&check_string%);
                elseif(%&call_function% == "isStringFormattedNumber");
                    return_boolean = isStringFormattedNumber(%&check_string%);
                endif;
                if(%return_boolean%);
                    break;
                endif;
            next;
            return(%return_boolean%);
        endfunction;
        
        // Coerces a given String to a Number (no decimal points).
            // Params:
                // {string} <&convert_string>    The String to Convert.
                // {number} [#precision=0]       Decimal Precision
            // Returns the Number result of the coercion.
        function stringToNumber(&convert_string,#precision=0);
            #convert_number = coerceNumber(%&convert_string%);
            return(%#convert_number%);
        endfunction;
        
        function isStringBoolean(&check_string);
            if(%&check_string% == "");
                return_boolean = true;
            else;
                &boolean_coercable[] = split(", ","0, 1, true, false, True, False");
                #boolean_index       = indexof(&boolean_coercable[],,%&check_string%);
                return_boolean       = %#boolean_index% != -1;
            endif;
            return(%return_boolean%);
        endfunction;
        
        function stringToBoolean(&convert_string);
            is_coercable = isStringBoolean(%&convert_string%);
            if(%is_coercable%);
                return_boolean := %&convert_string%;
            elseifmatches(%&convert_string%,"\S");
                return_boolean  = true;
            else;
                return_boolean  = false;
            endif;
            return(%return_boolean%);
        endfunction;
        
        function regexEscape(&input_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/string/index.txt:141
            &split_array[]  = split("\\",%&input_string%);
            foreach(&split_array[],&curr_char,#curr_index);
                if(%&curr_char% == "\\");
                    #last_index = #curr_index - 1;
                    #next_index = #curr_index + 1;
                    &last_char  = %&split_array[%#last_index%]%;
                    &next_char  = %&split_array[%#next_index%]%;
                    
                    // If this backslash is escaped already (last char == '\'), then we do not need to escape this char.
                    // If the backslash is escaping another backslash (next char == '\'), then we do not need to escape this char.
                    if((%&last_char% != "\\") && (%&next_char% != "\\"));
                        &rejoin_array[] = "\\";
                    endif;
                    &rejoin_array[] = %&curr_char%;
                else;
                    &rejoin_array[] = %&curr_char%;
                endif;
            next;
            &rejoint_string = join("",&rejoin_array[]);
            &search_string  = "(?<!\\\\)(?:\+|\*|\?|\^|\$|\.|\[|\]|\{|\}|\(|\)|\||\/)";
            &escaped_string = regexreplace(&rejoint_string,%&search_string%,"\\\$0");
            return(%&escaped_string%);
        endfunction;
    // gui/index/findItemContainer
        // Given any (or all, or any mix of) an Item's MCID, Name, SBID, and/or UUID, finds the Item in the Container and returns it's Slot.
            // Params:
                // {string} [...&filter_params[]]    An Array of Strings in format: [<PARAM_ENUM>: <FILTER>], where PARAM_ENUM can be any of:
                //                                   MCID|ITEM, DATA, STACK, NAME, SBID, NBT, or UUID. <FILTER> can be a Regular Expression or an Exact String.
                //                                   If Passing an Expression, prefix the Filter with 'r$'. All characters following the 'r$' will be used
                //                                   as the Expression.
                // {boolean} [return_arr=false]      If set to True, will return an Array of Slots matching the specified Filters. If set to False, will
                //                                   return the first Slot ID found that matches the Filters.
            // Returns the Slot ID(s) of the Item(s) found, or -1 if no Item(s) could be found. Will return -1 if CONTAINERSLOTS <= 0.
        function findItemContainer(return_arr=false,...&filter_params[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:1092
            #return_val = -1;
            
            // Setup Filter Parameters
            if(true);
                &valid_enums[] = split(", ","MCID, ITEM, DATA, STACK, NAME, SBID, UUID, NBT, SLOT");
                foreach(&filter_params[],&filter_param,#fpi);
                    ifmatches(%&filter_param%,"^(.+?):\s*(.+)$");
                        match(%&filter_param%,"^(.+?):\s*(.+)$",{&param_enum,&param_filter});
                        #enum_index = indexof(&valid_enums[],,%&param_enum%);
                        if(%#enum_index% != -1);
                            &param_enum = %&valid_enums[%#enum_index%]%;
                            if(%&param_enum% == "SLOT");
                                #prioritize_slot   = coerceNumber(%&param_filter%);
                                #prioritized_index = indexof(#prioritized_slots[],,%#prioritize_slot%);
                                if(%#prioritized_index% == -1);
                                    #prioritized_slots[] = %#prioritize_slot%;
                                endif;
                            else;
                                if(%&param_enum% == "ITEM");
                                    &param_enum = "MCID";
                                endif;
                                
                                ifmatches(%&param_filter%,"^r\$(.+)",&param_expression,1);
                                    &param_filter = %&param_expression%;
                                else;
                                    &param_filter = regexEscape(%&param_filter%);
                                    &param_filter = "^%&param_filter%$";
                                endif;
                                
                                &enum_array = lcase("&%&param_enum%_regex[]");
                                &enum_bool  = lcase("do_%&param_enum%");
                                push(%&enum_array%,%&param_filter%);
                                set(%&enum_bool%);
                            endif;
                        endif;
                    endif;
                next;
                
                foreach(&valid_enums[],&valid_enum);
                    if((%&valid_enum% != "SLOT") && (&valid_enum% != "ITEM"));
                        &enum_bool = lcase("do_%&valid_enum%");
                        enum_bool := "%%&enum_bool%%";
                        if(%enum_bool%);
                            &enum_array = lcase("&%&valid_enum%_regex[]");
                            &enum_value = join("|",%&enum_array%);
                            &enum_value = "(?:%&enum_value%)";
                            &enum_regex = lcase("&%&valid_enum%_regex");
                            set(%&enum_regex%,%&enum_value%);
                        endif;
                    endif;
                next;
                
                //    Array Name        |    Boolean Name    |    Regex String
                //    &mcid_regex[]     |    do_mcid         |    &mcid_regex
                //    &data_regex[]     |    do_data         |    &data_regex
                //    &stack_regex[]    |    do_stack        |    &stack_regex
                //    &name_regex[]     |    do_name         |    &name_regex
                //    &sbid_regex[]     |    do_sbid         |    &sbid_regex
                //    &uuid_regex[]     |    do_uuid         |    &uuid_regex
                //    &nbt_regex[]      |    do_nbt          |    &nbt_regex
            endif;
            
            // Iterate over Inventory Slots
            if(%CONTAINERSLOTS% >= 1);
                #r_start            = 0;
                #r_end              = %CONTAINERSLOTS% - 37;
                &r_filter[]         = split(", ","mcid, data, stack, name, sbid, uuid, nbt");
                
                #prioritize_slot_sz = arraysize(#prioritize_slot[]);
                if(%#prioritize_slot_sz% >= 1);
                    foreach(#prioritize_slot[],#prioritize_slot,#ps);
                        &f_mcid = getslotitemnbt(%#prioritize_slot%,,&f_stack,&f_data,&f_nbt);
                        &f_nbt  = strip(%&f_nbt%);
                        f_valid = true;
                        foreach(&r_filter[],&r_term,#rti);
                            &f_bool  = "do_%&r_term%";
                            f_bool  := "%%&f_bool%%";
                            if(%f_bool%);
                                if(%#rti% >= 3);
                                    if(%&r_term% == "name");
                                        &f_value = getItemName(%&f_nbt%,%&f_mcid%);
                                    elseif(%&r_term% == "sbid");
                                        &f_value = getItemSBID(%&f_nbt%);
                                    elseif(%&r_term% == "uuid");
                                        &f_value = getItemUUID(%&f_nbt%);
                                    elseif(%&r_term% == "nbt");
                                        &f_value = %&f_nbt%;
                                    endif;
                                else;
                                    &f_value = "&f_%&r_term%";
                                    &f_value = "%%&f_value%%";
                                endif;
                                &f_regex = "&%&r_term%_regex";
                                &f_regex = "%%&f_regex%%";
                                ifnotmatches(%&f_value%,%&f_regex%);
                                    // log("Term %&r_term% > No match between value %&f_value% and expression %&f_regex%");
                                    f_valid = false;
                                    break;
                                endif;
                            endif;
                        next;
                        
                        if(%f_valid%);
                            if(!%return_arr%);
                                #return_val = %#f_slot%;
                                break;
                            endif;
                            #return_val[] = %#f_slot%;
                        endif;
                    next;
                endif;
                for(#f_slot,%#r_start%,%#r_end%);
                    &f_mcid = getslotitemnbt(%#f_slot%,,&f_stack,&f_data,&f_nbt);
                    &f_nbt  = strip(%&f_nbt%);
                    f_valid = true;
                    foreach(&r_filter[],&r_term,#rti);
                        &f_bool  = "do_%&r_term%";
                        f_bool  := "%%&f_bool%%";
                        if(%f_bool%);
                            if(%#rti% >= 3);
                                if(%&r_term% == "name");
                                    &f_value = getItemName(%&f_nbt%,%&f_mcid%);
                                elseif(%&r_term% == "sbid");
                                    &f_value = getItemSBID(%&f_nbt%);
                                elseif(%&r_term% == "uuid");
                                    &f_value = getItemUUID(%&f_nbt%);
                                elseif(%&r_term% == "nbt");
                                    &f_value = %&f_nbt%;
                                endif;
                            else;
                                &f_value = "&f_%&r_term%";
                                &f_value = "%%&f_value%%";
                            endif;
                            &f_regex = "&%&r_term%_regex";
                            &f_regex = "%%&f_regex%%";
                            ifnotmatches(%&f_value%,%&f_regex%);
                                // log("Term %&r_term% > No match between value %&f_value% and expression %&f_regex%");
                                f_valid = false;
                                break;
                            endif;
                        endif;
                    next;
                    
                    if(%f_valid%);
                        if(!%return_arr%);
                            #return_val = %#f_slot%;
                            break;
                        elseif(%#prioritize_slot_sz% <= 0);
                            #return_val[] = %#f_slot%;
                        else;
                            #return_index = indexof(#return_val[],,%#f_slot%);
                            if(%#return_index% == -1);
                                #return_val[] = %#f_slot%;
                            endif;
                        endif;
                    endif;
                next;
            endif;
            
            if(%return_arr%);
                #return_val_sz = arraysize(#return_val[]);
                if(%#return_val_sz% == 0);
                    #return_val[] = -1;
                endif;
                return(#return_val[]);
            endif;
            return(%#return_val%);
        endfunction;
    // auctions/collect/auctionsCollectListing
        // Given any number of an Auction's Identifiers, finds an Auction that matches the specified Identifiers and collects it.
            // Params:
                // {number} [#tick_wait=20]                Amount of Ticks to wait between repeated Actions. Passed along to called Functions.
                // {number} [#timeout_sec=30]              Amount of Seconds Function can run for before timing out and returning an Error.
                // {string} <...&auction_identifiers[]>    An Array of Auction Identifiers in format: '<ID_TYPE>: <ID_DATA>'. If multiple instances of a given
                //                                         ID_TYPE are encountered, the one that appears latest in the Array is used. Valid ID_TYPE Prefixes are
                //                                         at the end of this Comment.
            // Valid ID_TYPE Prefixes:
                // {string} ID          The Listing ID
                // {string} TYPE        The Listing Type (one of: BIN, AUCTION)
                // {number} PRICE       The Current Listing Price
                // {number} BIDS        The amount of Bids on the Listing
                // {boolean} ENDED      Whether or not the Listing has Ended
                // {boolean} CLAIMED    Whether or not the Listing has been claimed
                // {string} OWNER       The UUID of the Player that created this Listing
                // {string} PROFILE     The Profile ID the Owner of this Listing was using to create this Listing
                // {string} SBID        The SkyBlock ID of the Item that this Listing represents
                // {string} NAME        The Display Name of the Item that this Listing represents
                // {string} MCID        The Minecraft Item ID that this Listing represents
                // {number} DATA        The Data Value of the Item that this Listing represents
                // {number} STACK       The Stack Size of the Item that this Listing represents
                // {string} BUYER       A UUID(s) of a Player who purchased/claimed this Listing. If giving multiple, join them with ~.
            // Returns a String ENUM:
                // SUCCESS                The Function executed as expected and was successful.
                // ERROR_TIMEOUT          Exited early due to a timeout.
                // ERROR_UNAVAILABLE      Auction House was closed for some reason (i.e. Derpy is Mayor).
                // ERROR_NOT_FOUND        Exited due to not being able to find a Listing that matched the specified Identifiers
                // ERROR_NOT_FOUND_GUI    Exited due to having found the Listing in Cache / API, but not being able to find the Auction in the GUI
                // ERROR_UNKNOWN          Exited due to an unknown Error.
                // ERROR_SERVER           Exited due to not being able to get onto SkyBlock.
                // ERROR_INVENTORY        Not enough space in the Inventory to successfully collect the Auction.
            // Example:
                //    &collected_listing = auctionsCollectListing(%#tick_wait%,%#timeout_sec%,...&auction_identifiers[]);
                //    if(%&collected_listing% != "SUCCESS");
                //        if(%&collected_listing% == "ERROR_TIMEOUT");
                //        elseif(%&collected_listing% == "ERROR_UNAVAILABLE");
                //        elseif(%&collected_listing% == "ERROR_NOT_FOUND");
                //        elseif(%&collected_listing% == "ERROR_NOT_FOUND_GUI");
                //        elseif(%&collected_listing% == "ERROR_UNKNOWN");
                //        elseif(%&collected_listing% == "ERROR_SERVER");
                //        elseif(%&collected_listing% == "ERROR_INVENTORY");
                //        endif;
                //    endif;
        function auctionsCollectListing(#tick_wait=20,#timeout_sec=30,...&auction_identifiers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/collect.txt:44
            // Setup Function Variables
            if(true);
                debug               = true;
                &script_debug_name  = "&9auctionsCollectListing&7";
                do_timeout          = %#timeout_sec% > 0;
                #start_time         = %TIMESTAMP%;
                &enum_success       = "SUCCESS";
                &enum_timeout       = "ERROR_TIMEOUT";
                &enum_not_found     = "ERROR_NOT_FOUND";
                &enum_not_found_gui = "ERROR_NOT_FOUND_GUI";
                &enum_unknown       = "ERROR_UNKNOWN";
                &enum_server        = "ERROR_SERVER";
                &enum_inventory     = "ERROR_INVENTORY";
                
                if(%#tick_wait% < 100);
                    #collect_wait = 100;
                else;
                    #collect_wait = %#tick_wait%;
                endif;
            endif;
            
            // Find the specified Auction
            if(true);
                // 1. Check if the Auction is Cached
                if(true);
                    &cache_data[]   = auctionsCheckCache(...&auction_identifiers[]);
                    cache_hit      := %&cache_data[0]%;
                    &cache_id       = %&cache_data[1]%;
                    &cache_type     = %&cache_data[2]%;
                    #cache_price   := %&cache_data[3]%;
                    #cache_bids    := %&cache_data[4]%;
                    cache_ended    := %&cache_data[5]%;
                    cache_claimed  := %&cache_data[6]%;
                    &cache_owner    = %&cache_data[7]%;
                    &cache_profile  = %&cache_data[8]%;
                    &cache_sbid     = %&cache_data[9]%;
                    &cache_name     = %&cache_data[10]%;
                    &cache_mcid     = %&cache_data[11]%;
                    #cache_data    := %&cache_data[12]%;
                    #cache_stack   := %&cache_data[13]%;
                    &cache_buyers   = %&cache_data[14]%;
                endif;
                
                if(!%cache_hit%);
                    &identifers = join("&c,&4 ");
                    debug_error(%debug%,%&script_debug_name%,"Could not find Auction with Identifiers: &4%&identifers%&c. Returning '&4%&enum_not_found%&c'.");
                    return(%&enum_not_found%);
                endif;
            endif;
            
            // Loop actions until we have completed the Action, or an un-correctable Error is encountered.
            if(true);
                // Setup Auction State Terms
                if(true);
                    //    PURCHASED_ITEM
                        &auction_state_terms[] = "PURCHASED_ITEM";
                        &auction_state_mcids[] = "gold_block";
                        &auction_state_names[] = "Collect Auction";
                        &auction_state_regex[] = "Click to pick up item!";
                    //    PURCHASED_COINS
                        &auction_state_terms[] = "PURCHASED_COINS";
                        &auction_state_mcids[] = "gold_block";
                        &auction_state_names[] = "Collect Auction";
                        &auction_state_regex[] = "Click to collect coins!";
                    //    EXPIRED_COINS
                        &auction_state_terms[] = "EXPIRED_COINS";
                        &auction_state_mcids[] = "gold_nugget";
                        &auction_state_names[] = "Collect Auction";
                        &auction_state_regex[] = "Click to collect bid coins!";
                    //    EXPIRED_ITEM
                        &auction_state_terms[] = "EXPIRED_ITEM";
                        &auction_state_mcids[] = "stained_hardened_clay";
                        &auction_state_names[] = "Cancel Auction";
                        &auction_state_regex[] = "Click to cancel auction!";
                endif;
                #waited_ticks = 0;
                
                &init_unset_pointers[] = split(", ","@ah_failure, @ah_confirm, @&ah_failure_string, @&ah_confirm_string");
                &fail_ifset_pointers[] = split(", ","@ah_failure");
                &okay_ifset_pointers[] = split(", ","@ah_confirm");
                &check_bool_pointers[] = split(", ","@ah_confirm, @ah_failure");
                
                foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                    unset(%&init_unset_pointer%);
                next;
                
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. If we have already clicked on the item, check to see whether or not we have any Pointers set.
                    if(%check_pointers%);
                        foreach(&check_bool_pointers[],&check_bool_pointer,#cbp);
                            check_bool_state := "%%&check_bool_pointer%%";
                            if(%check_bool_state%);
                                if(%&check_bool_pointer% == "@ah_failure");
                                    // debug_breakpoint(%debug%,%&script_debug_name%,"Error Pointer @ah_failure is set!");
                                    debug_error(%debug%,%&script_debug_name%,"Error Pointer @ah_failure is set!");
                                    &return_string = %&enum_unknown%;
                                    break;
                                elseif(%&check_bool_pointer% == "@ah_confirm");
                                    // debug_breakpoint(%debug%,%&script_debug_name%,"Success Pointer @ah_confirm is set!");
                                    debug_log(%debug%,%&script_debug_name%,"Success Pointer @ah_confirm is set!");
                                    &return_string = %&enum_success%;
                                    break;
                                endif;
                            endif;
                        next;
                        
                        if(%&return_string% != "");
                            // debug_breakpoint(%debug%,%&script_debug_name%,"About to exit with return_string: '&d%&return_string%&7'...");
                            debug_log(%debug%,%&script_debug_name%,"About to exit with return_string: '&d%&return_string%&7'...");
                            break;
                        elseif((%TIMESTAMP% - %#check_pointer_timestamp%) >= 3);
                            debug_breakpoint(%debug%,%&script_debug_name%,"About to disable pointer check...");
                            check_pointers = false;
                        endif;
                        wait("1t");
                    else;
                        // 2. Open the Auction GUI, if we are not already in it.
                        if(true);
                            // 2a. Save the state of all our Pointers before we run the Function.
                            foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                                &saved_states[%#iup%] = %%&init_unset_pointer%%;
                            next;
                            
                            #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            &listing_opened    = auctionsOpenListing(%&cache_id%,&cache_data[],%#tick_wait%,%#recursive_timeout%);
                            if(%&listing_opened% != "SUCCESS");
                                debug_error(%debug%,%&script_debug_name%,"Received an Error Code from auctionsOpenListing: '&4%&listing_opened%&c'. Will return this Error Code.");
                                &return_string = %&listing_opened%;
                                break;
                            endif;
                            
                            // 2b. Revert the state of all our Pointers to their former State.
                            foreach(&saved_states[],&saved_state,#ss);
                                set(%&init_unset_pointers[%#ss%]%,%&saved_state%);
                            next;
                        endif;
                        
                        // 3. Check if we can collect the Auction Listing.
                        if(true);
                            // 3a. Find the Auction Listing Type (PURCHASED_ITEM, PURCHASED_COINS, EXPIRED_COINS, EXPIRED_ITEM).
                            if(true);
                                &found_state_term = "";
                                foreach(&auction_state_terms[],&auction_state_term,#ast);
                                    &auction_state_mcid  = %&auction_state_mcids[%#ast%]%;
                                    &auction_state_name  = %&auction_state_names[%#ast%]%;
                                    &auction_state_regex = %&auction_state_regex[%#ast%]%;
                                    #auction_state_slot  = findItemContainer(false,"MCID: %&auction_state_mcid%","NAME: %&auction_state_name%","NBT: r$%&auction_state_regex%");
                                    if(%#auction_state_slot% != -1);
                                        &found_state_term = %&auction_state_term%;
                                        break;
                                    endif;
                                next;
                                
                                // Break and return early after logging the contents of the Inventory, Mouse, and Container to file if we were not able to determine the Auction State.
                                if(%&found_state_term% == "");
                                    &log_path = containerLog("~/liteconfig/common/macros/logs/auctionFailures/%TIMESTAMP%-auctionNBT.txt",false,"Caller: %&script_debug_name%");
                                    debug_error(%debug%,%&script_debug_name%,"Could not determine the Auction State Type! This may be because the auction is not owned by us, it has expired, and we did not bid on it, or the server is shutting down soon, or something else that is yet to be accounted for. Full GUI Data has been logged to '&d%&log_path%&c'.");
                                    &return_string = %&enum_unknown%;
                                    break;
                                endif;
                            endif;
                            
                            // 3b. If we found the Auction Listing Type, determine whether or not we will be able to collect it.
                            if(true);
                                auction_collectable = ((%&found_state_term% == "PURCHASED_ITEM") || (%&found_state_term% == "PURCHASED_COINS"));
                                if(!%auction_collectable%);
                                    #auction_placeholder_slot     = 13;
                                    &auction_placeholder_item     = getslotitemnbt(%#auction_placeholder_slot%,,#auction_placeholder_stack,#auction_placeholder_data,&auction_placeholder_nbt);
                                    &auction_placeholder_nbt      = strip(%&auction_placeholder_nbt%);
                                    &auction_placeholder_name     = getItemName(%&auction_placeholder_nbt%,%&auction_placeholder_item%);
                                    &auction_placeholder_sbid     = getItemSBID(%&auction_placeholder_nbt%);
                                    #sum_available_inventory_room = getStackRoomInventory(%&auction_placeholder_sbid%);
                                    auction_collectable           = %#sum_available_inventory_room% >= %#auction_placeholder_stack%;
                                    if(!%auction_collectable%);
                                        debug_error(%debug%,%&script_debug_name%,"Auction Listing is not collectable. Minimum required room in Inventory is &4%#auction_placeholder_stack%&c, but we only have &4%#sum_available_inventory_room%&c room available. Will return '&4%&enum_inventory%&c'.");
                                        &return_string = %&enum_inventory%;
                                        break;
                                    endif;
                                endif;
                            endif;
                            
                            // 3c. If the Auction is Collectable, attempt to Collect the Auction.
                            if(%auction_collectable%);
                                #waited_ticks   = 0;
                                entered_new_gui = false;
                                &init_gui       = getContainerString(false);
                                item_clicked    = false;
                                do;
                                    // 1. Check for Function Timeout
                                    if(%do_timeout%);
                                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        if(%func_timeout%);
                                            debug_error(%debug%,%&script_debug_name%,"Function timed out");
                                            &return_string = %&enum_timeout%;
                                            break;
                                        endif;
                                    endif;
                                    
                                    // 2. Check if we are still in the same GUI
                                    if(true);
                                        entered_new_gui = enteredNewGUI(%&init_gui%,false);
                                        if(%entered_new_gui%);
                                            if(%item_clicked%);
                                                // debug_breakpoint(%debug%,%&script_debug_name%,"Entered new GUI, clicked new Item, about to enter Pointer Check mode.");
                                                debug_log(%debug%,%&script_debug_name%,"Entered new GUI, clicked new Item, about to enter Pointer Check mode.");
                                                #check_pointer_timestamp = %TIMESTAMP%;
                                                check_pointers           = true;
                                            else;
                                                // debug_breakpoint(%debug%,%&script_debug_name%,"Entered new GUI, but have not yet clicked new Item. &cWill not be entering Pointer Check mode.");
                                                debug_error(%debug%,%&script_debug_name%,"Entered new GUI, but have not yet clicked new Item. &4Will not be entering Pointer Check mode.");
                                            endif;
                                            break;
                                        endif;
                                    endif;
                                    
                                    // 3. Check if we can click the Item
                                    if(true);
                                        can_click = canDoInteraction(%#waited_ticks%,%#collect_wait%);
                                        if(%can_click%);
                                            slotclick(%#auction_state_slot%,"right");
                                            item_clicked = true;
                                        endif;
                                    endif;
                                    
                                    // 4. Check if any of our pointers are set
                                    if(true);
                                        foreach(&check_bool_pointers[],&check_bool_pointer,#cbp);
                                            check_bool_state := "%%&check_bool_pointer%%";
                                            if(%check_bool_state%);
                                                if(%&check_bool_pointer% == "@ah_failure");
                                                    debug_error(%debug%,%&script_debug_name%,"Error Pointer @ah_failure is set!");
                                                    &return_string = %&enum_unknown%;
                                                    break;
                                                elseif(%&check_bool_pointer% == "@ah_confirm");
                                                    debug_log(%debug%,%&script_debug_name%,"Success Pointer @ah_confirm is set!");
                                                    &return_string = %&enum_success%;
                                                    break;
                                                endif;
                                            endif;
                                        next;
                                    endif;
                                    
                                    wait("1t");
                                    inc(#waited_ticks);
                                until((%&return_string% != "") || (%entered_new_gui%));
                            endif;
                        endif;
                    endif;
                until(%&return_string% != "");
            endif;
            
            return(%&return_string%);
        endfunction;
    // gui/clickUntilUpdate/containerClick
        // Clicks on a Slot in a GUI until the GUI updates.
            // Params:
                // {number}  <#click_slot>          The Slot to Click on.
                // {number}  [#timeout_sec=30]      The Maximum Amount of Seconds to try to Click for before timing out.
                // {number}  [#tick_wait=20]        Ticks to wait between clicks.
                // {boolean} [check_items=false]    Whether or not to check items in the getContainerString and enteredNewGUI calls to
                //                                  help determine whether or not our GUI has updated.
                // {boolean} [right_click=false]    Whether or not to right click. Will left click if false.
                // {boolean} [shift_click=false]    Whether or not to shift click.
            // Returns a Boolean indicating whether or not we were able to get the GUI to update before timeout.
            // Example:
                //    updated_gui = containerClick(%#click_slot%,%#timeout_sec%,%#tick_wait%,%right_click%,%shift_click%);
        function containerClick(#click_slot,#timeout_sec=30,#tick_wait=20,check_items=false,right_click=false,shift_click=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/clickUntilUpdate.txt:13
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&7containerClick";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
            endif;
            
            // Loop until we have hit our return condition.
            if(true);
                if(%CONTAINERSLOTS% <= 0);
                    debug_error(%debug%,%&script_debug_name%,"Not in a clickable GUI at runtime!");
                    return(false);
                elseif(%right_click%);
                    &click_mode = "right";
                else;
                    &click_mode = "left";
                endif;
                
                &init_gui = getContainerString(%check_items%);
                do;
                    // Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Failed to update the GUI, function timed out.");
                            break;
                        endif;
                    endif;
                    
                    // Check if we are in a new GUI.
                    if(%clicked%);
                        gui_updated = enteredNewGUI(%&init_gui%,%check_items%);
                        if(%gui_updated%);
                            debug_log(%debug%,%&script_debug_name%,"gui has updated!");
                            break;
                        endif;
                        debug_log(%debug%,%&script_debug_name%,"gui has not yet updated");
                    endif;
                    
                    // Check if we can click the Slot again.
                    can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                    if(%can_click%);
                        slotclick(%#click_slot%,%&click_mode%,%shift_click%);
                        clicked = true;
                    endif;
                    
                    wait("1t");
                    inc(#waited_ticks);
                until((%gui_updated%) || (%GUI% == "NONE") || (%func_timeout%));
            endif;
            
            return(%gui_updated%);
        endfunction;
    // movement/index/splitCoordString
        // Given a coordinate string, splits it up by tunnel characters and returns an integer array.
            // Params:
            //      {string} [&coord_string="%XPOS%|%YPOS%|%ZPOS%"] The coordinate string to split up
            //
            // Returns an Array where the 0th element is the XPOS, 1st is YPOS, and 2nd is ZPOS.
        function splitCoordString(&coord_string="%XPOS%|%YPOS%|%ZPOS%");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:6
            &pos[] = split("|",%&coord_string%);
            &x     = %&pos[0]%;
            &y     = %&pos[1]%;
            &z     = %&pos[2]%;
            &arr[] = split(", ","%&x%, %&y%, %&z%");
            return(&arr[]);
        endfunction;
    // movement/index/fnCalcYawTo
        // Given an X, Y, Z value (and/or coordinate string), calculates the yaw and pitch values required to look at the value.
            // Params:
            //      {string} <&coordinate_string>   The Coordinate String, or X position.
            //      {string} [&y_pos]               The Y position (only required if <&coordinate_string> is a single value).
            //      {string} [&z_pos]               The Z position (only required if <&coordinate_string> is a single value).
            //
            // Returns an Array where element 0 = yaw, element 1 = dist, element 2 = pitch.
        function fnCalcYawTo(&coordinate_string,&y_pos,&z_pos);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:34
            &x_pos = %&coordinate_string%;
            ifmatches(%&coordinate_string%,"(.+)\|(.+)\|(.+)");
                &split_pos[] = splitCoordString(%&coordinate_string%);
                &x_pos       = %&split_pos[0]%;
                &y_pos       = %&split_pos[1]%;
                &z_pos       = %&split_pos[2]%;
            endif;
            
            calcyawto(%&x_pos%,%&y_pos%,%&z_pos%,#calc_yaw,#calc_dist,#calc_pitch);
            #calc_yaw = %#calc_yaw% + 180;
            if(%#calc_yaw% > 360);
                #calc_yaw = %#calc_yaw% - 360;
            elseif(%#calc_yaw% == 360);
                #calc_yaw = 0;
            endif;
            
            return(%#calc_yaw%,%#calc_dist%,%#calc_pitch%);
        endfunction;
    // info/index/getEntityPos
        // Given an Entity Name expression (and optionally the Entity Type and/or Range), uses the Entities Iterator to find them and return their position.
            // Params:
            //      {string} <&entity_expr>         A regular expression to use in the iterator filter
            //      {string} [&entity_type]         Optional entity type to use in the iterator filter
            //      {string} [&entity_range]        Optional max range to use in the iterator filter
            //      {boolean} [return_float=false]  If set to true, will return the entity's XPOSF, YPOSF, ZPOSF instead of integers.
            //
            // Returns an Array where element 0 = XPOS[F], 1 = YPOS[F], 2 = ZPOS[F]. Will return a string array no matter what,
            // if cannot find entity the first value of this array will be an empty string.
        function getEntityPos(&entity_expr,&entity_type="",&entity_range="",return_float=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:610
            &filter_terms[] = "name:%&entity_expr%";
            if(%&entity_type% != "");
                &filter_terms[] = "type:%&entity_expr%";
            endif;
            &filter_terms = join(",",&filter_terms[]);
            &filter_terms = "filter:{%&filter_terms%}"
            if(%&entity_range% != "");
                &filter_terms = "%&filter_terms%,range:%&entity_range%";
            endif;
            
            foreach("entities(%&filter_terms%)");
                if(%return_float%);
                    &out_arr[] = %ENTITYXPOSF%;
                    &out_arr[] = %ENTITYYPOSF%;
                    &out_arr[] = %ENTITYZPOSF%;
                else;
                    &out_arr[] = %ENTITYXPOS%;
                    &out_arr[] = %ENTITYYPOS%;
                    &out_arr[] = %ENTITYZPOS%;
                endif;
                found = true;
                break;
            next;
            
            if(!%found%);
                &out_arr[0] = "";
            endif;
            return(&out_arr[]);
        endfunction;
    // movement/index/isStalled
        // Used to check if the player is "stalled" (not moving more than [#stall_break] absolute distance)
        // for more than [#seconds] seconds.
            // Params:
            //      {number} #start_timestamp   The timestamp the last known 'unstalled' position was recorded at
            //      {string} &start_position    The coordinate string of the last known 'unstalled' position
            //      {number} [#seconds=5]       Amount of seconds required to have passed with no more than [#stall_break]
            //                                  blocks of absolute movement to consider as a stall
            //      {number} [#stall_break=3]   Blocks of absolute movement required to consider as having moved
            //
            // Returns an Array where element 0 is a boolean indicating whether or not the Player is stalled, and
            // element 1 is a boolean indicating whether or not to update the stall position / timestamp.
        function isStalled(#start_timestamp=%TIMESTAMP%,&start_position="%XPOS%|%YPOS%|%ZPOS%",#seconds=5,#stall_break=3);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:65
            #last_pos[] = splitCoordString(%&start_position%);
            #curr_pos[] = splitCoordString();
            #abs_diff   = xEval("sqrt((%#last_pos[0]% - %#curr_pos[0]%)^2) + sqrt((%#last_pos[1]% - %#curr_pos[1]%)^2) + sqrt((%#last_pos[2]% - %#curr_pos[2]%)^2)",true);
            
            update_pos = #abs_diff >= #stall_break;
            is_stalled = !%update_pos%;
            if(%is_stalled%);
                is_stalled = hasTimeExceeded(%#start_timestamp%,%#seconds%);
            endif;
            return(%over_limit%,%update_pos%);
        endfunction;
    // info/index/withinBounds
        // Checks if a number is <= min && >= max.
            // Params:
            //      {number} <#number>  The number to check if is between min && max.
            //      {number} <#min>     The minimum value for <#number>
            //      {number} <#max>     The maximum value for <#number>
            //
            // Returns a boolean indicating whether or not the number is between the specified values.
        function withinBounds(#number,#min,#max);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:23
            return_boolean = ((#number >= #min) && (#number <= #max));
            return(%return_boolean%);
        endfunction;
    // movement/index/getCoordString
        // Generates a coordinate string from the input numbers
            // Params:
            //      {number} [#x=%XPOS%]    The X Position
            //      {number} [#x=%YPOS%]    The Y Position
            //      {number} [#x=%ZPOS%]    The Z Position
            //
            // Returns the coordinate string.
        function getCoordString(#x=%XPOS%,#y=%YPOS%,#z=%ZPOS%);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:22
            &coord_string = "%XPOS%|%YPOS%|%ZPOS%";
            return(%&coord_string%);
        endfunction;
    // movement/index/baritoneGoto
        // Takes input of a coordinate position in the world to move to, as well as optional setting pairs to pass along
        // to baritone, then instructs Baritone to move to the position in the world.
            // Params:
            //      {string} <&target_position>     The Coordinate string to move to (X|Y|Z).
            //      {string} [&coord_bounds[]]      An optional array of coordinate bounds (idx 0 = min coord bound, idx 1 = max coord bound)
            //                                      strings. If provided, will exit the function and kill Baritone should the Player exit
            //                                      these bounds.
            //      {number} [#timeout_sec=300]     Maximum amount of seconds for the function to wait before timing out and exiting. Set to -1
            //                                      to disable timeouts.
            //      {number} [#stall_sec=5]         Maximum amount of seconds for the function to be stalled in nearly the same X/Y/Z position (no more
            //                                      than 3 blocks of absolute distance) before timing out and exiting. Set to -1 to disable stall timeouts.
            //      {string} [...&setting_pairs[]]  An optional array of key value Baritone Setting pairs to pass through to
            //                                      Baritone before executing the movement. By default, this function will always
            //                                      use the settings defined below. If you pass in these settings' keys, your values
            //                                      will be used instead of the defaults. You can pass in other settings as well, if
            //                                      needed. The format to pass key value pairs in is: '<key>|<value>'.
                // Baritone Settings Used:
                //  allowPlace              : false
                //  allowBreak              : false
                //  allowSprint             : true
                //  allowDiagonalDescend    : true
                //  allowDiagonalAscend     : true
                //  allowParkour            : true
                //  allowParkourAscend      : true
                //  antiCheatCompatibility  : true
                //  allowWalkOnBottomSlab   : true
                //  allowWaterBucketFall    : false
                //  blocksToAvoid           : spruce_fence,spruce_fence_gate,birch_fence,birch_fence_gate,jungle_fence,jungle_fence_gate,acacia_fence,acacia_fence_gate,dark_oak_fence,dark_oak_fence_gate,nether_brick_fence,cobblestone_wall
                //  freeLook                : false
                //  overshootTraverse       : true
                //  randomLooking           : 0.03
                //  sprintAscends           : true
                //  sprintInWater           : false
        function baritoneGoto(&target_position,&coord_bounds[],#timeout_sec=300,#stall_sec=5,...&setting_pairs[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:150
            log("baritoneGoto : target_position = %&target_position%");
            // Validate input parameters
            if(true);
                // Issue Baritone Settings
                if(true);
                    // Default Settings
                        &baritone_keys[] = "allowBreak";
                        &baritone_vals[] = "false";
        
                        &baritone_keys[] = "allowPlace";
                        &baritone_vals[] = "false";
        
                        &baritone_keys[] = "allowSprint";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "allowDiagonalDescend";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "allowDiagonalAscend";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "allowParkour";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "allowParkourAscend";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "antiCheatCompatibility";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "allowWalkOnBottomSlab";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "allowWaterBucketFall";
                        &baritone_vals[] = "false";
                        
                        &baritone_keys[] = "blocksToAvoid";
                        &baritone_vals[] = "spruce_fence,spruce_fence_gate,birch_fence,birch_fence_gate,jungle_fence,jungle_fence_gate,acacia_fence,acacia_fence_gate,dark_oak_fence,dark_oak_fence_gate,nether_brick_fence,cobblestone_wall";
        
                        &baritone_keys[] = "freeLook";
                        &baritone_vals[] = "false";
        
                        &baritone_keys[] = "overshootTraverse";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "randomLooking";
                        &baritone_vals[] = "0.03";
        
                        &baritone_keys[] = "sprintAscends";
                        &baritone_vals[] = "true";
        
                        &baritone_keys[] = "sprintInWater";
                        &baritone_vals[] = "false";
                    foreach(&setting_pairs[],&setting_pair,#spi);
                        &setting_pair[] = split("|",%&setting_pair%);
                        &setting_key    = %&setting_pair[0]%;
                        if(%&setting_key% != "");
                            &setting_val = %&setting_pair[1]%;
                            #setting_idx = indexof(&baritone_keys[],,%&setting_key%);
                            if(#setting_idx != -1);
                                &baritone_vals[%#setting_idx%] = %&setting_val%;
                            else;
                                &baritone_keys[] = %&setting_key%;
                                &baritone_vals[] = %&setting_val%;
                            endif;
                        endif;
                    next;
                    
                    foreach(&baritone_keys[],&baritone_key,#bki);
                        &baritone_val = %&baritone_vals[%#bki%]%;
                        baritonecommand("set %&baritone_key% %&baritone_val%");
                    next;
                endif;
                
                // Setup bounds and exit conditions
                if(true);
                    foreach(&coord_bounds[],&coord_bound,#cbi);
                        ifmatches(%&coord_bound%,"(.+)\|(.+)\|(.+)");
                            #coords[]   = splitCoordString(%&coord_bound%);
                            #bounds_x[] = %#coord[0]%;
                            #bounds_y[] = %#coord[1]%;
                            #bounds_z[] = %#coord[2]%;
                        endif;
                    next;
                    #bounds_x = arraysize(#bounds_x[]);
                    do_coord_bound = #bounds_x >= 2;
                    if(%do_coord_bound%);
                        #final_idx = #bounds_x - 1;
                        sort("ASC",#bounds_x[]);
                        sort("ASC",#bounds_y[]);
                        sort("ASC",#bounds_z[]);
                        #min_bound_x = %#bounds_x[0]%;
                        #min_bound_y = %#bounds_y[0]%;
                        #min_bound_z = %#bounds_z[0]%;
                        #max_bound_x = %#bounds_x[%#final_idx%]%;
                        #max_bound_y = %#bounds_y[%#final_idx%]%;
                        #max_bound_z = %#bounds_z[%#final_idx%]%;
                    endif;
                    
                    #target_pos[] = splitCoordString(%&target_position%);
                    #target_x    := %#target_pos[0]%;
                    #target_y    := %#target_pos[1]%;
                    #target_z    := %#target_pos[2]%;
                endif;
                
                do_timeout  = #timeout_sec != -1;
                do_stall    = #stall_sec != -1;
                #start_time = %TIMESTAMP%;
                
                if(%do_stall%);
                    #stall_time = #start_time;
                    &stall_pos  = getCoordString();
                endif;
            endif;
            
            // Start moving to the position.
            localGUI("NONE");
            baritonecommand("goto %#target_x% %#target_y% %#target_z%");
            do;
                // Exit any GUI if we are in one.
                if(%GUI% != "NONE");
                    localGUI("NONE");
                endif;
                
                // Check if we have timed out
                break_condition = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                if(%break_condition%);
                    break;
                endif;
                
                // Check if we have exited the boundaries
                if(%do_coord_bound%);
                    wait("1t");
                    in_bounds_x     = withinBounds(%XPOS%,%#min_bound_x%,%#max_bound_x%);
                    in_bounds_y     = withinBounds(%YPOS%,%#min_bound_y%,%#max_bound_y%);
                    in_bounds_z     = withinBounds(%ZPOS%,%#min_bound_z%,%#max_bound_z%);
                    break_condition = !((%in_bounds_x%) && (%in_bounds_y%) && (%in_bounds_z%));
                    if(%break_condition%);
                        break;
                    endif;
                endif;
                
                // Check if we are on the correct position
                return_boolean = ((%XPOS% == #target_x) && (%YPOS% == #target_y) && (%ZPOS% == #target_z));
                if(%return_boolean%);
                    break;
                endif;
                
                // Check if we have stalled out
                if(%do_stall%);
                    wait("1t");
                    stall_data[]    = isStalled(%#start_time%,%&start_pos%,%#stall_sec%);
                    break_condition = %stall_data[0]%;
                    update_stall    = %stall_data[1]%;
                    if(%break_condition%);
                        break;
                    elseif(%update_stall%);
                        #stall_time = %TIMESTAMP%;
                        &stall_pos  = getCoordString();
                    endif;
                endif;
                
                wait("1t");
            until((!%BARITONEWORKING%) || (%break_condition%) || (%return_boolean%));
            
            if((!%BARITONEWORKING%) && (!%break_condition%));
                return_boolean = ((%XPOS% == #target_x) && (%YPOS% == #target_y) && (%ZPOS% == #target_z));
            elseif(%BARITONEWORKING%);
                baritonecommand("stop");
            endif;
            return(%return_boolean%);
        endfunction;
    // math/index/absDiff
        // Given input of two numbers, finds the absolute difference between them.
            // Params:
            //      {string} <&first_number>    The first number (can be integer or float)
            //      {string} <&second_number>   The second number (can be integer or float)
            //
            // Returns the absolute difference between the two numbers. If either number is a float,
            // a float number is returned. Otherwise, an integer is returned.
        function absDiff(&first_number,&second_number);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:8
            ifmatches(%&first_number%,"\.");
                float = true;
            elseifmatches(%&second_number%,"\.");
                float = true;
            endif;
            
            if(%float%);
                &diff = xEval("%&first_number% - %&second_number%");
                ifmatches(%&diff%,"-");
                    &diff = xEval("%&diff% * -1");
                endif;
                return(%&diff%);
            else;
                #first  := %&first_number%;
                #second := %&second_number%;
                #diff    = %#first% - %#second%;
                if(#diff < 0);
                    #diff = #diff * -1;
                endif;
                return(%#diff%);
            endif;
        endfunction;
    // gui/index/regexTest
        // Tests if the regular expression <&expression> matches against <&input_string>.
            // Params:
            //      {string} <&input_string>    The input string to test against <&expression>.
            //      {string} <&expression>      The regular expression to test against <&input_string>.
            //
            // Returns a boolean indicating whether or not the <&expression> matches against the <&input_string>.
        function regexTest(&input_string,&expression);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:49
            ifmatches(%&input_string%,%&expression%);
                return_bool = true;
            endif;
            return(%return_bool%);
        endfunction;
    // movement/index/getMiddlePointCoordRange
        // Given a minimum and maximum coordinate string, splits both of them, then finds the middle most value.
            // Params:
            //      {string} <&min_coord_string>    The minimum coordinate string
            //      {string} <&max_coord_string>    The maximum coordinate string
            //
            // Returns an Array where the 0th element is the XPOS, 1st is YPOS, and 2nd is ZPOS. The value is the
            // middle point (min X + max X / 2, etc) of each coordinate point.
        function getMiddlePointCoordRange(&min_coord_string,&max_coord_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:105
            #min_coord[] = splitCoordString(%&min_coord_string%);
            #max_coord[] = splitCoordString(%&max_coord_string%);
            
            #avg_pos_x   = (%#min_coord[0]% + %#max_coord[0]%) / 2;
            #avg_pos_y   = (%#min_coord[1]% + %#max_coord[1]%) / 2;
            #avg_pos_z   = (%#min_coord[2]% + %#max_coord[2]%) / 2;
            
            log("getMiddlePointCoordRange: avg x %#avg_pos_x%, avg y %#avg_pos_y%, avg z %#avg_pos_z%");
            return(%#avg_pos_x%,%#avg_pos_y%,%#avg_pos_z%);
        endfunction;
    // movement/index/expandCoordStringToRange
        // Given a coordinate string, splits it up by tunnel characters and returns the minimum and maximum
        // coordinate strings, evaluated by +/- [#expand_by] to each coordinate point.
            // Params:
            //      {string} [&coord_string="%XPOS%|%YPOS%|%ZPOS%"] The coordinate string to split up
            //      {number} [#expand_by=1]                         The offset to apply to each coordinate point
            //
            // Returns an Array where the first element is the minimum string and second element is maximum string.
        function expandCoordStringToRange(&coord_string="%XPOS%|%YPOS%|%ZPOS%",#expand_by=1);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:85
            #expand_greater = %#expand_by%;
            #expand_lesser  = %#expand_by% * -1;
            #coord_array[]  = splitCoordString(%&coord_string%);
            foreach(#coord_array[],#coord_pos,#cpi);
                #min_coord[%#cpi%] = %#coord_pos% + %#expand_lesser%;
                #max_coord[%#cpi%] = %#coord_pos% + %#expand_greater%;
            next;
            &min_string = join("|",#min_coord[]);
            &max_string = join("|",#max_coord[]);
            return(%&min_string%,%&max_string%);
        endfunction;
    // movement/index/goto
        // Given a position string (and/or a server and coordinate string), gets the Player to the
        // required Server then moves them to the required position.
            // Params:
            //      {string} [&position]        The name of the pre-defined position to move to. Valid strings are:
                //  'HUB'                   : SkyBlock Hub
                //  'HOME'                  : SkyBlock Home (Private Island)
                //  'BANKER'                : SkyBlock Hub => Banker NPC
                //  'BAZAAR'                : SkyBlock Hub => Bazaar NPC
                // Note that in order to use the 'BAZAAR' or 'BAZAAR_AGENT' term, Chat Filter must be setup with 'You need level 7 in Farming, Foraging and Mining to access this feature!'
                // in order to cancel the function in the event that the User is not yet level 10.
                //  'BUILDER'               : SkyBlock Hub => Builder NPC
                //  'MAD_REDSTONE_ENGINEER' : SkyBlock Hub => Builder NPC => Downstairs Redstone NPC (alt. strings: 'REDSTONE_ENGINEER', 'REDSTONE_MERCHANT')
                //  'BITS'                  : SkyBlock Hub => Elizabeth NPC (Community Center)
                //  'ALCHEMIST'             : SkyBlock Hub => Alchemist NPC
                //  'AUCTION'               : SkyBlock Hub => Auction NPC
                //  'JACOB'                 : SkyBlock Hub => Jacob NPC
                //  Note that in order to use the 'JACOB' term, Chat Filter must be setup with '\[NPC\] Jacob: You need Farming 10 to participate!' in order to cancel
                //  the function in the event that the User is not yet level 10.
                //  'ANITA'                 : SkyBlock Hub => Anita NPC
                //  'ANVIL'                 : SkyBlock Hub => Anvil (at Blacksmith)
                //  'REFORGE_ANVIL'         : SkyBlock Hub => Reforge Anvil (at Blacksmith / Smithmonger)
                //  'ENCHANTMENT_TABLE'     : SkyBlock Hub => Enchantment Table Building (Library)
                //  'LIBRARIAN'             : SkyBlock Hub => Librarian NPC
                //  'FREE_COOKIE'           : SkyBlock Hub => Community Center => City Project
                //  'WHEAT_FIELDS'          : SkyBlock Hub => Wheat Fields
                //  'COAL_MINE'             : SkyBlock Hub => Coal Mine
                //  'GOLD_MINE'             : SkyBlock Hub => Coal Mine => Gold Mine
                //  'FOREST'                : SkyBlock Hub => Forest
                //  'HUB_SECLUDED'          : SkyBlock Hub => Random secluded location
                //  'HUB_SELECTOR'          : SkyBlock Hub => Hub Selector NPC (alt. strings              : 'SELECTOR')
                //  'FARM_MERCHANT'         : SkyBlock Hub => Farm Merchant NPC (alt. strings             : 'FARM', 'FARM MERCHANT', 'FARMER', 'FARMER MERCHANT')
                //  'MINE_MERCHANT'         : SkyBlock Hub => Mine Merchant NPC (alt. strings             : 'MINE', 'MINE MERCHANT', 'MINER', 'MINER MERCHANT')
                //  'LUMBER_MERCHANT'       : SkyBlock Hub => Lumber Merchant NPC (alt. strings           : 'LUMBER', 'LUMBER MERCHANT')
            //      {boolean} [open_gui=false]  Whether or not to open the GUI this Position is bound to once we have
            //                                  arrived.
            //      {number} [#timeout_sec=300] Amount of seconds to continue to attempt to execute this movement for before
            //                                  timing out and returning false. If set to -1, will take it as no timeout, do it
            //                                  forever until successful completion.
            //      {string} [&server]          The name of the Server the position exists on. Only required if
            //                                  [&position] is omitted. Valid values are 'HUB', 'HOME'.
            //      {string} [&coord_string]    The coordinate string of the position to move to in format X|Y|Z.
            //                                  Only required if [&position] is omitted and [&server] is provided.
            //
            // Returns a boolean indicating whether or not the movement was successful.
        function goto(&position,open_gui=false,#timeout_sec=300,&server,&coord_string);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/movement/index.txt:491
            // Check if need to setup position string indexes
            if(true);
                #pos_param_len = arraysize(@&goto_pos_params[]);
                #last_build    = %@#goto_pos_last_build%;
                &curr_config   = %CONFIG%;
                &curr_config   = regexreplace(&curr_config,"-dev$","");
                #curr_build    = getbuild(%&curr_config%);
                refresh_index  = ((#pos_param_len == 0) || (#last_build == 0) || ((#last_build != #curr_build) && (#curr_build != -1)));
                
                if(%refresh_index%);
                    unset(@&goto_pos_params[]);         // parameters used to select a position to go to
                    unset(@&goto_pos_min[]);            // min coordinate bound strings
                    unset(@&goto_pos_max[]);            // max coordinate bound strings
                    unset(@&goto_pos_server[]);         // server type (hub, home)
                    unset(@&goto_pos_entity[]);         // entity name for use in foreach ... entities or NULL if no entity
                    unset(@&goto_pos_container[]);      // name of container if entity or goto_pos_override_look
                    unset(@&goto_pos_override_look[]);  // coordinate string to calcyawto & look at if not entity
                    unset(@&goto_pos_chat_cancel[]);    // pointer to global bool var to unset before actions, if turns true while running, cancel
                    
                    if(true);
                        // Home / Private Island
                            @&goto_pos_params[]        = "HOME";
                            @&goto_pos_min[]           = "NULL";
                            @&goto_pos_max[]           = "NULL";
                            @&goto_pos_server[]        = "SKYBLOCK_HOME";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "NULL";
                            @&goto_pos_override_look[] = "NULL";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Hub Spawnpoint @ Hub
                            @&goto_pos_params[]        = "HUB";
                            @&goto_pos_min[]           = "-4|69|-71";
                            @&goto_pos_max[]           = "-2|71|-69";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "NULL";
                            @&goto_pos_override_look[] = "NULL";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Hub Selector @ Village
                            @&goto_pos_params[]        = "HUB_SELECTOR, SELECTOR, SERVER_SELECTOR, SERVER SELECTOR, HUB SELECTOR";
                            @&goto_pos_min[]           = "-12|69|-70";
                            @&goto_pos_max[]           = "-10|71|-68";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Hub Selector";
                            @&goto_pos_container[]     = "SkyBlock Hub Selector";
                            @&goto_pos_override_look[] = "-10.0|71.5|-67.0";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Banker @ Bank
                            @&goto_pos_params[]        = "BANKER";
                            @&goto_pos_min[]           = "-26|70|-62";
                            @&goto_pos_max[]           = "-24|72|-60";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Banker";
                            @&goto_pos_container[]     = "^(?:Bank|Personal Bank Account)$";
                            @&goto_pos_override_look[] = "-24.5|72.5|-58.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Bazaar @ Bazaar Alley
                            &char_unicode_escaped      = "\u279C"; // bazaar fat arrow
                            @&goto_pos_params[]        = "BAZAAR";
                            @&goto_pos_min[]           = "-32|69|-77";
                            @&goto_pos_max[]           = "-30|71|-75";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Bazaar";
                            @&goto_pos_container[]     = "Bazaar %&char_unicode_escaped% (?:Farming|Mining|Combat|Woods & Fishes|Oddities)";
                            @&goto_pos_override_look[] = "-32.5|72.5|-76.5";
                            @&goto_pos_chat_cancel[]   = "@cannot_use_bazaar";
                        // Lumber Merchant @ Village
                            @&goto_pos_params[]        = "LUMBER_MERCHANT, LUMBER, LUMBER MERCHANT";
                            @&goto_pos_min[]           = "-51|69|-72";
                            @&goto_pos_max[]           = "-49|71|-70";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Lumber Merchant";
                            @&goto_pos_container[]     = "Lumber Merchant";
                            @&goto_pos_override_look[] = "-49.5|71.5|-68.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Builder @ Builder's House
                            @&goto_pos_params[]        = "BUILDER";
                            @&goto_pos_min[]           = "-53|70|-31";
                            @&goto_pos_max[]           = "-51|72|-29";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Builder";
                            @&goto_pos_container[]     = "Builder";
                            @&goto_pos_override_look[] = "-51.0|72.5|-27.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Wool Weaver @ Builder's House
                            @&goto_pos_params[]        = "WOOL_WEAVER, WOOL WEAVER, WOOL";
                            @&goto_pos_min[]           = "-48|73|-34";
                            @&goto_pos_max[]           = "-46|75|-32";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Wool Weaver";
                            @&goto_pos_container[]     = "Wool Weaver";
                            @&goto_pos_override_look[] = "-47.0|75.5|-30.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Mad Redstone Engineer @ Builder's House
                            @&goto_pos_params[]        = "MAD_REDSTONE_ENGINEER, REDSTONE_ENGINEER, REDSTONE_MERCHANT, MAD RESTONE ENGINEER, REDSTONE ENGINEER, REDSTONE MERCHANT, REDSTONE";
                            @&goto_pos_min[]           = "-54|64|-32";
                            @&goto_pos_max[]           = "-52|66|-30";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Mad Redstone Engineer";
                            @&goto_pos_container[]     = "Mad Redstone Engineer";
                            @&goto_pos_override_look[] = "-52.0|66.5|-29.0";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Lumberjack @ Forest
                            @&goto_pos_params[]        = "LUMBERJACK, FOREST";
                            @&goto_pos_min[]           = "-113|73|-37";
                            @&goto_pos_max[]           = "-111|75|-35";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Lumberjack";
                            @&goto_pos_container[]     = "NULL";
                            @&goto_pos_override_look[] = "-112.5|75.5|-36.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Adventurer @ Village
                            @&goto_pos_params[]        = "ADVENTURER, ADVENTURER_MERCHANT";
                            @&goto_pos_min[]           = "-43|69|-68";
                            @&goto_pos_max[]           = "-41|71|-66";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Adventurer";
                            @&goto_pos_container[]     = "Adventurer";
                            @&goto_pos_override_look[] = "-41.5|71.5|-64.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Bazaar Agent @ Bazaar Alley
                            &char_unicode_escaped      = "\u279C"; // bazaar fat arrow
                            @&goto_pos_params[]        = "BAZAAR_AGENT";
                            @&goto_pos_min[]           = "-41|69|-79";
                            @&goto_pos_max[]           = "-39|71|-77";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Bazaar Agent";
                            @&goto_pos_container[]     = "Bazaar %&char_unicode_escaped% (?:Farming|Mining|Combat|Woods & Fishes|Oddities)";
                            @&goto_pos_override_look[] = "-39.5|71.5|-78.90625";
                            @&goto_pos_chat_cancel[]   = "@cannot_use_bazaar";
                        // Vault @ Bank
                            @&goto_pos_params[]        = "VAULT";
                            @&goto_pos_min[]           = "-29|70|-63";
                            @&goto_pos_max[]           = "-27|72|-61";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Vault";
                            @&goto_pos_container[]     = "^(?:Unlock Bank|Personal) Vault\??$";
                            @&goto_pos_override_look[] = "-28.5|72.8125|-61.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Alchemist @ Village
                            @&goto_pos_params[]        = "ALCHEMIST";
                            @&goto_pos_min[]           = "41|69|-63";
                            @&goto_pos_max[]           = "43|71|-61";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Alchemist";
                            @&goto_pos_container[]     = "Alchemist";
                            @&goto_pos_override_look[] = "41.5|71.5|-63.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Fish Merchant @ Village
                            @&goto_pos_params[]        = "FISH_MERCHANT, FISH MERCHANT, FISH";
                            @&goto_pos_min[]           = "49|67|-84";
                            @&goto_pos_max[]           = "51|69|-82";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Fish Merchant";
                            @&goto_pos_container[]     = "Fish Merchant";
                            @&goto_pos_override_look[] = "52.5|69.5|-82.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Plumber Joe @ Village
                            @&goto_pos_params[]        = "PLUMBER_JOE, PLUMBER JOE, PLUMBER";
                            @&goto_pos_min[]           = "56|69|-80";
                            @&goto_pos_max[]           = "58|71|-78";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Plumber Joe";
                            @&goto_pos_container[]     = "Plumber Joe";
                            @&goto_pos_override_look[] = "56.5|71.59375|-77.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Kat @ Village
                            @&goto_pos_params[]        = "KAT";
                            @&goto_pos_min[]           = "32|70|-102";
                            @&goto_pos_max[]           = "34|72|-100";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Kat";
                            @&goto_pos_container[]     = "Pet Sitter";
                            @&goto_pos_override_look[] = "34.5|72.59375|-100.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Zog @ Village
                            @&goto_pos_params[]        = "ZOG";
                            @&goto_pos_min[]           = "32|69|-95";
                            @&goto_pos_max[]           = "34|71|-93";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Zog";
                            @&goto_pos_container[]     = "Zog";
                            @&goto_pos_override_look[] = "33.5|71.5|-95.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Bea @ Village
                            @&goto_pos_params[]        = "BEA";
                            @&goto_pos_min[]           = "27|69|-92";
                            @&goto_pos_max[]           = "29|71|-90";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Bea";
                            @&goto_pos_container[]     = "Bea";
                            @&goto_pos_override_look[] = "30.5|71.5|-90.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // George @ Village
                            @&goto_pos_params[]        = "GEORGE";
                            @&goto_pos_min[]           = "31|76|-93";
                            @&goto_pos_max[]           = "33|78|-91";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "George";
                            @&goto_pos_container[]     = "Offer Pets";
                            @&goto_pos_override_look[] = "32.5|78.5|-93.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Jacob @ Farmhouse
                            @&goto_pos_params[]        = "JACOB";
                            @&goto_pos_min[]           = "21|70|-69";
                            @&goto_pos_max[]           = "23|72|-67";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Jacob";
                            @&goto_pos_container[]     = "Jacob's Farming Contests";
                            @&goto_pos_override_look[] = "23.0|72.5|-69.0";
                            @&goto_pos_chat_cancel[]   = "@cannot_use_jacob";
                        // Anita @ Farmhouse
                            @&goto_pos_params[]        = "ANITA";
                            @&goto_pos_min[]           = "23|76|-71";
                            @&goto_pos_max[]           = "25|78|-69";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Anita";
                            @&goto_pos_container[]     = "Anita";
                            @&goto_pos_override_look[] = "23.0|78.5|-69.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Farm Merchant @ Village
                            @&goto_pos_params[]        = "FARM_MERCHANT, FARM MERCHANT, FARMER_MERCHANT, FARMER MERCHANT, FARMER, FARM";
                            @&goto_pos_min[]           = "13|69|-73";
                            @&goto_pos_max[]           = "15|71|-71";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Farm Merchant";
                            @&goto_pos_container[]     = "Farm Merchant";
                            @&goto_pos_override_look[] = "15.5|71.5|-71.78125";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Elizabeth @ Community Center
                            @&goto_pos_params[]        = "ELIZABETH, BITS";
                            @&goto_pos_min[]           = "0|70|-103";
                            @&goto_pos_max[]           = "2|72|-101";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Elizabeth";
                            @&goto_pos_container[]     = "Community Shop";
                            @&goto_pos_override_look[] = "0.0|72.5|-101.0";
                            @&goto_pos_chat_cancel[]   = "@cannot_use_elizabeth";
                        // City Project @ Community Center
                            @&goto_pos_params[]        = "FREE_COOKIE, CITY_PROJECT";
                            @&goto_pos_min[]           = "8|72|-110";
                            @&goto_pos_max[]           = "10|74|-108";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "CITY PROJECT";
                            @&goto_pos_container[]     = "Project";
                            @&goto_pos_override_look[] = "12.0|73.53125|-108.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Auction Agent @ Auction House
                            @&goto_pos_params[]        = "AUCTIONS, AUCTION, AUCTION_HOUSE, AUCTION HOUSE, AH";
                            @&goto_pos_min[]           = "-32|71|-89";
                            @&goto_pos_max[]           = "-30|73|-87";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Auction Agent";
                            @&goto_pos_container[]     = "(?:Co-op )?Auction House";
                            @&goto_pos_override_look[] = "-31.0|74.5|-85.5";
                            @&goto_pos_chat_cancel[]   = "@cannot_use_ah";
                        // Librarian @ Library
                            @&goto_pos_params[]        = "LIBRARIAN, LIBRARY, LIBRARIAN_MERCHANT, LIBRARY_MERCHANT, LIBRARIAN MERCHANT, LIBRARY MERCHANT";
                            @&goto_pos_min[]           = "-36|68|-113";
                            @&goto_pos_max[]           = "-34|70|-111";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Librarian";
                            @&goto_pos_container[]     = "Librarian";
                            @&goto_pos_override_look[] = "-35.5|70.59375|-112.5";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Enchanting Table @ Library
                            @&goto_pos_params[]        = "ENCHANTMENT_TABLE, ENCHANTMENT TABLE, ENCHANTMENT, ENCHANTING_TABLE, ENCHANTING TABLE, ENCHANTING, ENCHANT_TABLE, ENCHANT TABLE, ENCHANT";
                            @&goto_pos_min[]           = "-36|68|-113";
                            @&goto_pos_max[]           = "-34|70|-111";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "Enchant Item";
                            @&goto_pos_override_look[] = "-37|69|-111";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Mine Merchant @ Coal Mine
                            @&goto_pos_params[]        = "MINE_MERCHANT, MINE MERCHANT, MINER_MERCHANT, MINER MERCHANT, MINE, MINER";
                            @&goto_pos_min[]           = "-10|67|-124";
                            @&goto_pos_max[]           = "-8|69|-122";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Mine Merchant";
                            @&goto_pos_container[]     = "Mine Merchant";
                            @&goto_pos_override_look[] = "-9.0|69.5|-125.0";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Blacksmith @ Blacksmith
                            @&goto_pos_params[]        = "ANVIL";
                            @&goto_pos_min[]           = "-29|68|-128";
                            @&goto_pos_max[]           = "-27|70|-126";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "Anvil";
                            @&goto_pos_override_look[] = "-28|69|-129";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Smithmonger @ Blacksmith
                            @&goto_pos_params[]        = "SMITHMONGER";
                            @&goto_pos_min[]           = "-32|68|-137";
                            @&goto_pos_max[]           = "-30|70|-135";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "Smithmonger";
                            @&goto_pos_container[]     = "Smithmonger";
                            @&goto_pos_override_look[] = "-32.5|70.59375|-135.5";
                            @&goto_pos_chat_cancel[]   = "@cannot_use_smithmonger";
                        // Reforge Anvil @ Blacksmith/Smithmonger
                            @&goto_pos_params[]        = "REFORGE_ANVIL, REFORGE ANVIL, REFORGE";
                            @&goto_pos_min[]           = "-32|68|-137";
                            @&goto_pos_max[]           = "-30|70|-135";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "Reforge Item \(Advanced\)";
                            @&goto_pos_override_look[] = "-29|69|-137";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Wheat Fields @ Farm in Hub
                            @&goto_pos_params[]        = "WHEAT_FIELDS, WHEAT FIELDS, WHEAT, FIELDS";
                            @&goto_pos_min[]           = "42|70|-144";
                            @&goto_pos_max[]           = "44|72|-142";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "NULL";
                            @&goto_pos_override_look[] = "NULL";
                            @&goto_pos_chat_cancel[]   = "NULL";
                        // Coal Mine @ Coal Mine in Hub
                            @&goto_pos_params[]        = "COAL_MINE, COAL MINE, COAL";
                            @&goto_pos_min[]           = "-21|70|-166";
                            @&goto_pos_max[]           = "-19|72|-164";
                            @&goto_pos_server[]        = "SKYBLOCK_HUB";
                            @&goto_pos_entity[]        = "NULL";
                            @&goto_pos_container[]     = "NULL";
                            @&goto_pos_override_look[] = "NULL";
                            @&goto_pos_chat_cancel[]   = "NULL";
                    endif;
                    
                    @#goto_pos_last_build = %#curr_build%;
                endif;
            endif;
            
            // Find the position we are going to need to go to.
            if(true);
                #position_index = -1;
                if(%&position% != "");
                    foreach(@&goto_pos_params[],&goto_pos_params,#gpi);
                        &goto_pos_params[] = split(", ",%&goto_pos_params%);
                        #goto_pos_index    = indexof(&goto_pos_params[],,%&position%);
                        if(#goto_pos_index != -1);
                            debug_log(%@fn_debug%,%&script_debug_name%,"goto > pos found in %&goto_pos_params% (%&goto_pos_params[%#goto_pos_index%]%)");
                            #position_index = #gpi;
                            break;
                        endif;
                    next;
                endif;
                if(#position_index != -1);
                    #auction_index          = indexof(&goto_pos_params[],,"AUCTION");
                    if(#auction_index != -1);
                        #auction_y      =  72;
                        #auction_min_x  = -39;
                        #auction_max_x  = -29;
                        #auction_row_z1 = -88;
                        #auction_row_z2 = -94;
                        
                        
                    else;
                        &goto_pos_min = %@&goto_pos_min[%#position_index%]%;
                        &goto_pos_max = %@&goto_pos_max[%#position_index%]%;
                    endif;
                    &goto_pos_server        = %@&goto_pos_server[%#position_index%]%;
                    &goto_pos_entity        = %@&goto_pos_entity[%#position_index%]%;
                    &goto_pos_container     = %@&goto_pos_container[%#position_index%]%;
                    &goto_pos_override_look = %@&goto_pos_override_look[%#position_index%]%;
                    &goto_pos_chat_cancel   = %@&goto_pos_chat_cancel[%#position_index%]%;
                elseif((%&server% != "") && (%&coord_string% != ""));
                    &goto_pos_arr[]         = expandCoordStringToRange(%&coord_string%);
                    &goto_pos_min           = %&goto_pos_arr[0]%;
                    &goto_pos_max           = %&goto_pos_arr[1]%;
                    &goto_pos_server        = %&server%;
                    &goto_pos_entity        = "NULL";
                    &goto_pos_container     = "NULL";
                    &goto_pos_override_look = "NULL";
                    &goto_pos_chat_cancel   = "NULL";
                endif;
            endif;
            
            // Start moving towards the position we need to go to.
            if(true);
                // Setup loop variables
                if(true);
                    do_timeout      = #timeout_sec != -1;
                    #start_time     = %TIMESTAMP%;
                    #fn_timeout     = -1
                    do_open_gui     = ((%open_gui%) && (%&goto_pos_container% != "") && (%&goto_pos_container% != "NULL"));
                    log("do_open_gui : %do_open_gui%")
                    do_coord_bound  = ((%&goto_pos_min% != "NULL") && (%&goto_pos_max% != "NULL"));
                    if(%do_coord_bound%);
                        log("goto_pos_min %&goto_pos_min%, goto_pos_max %&goto_pos_max%")
                        #goto_pos_avg[] = getMiddlePointCoordRange(%&goto_pos_min%,%&goto_pos_max%);
                        #goto_pos_min[] = splitCoordString(%&goto_pos_min%);
                        #goto_pos_max[] = splitCoordString(%&goto_pos_max%);
                        
                        // Setup coordinate position points
                        if(true);
                            #goto_pos_min_x = %#goto_pos_min[0]%;
                            #goto_pos_min_y = %#goto_pos_min[1]%;
                            #goto_pos_min_z = %#goto_pos_min[2]%;
                            
                            #goto_pos_max_x = %#goto_pos_max[0]%;
                            #goto_pos_max_y = %#goto_pos_max[1]%;
                            #goto_pos_max_z = %#goto_pos_max[2]%;
                            
                            #goto_pos_avg_x = %#goto_pos_avg[0]%;
                            #goto_pos_avg_y = %#goto_pos_avg[1]%;
                            #goto_pos_avg_z = %#goto_pos_avg[2]%;
                            &goto_pos_avg   = "%#goto_pos_avg_x%|%#goto_pos_avg_y%|%#goto_pos_avg_z%";
                        endif;
                    endif;
                    
                    use_override_look = ((%do_open_gui%) && (%&goto_pos_override_look% != "NULL"));
                    if(%use_override_look%);
                        &override_look_pos[] = splitCoordString(%&goto_pos_override_look%);
                        &calc_look_x         = %&override_look_pos[0]%;
                        &calc_look_y         = %&override_look_pos[1]%;
                        &calc_look_z         = %&override_look_pos[2]%;
                    endif;
                    
                    use_chat_cancel = ((%do_open_gui%) && (%&goto_pos_chat_cancel% != "NULL"));
                    if(%use_chat_cancel%);
                        unset(%&goto_pos_chat_cancel%);
                    endif;
                    
                    #static_hub_x = -3;
                    #static_hub_y = 70;
                    #static_hub_z = -70;
                endif;
                do;
                    // Check if we should timeout and exit early
                    if(true);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            break;
                        elseif(%do_timeout%);
                            #elapsed_sec = %TIMESTAMP% - #start_time;
                            #fn_timeout  = #timeout_sec - #elapsed_sec;
                        endif;
                    endif;
                    
                    on_server = gotoServer(%&goto_pos_server%,100,%#fn_timeout%);
                    if(%on_server%);
                        // If we are on the correct server, check to see if we can exit now, or if we need to do more stuff.
                        pos_condition = !%do_coord_bound%;
                        if(%do_coord_bound%);
                            in_bounds_x   = withinBounds(%XPOS%,%#goto_pos_min_x%,%#goto_pos_max_x%);
                            in_bounds_y   = withinBounds(%YPOS%,%#goto_pos_min_y%,%#goto_pos_max_y%);
                            in_bounds_z   = withinBounds(%ZPOS%,%#goto_pos_min_z%,%#goto_pos_max_z%);
                            pos_condition = ((%in_bounds_x%) && (%in_bounds_y%) && (%in_bounds_z%));
                            debug_log(%@fn_debug%,%&script_debug_name%,"goto > in_bounds_x : %in_bounds_x%, in_bounds_y = %in_bounds_y%, in_bounds_z = %in_bounds_z%");
                        endif;
                        
                        gui_condition = !%do_open_gui%;
                        if(%do_open_gui%);
                            gui_condition = regexTest(%CONTAINERNAME%,%&goto_pos_container%);
                            log("gui_condition : %gui_condition% (%CONTAINERNAME%, %&goto_pos_container%)");
                            if(%use_chat_cancel%);
                                chat_cancel_val := "%%&goto_pos_chat_cancel%%";
                                if(%chat_cancel_val%);
                                    log("chat cancelled")
                                    break;
                                endif;
                            endif;
                        endif;
                        
                        return_boolean = ((%pos_condition%) && (%gui_condition%));
                        log("return_boolean: %return_boolean%")
                        if(!%return_boolean%);
                            if(!%pos_condition%);
                                use_baritone = %&goto_pos_server% != "SKYBLOCK_HUB";
                                
                                // If the server is HUB, check to see if it would be faster for us to /warp hub => navigate instead of just going there using Baritone.
                                if(%&goto_pos_server% == "SKYBLOCK_HUB");
                                    #curr_dist_x   = absDiff(%#goto_pos_avg_x%,%XPOS%);
                                    #curr_dist_y   = absDiff(%#goto_pos_avg_y%,%YPOS%);
                                    #curr_dist_z   = absDiff(%#goto_pos_avg_z%,%ZPOS%);
                                    #curr_sum_dist = #curr_dist_x + #curr_dist_y + #curr_dist_z;
                                    #hub_dist_x    = absDiff(%#goto_pos_avg_x%,%#static_hub_x%);
                                    #hub_dist_y    = absDiff(%#goto_pos_avg_y%,%#static_hub_y%);
                                    #hub_dist_z    = absDiff(%#goto_pos_avg_z%,%#static_hub_z%);
                                    #hub_sum_dist  = #hub_dist_x + #hub_dist_y + #hub_dist_z;
                                    use_baritone   = #hub_sum_dist >= #curr_sum_dist;
                                    
                                    &log_vars[] = split(", ","#curr_dist_x, #curr_dist_y, #curr_dist_z, #curr_sum_dist, #hub_dist_x, #hub_dist_y, #hub_dist_z, #hub_sum_dist, use_baritone");
                                    foreach(&log_vars[],&log_var,#lvi);
                                        &log_val = "%%&log_var%%";
                                        log("&7%#lvi% > %&log_var% : &d%&log_val%");
                                    next;
                                    
                                    if(!%use_baritone%);
                                        if(%do_timeout%);
                                            #elapsed_sec = %TIMESTAMP% - #start_time;
                                            #fn_timeout  = #timeout_sec - #elapsed_sec;
                                        endif;
                                        on_server = gotoServer("SKYBLOCK_HUB",100,%#fn_timeout%,true);
                                    endif;
                                endif;
                                
                                if(%use_baritone%);
                                    // Use Baritone to navigate to the "average" position.
                                    log("goto > 2154 goto_pos_avg : %&goto_pos_avg%")
                                    baritone_outcome = baritoneGoto(%&goto_pos_avg%,,%#fn_timeout%);
                                    if((%gui_condition%) && (%baritone_outcome%));
                                        return_boolean = true;
                                        break;
                                    endif;
                                endif;
                            elseif(!%gui_condition%);
                                // Attempt to open the correct Container.
                                if(!%use_override_look%);
                                    &entity_pos[] = getEntityPos(".*%&goto_pos_entity%",,5,true);
                                    &calc_look_x  = %&entity_pos[0]%;
                                    if(%&calc_look_x% == "");
                                        log("&4Unexpected Error in movement/index.txt fn#Goto: Cannot find entity with name &e%&goto_pos_entity%&4!")
                                        break;
                                    endif;
                                    &calc_look_y  = %&entity_pos[1]%;
                                    &calc_look_z  = %&entity_pos[2]%;
                                endif;
                                #calc_vars[] = fnCalcYawTo(%&calc_look_x%,%&calc_look_y%,%&calc_look_z%);
                                #calc_yaw    = %#calc_vars[0]%;
                                #calc_dist   = %#calc_vars[1]%;
                                #calc_pitch  = %#calc_vars[2]%;
                                localGUI("NONE");
                                
                                looks(%#calc_yaw%,%#calc_pitch%,"0.500");
                                key("use");
                                &init_container_string = getContainerString();
                                do(20);
                                    new_gui = enteredNewGUI(%&init_container_string%);
                                    wait("1t");
                                until(%new_gui%);
                            endif;
                        endif;
                    else;
                        // Not on Server, not really sure how to fix this ...
                        log("&4Unexpected Error in movement/index.txt fn#Goto: Not on correct Hypixel Server after attempting fn#GotoServer")
                        break;
                    endif;
                until((%return_boolean%) || (%func_timeout%));
            endif;
            
            return(%return_boolean%);
        endfunction;
    // gui/index/remoteGUI
        // Changes the current GUI to a remote GUI.
        // NOTE: For /viewcollection commands to work, CHATFILTER must include:
            // Expression:
                //    ifmatches(%CHATCLEAN%,"^You haven't found this item yet!$");
                //        @remote_gui_collection_unlock_exception = true;
                //    endif;
            // Params:
                // {string}    <&target_gui>                     String ENUM. List of available GUIs below.
                // {number}    [#wait_ticks=@#def_wait_ticks]    Amount of time to wait for in ticks (1t = 50ms)
                // {number}    [#timeout_sec=60]                 Maximum amount of seconds to spend attempting to enter the specified
                //                                               GUI. If this function takes more than or equal to this amount of seconds
                //                                               to complete, the function will exit and return False. Set to -1 for infinite.
            // Returns a Boolean indicating whether or not we were able to enter the specified GUI.
            // Example                       : in_gui = remoteGUI("SB_MENU");
            // Valid ENUMs for <&target_gui> :
                //  'SB_MENU'              : /sbmenu
                //  'TRADES'               : /sbmenu => emerald item
                //  'BOOSTER'              : /sbmenu => cookie item
                //  'STATS'                : /sbmenu => skull item (stats menu)
                //    'ACCESSORY_BAG'        : /sbmenu => accessory bag item (slot 53)
                //  'CALENDAR'             : /calendar
                //  'STORAGE'              : /storage
                //  'ENDERCHEST'           : /enderchest
                //  'PROFILES'             : /profiles
                //  'EFFECTS'              : /effects (note; cannot disable effects from this GUI)
                //  'CRAFT_ITEM'           : /craft
                //  'ANVIL'                : /anvil (only works if booster cookie effect is applied)
                //  'BAZAAR'               : /bazaar (only works if booster cookie effect is applied)
                //  'AUCTION_HOUSE'        : /auctions (only works if booster cookie effect is applied)
                //  'ENCHANTING'           : /enchantingtable (only works if booster cookie effect is applied)
                //  'SKILLS'               : /skills
                    //  'SKILLS_FARMING'       : /skills => farming
                    //  'SKILLS_MINING'        : /skills => mining
                    //  'SKILLS_COMBAT'        : /skills => combat
                    //  'SKILLS_FORAGING'      : /skills => foraging
                    //  'SKILLS_FISHING'       : /skills => fishing
                    //  'SKILLS_ENCHANTING'    : /skills => enchanting
                    //  'SKILLS_ALCHEMY'       : /skills => alchemy
                    //  'SKILLS_RUNECRAFTING'  : /skills => runecrafting
                    //  'SKILLS_SOCIAL'        : /skills => social
                    //  'SKILLS_TAMING'        : /skills => taming
                    //  'SKILLS_DUNGEONEERING' : /skills => dungeoneering
                //  'SB_SETTINGS'          : /viewsettings
                    //  'SB_SETTINGS_PERSONAL' : /viewsettings => personal
                    //  'SB_SETTINGS_COMMS'    : /viewsettings => comms
                    //  'SB_SETTINGS_IS'       : /viewsettings => island
                    //  'SB_SETTINGS_API'      : /viewsettings => api
                    //  'SB_SETTINGS_IS_MGMT'  : /viewsettings => island management
                //  'HY_SETTINGS'          : /settings
                    //  'HY_SETTINGS_GAME'     : /settings => game
                    //  'HY_SETTINGS_CHAT'     : /settings => chat
                    //  'HY_SETTINGS_SOCIAL'   : /settings => social
                    //  'HY_SETTINGS_LOBBY'    : /settings => lobby
                    //  'HY_SETTINGS_API'      : /settings => api
                    //  'HY_SETTINGS_GUILD'    : /settings => guild
                //  'COLLECTIONS'          : /collections
                    //  'COLLECTIONS_INK_SACK:3'             : /viewcollection INK_SACK:3             (Cocoa Beans)
                    //  'COLLECTIONS_CARROT_ITEM'            : /viewcollection CARROT_ITEM            (Carrot)
                    //  'COLLECTIONS_CACTUS'                 : /viewcollection CACTUS                 (Cactus)
                    //  'COLLECTIONS_RAW_CHICKEN'            : /viewcollection RAW_CHICKEN            (Raw Chicken)
                    //  'COLLECTIONS_SUGAR_CANE'             : /viewcollection SUGAR_CANE             (Sugar Cane)
                    //  'COLLECTIONS_PUMPKIN'                : /viewcollection PUMPKIN                (Pumpkin)
                    //  'COLLECTIONS_WHEAT'                  : /viewcollection WHEAT                  (Wheat)
                    //  'COLLECTIONS_SEEDS'                  : /viewcollection SEEDS                  (Seeds)
                    //  'COLLECTIONS_MUSHROOM_COLLECTION'    : /viewcollection MUSHROOM_COLLECTION    (Mushroom)
                    //  'COLLECTIONS_RABBIT'                 : /viewcollection RABBIT                 (Raw Rabbit)
                    //  'COLLECTIONS_NETHER_STALK'           : /viewcollection NETHER_STALK           (Nether Wart)
                    //  'COLLECTIONS_MUTTON'                 : /viewcollection MUTTON                 (Mutton)
                    //  'COLLECTIONS_MELON'                  : /viewcollection MELON                  (Melon)
                    //  'COLLECTIONS_POTATO_ITEM'            : /viewcollection POTATO_ITEM            (Potato)
                    //  'COLLECTIONS_LEATHER'                : /viewcollection LEATHER                (Leather)
                    //  'COLLECTIONS_PORK'                   : /viewcollection PORK                   (Raw Porkchop)
                    //  'COLLECTIONS_FEATHER'                : /viewcollection FEATHER                (Feather)
                    //  'COLLECTIONS_INK_SACK:4'             : /viewcollection INK_SACK:4             (Lapis Lazuli)
                    //  'COLLECTIONS_REDSTONE'               : /viewcollection REDSTONE               (Redstone)
                    //  'COLLECTIONS_COAL'                   : /viewcollection COAL                   (Coal)
                    //  'COLLECTIONS_ENDER_STONE'            : /viewcollection ENDER_STONE            (End Stone)
                    //  'COLLECTIONS_QUARTZ'                 : /viewcollection QUARTZ                 (Nether Quartz)
                    //  'COLLECTIONS_SAND'                   : /viewcollection SAND                   (Sand)
                    //  'COLLECTIONS_IRON_INGOT'             : /viewcollection IRON_INGOT             (Iron Ingot)
                    //  'COLLECTIONS_GEMSTONE_COLLECTION'    : /viewcollection GEMSTONE_COLLECTION    (Gemstone)
                    //  'COLLECTIONS_OBSIDIAN'               : /viewcollection OBSIDIAN               (Obsidian)
                    //  'COLLECTIONS_DIAMOND'                : /viewcollection DIAMOND                (Diamond)
                    //  'COLLECTIONS_COBBLESTONE'            : /viewcollection COBBLESTONE            (Cobblestone)
                    //  'COLLECTIONS_GLOWSTONE_DUST'         : /viewcollection GLOWSTONE_DUST         (Glowstone Dust)
                    //  'COLLECTIONS_GOLD_INGOT'             : /viewcollection GOLD_INGOT             (Gold Ingot)
                    //  'COLLECTIONS_GRAVEL'                 : /viewcollection GRAVEL                 (Gravel)
                    //  'COLLECTIONS_HARD_STONE'             : /viewcollection HARD_STONE             (Hard Stone)
                    //  'COLLECTIONS_MITHRIL_ORE'            : /viewcollection MITHRIL_ORE            (Mithril)
                    //  'COLLECTIONS_EMERALD'                : /viewcollection EMERALD                (Emerald)
                    //  'COLLECTIONS_ICE'                    : /viewcollection ICE                    (Ice)
                    //  'COLLECTIONS_NETHERRACK'             : /viewcollection NETHERRACK             (Netherrack)
                    //  'COLLECTIONS_ENDER_PEARL'            : /viewcollection ENDER_PEARL            (Ender Pearl)
                    //  'COLLECTIONS_SLIME_BALL'             : /viewcollection SLIME_BALL             (Slimeball)
                    //  'COLLECTIONS_MAGMA_CREAM'            : /viewcollection MAGMA_CREAM            (Magma Cream)
                    //  'COLLECTIONS_GHAST_TEAR'             : /viewcollection GHAST_TEAR             (Ghast Tear)
                    //  'COLLECTIONS_SULPHUR'                : /viewcollection SULPHUR                (Gunpowder)
                    //  'COLLECTIONS_ROTTEN_FLESH'           : /viewcollection ROTTEN_FLESH           (Rotten Flesh)
                    //  'COLLECTIONS_SPIDER_EYE'             : /viewcollection SPIDER_EYE             (Spider Eye)
                    //  'COLLECTIONS_BONE'                   : /viewcollection BONE                   (Bone)
                    //  'COLLECTIONS_BLAZE_ROD'              : /viewcollection BLAZE_ROD              (Blaze Rod)
                    //  'COLLECTIONS_STRING'                 : /viewcollection STRING                 (String)
                    //  'COLLECTIONS_LOG_2'                  : /viewcollection LOG_2                  (Acacia Wood)
                    //  'COLLECTIONS_LOG:1'                  : /viewcollection LOG:1                  (Spruce Wood)
                    //  'COLLECTIONS_LOG:3'                  : /viewcollection LOG:3                  (Jungle Wood)
                    //  'COLLECTIONS_LOG:2'                  : /viewcollection LOG:2                  (Birch Wood)
                    //  'COLLECTIONS_LOG'                    : /viewcollection LOG                    (Oak Wood)
                    //  'COLLECTIONS_LOG_2:1'                : /viewcollection LOG_2:1                (Dark Oak Wood)
                    //  'COLLECTIONS_WATER_LILY'             : /viewcollection WATER_LILY             (Lily Pad)
                    //  'COLLECTIONS_PRISMARINE_SHARD'       : /viewcollection PRISMARINE_SHARD       (Prismarine Shard)
                    //  'COLLECTIONS_INK_SACK'               : /viewcollection INK_SACK               (Ink Sack)
                    //  'COLLECTIONS_RAW_FISH'               : /viewcollection RAW_FISH               (Raw Fish)
                    //  'COLLECTIONS_RAW_FISH:3'             : /viewcollection RAW_FISH:3             (Pufferfish)
                    //  'COLLECTIONS_RAW_FISH:2'             : /viewcollection RAW_FISH:2             (Clownfish)
                    //  'COLLECTIONS_RAW_FISH:1'             : /viewcollection RAW_FISH:1             (Raw Salmon)
                    //  'COLLECTIONS_PRISMARINE_CRYSTALS'    : /viewcollection PRISMARINE_CRYSTALS    (Prismarine Crystals)
                    //  'COLLECTIONS_CLAY'                   : /viewcollection CLAY                   (Clay)
                    //  'COLLECTIONS_SPONGE'                 : /viewcollection SPONGE                 (Sponge)
        function remoteGUI(&target_gui,#tick_wait=20,#timeout_sec=60);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/gui/index.txt:489
            &script_debug_name = "&9remoteGUI";
            debug              = true;
            do_timeout         = #timeout_sec > 0;
            #start_time        = %TIMESTAMP%;
            
            // Validate input
            if(true);
                &valid_guis[] = split(", ","SB_MENU, TRADES, ACCESSORY_BAG, BOOSTER, STATS, CALENDAR, STORAGE, ENDERCHEST, PROFILES, EFFECTS, CRAFT_ITEM, ANVIL, BAZAAR, AUCTION_HOUSE, ENCHANTING, SKILLS, SKILLS_FARMING, SKILLS_MINING, SKILLS_COMBAT, SKILLS_FORAGING, SKILLS_FISHING, SKILLS_ENCHANTING, SKILLS_ALCHEMY, SKILLS_RUNECRAFTING, SKILLS_SOCIAL, SKILLS_TAMING, SKILLS_DUNGEONEERING, SB_SETTINGS, SB_SETTINGS_PERSONAL, SB_SETTINGS_COMMS, SB_SETTINGS_IS, SB_SETTINGS_API, SB_SETTINGS_IS_MGMT, HY_SETTINGS, HY_SETTINGS_GAME, HY_SETTINGS_CHAT, HY_SETTINGS_SOCIAL, HY_SETTINGS_LOBBY, HY_SETTINGS_API, HY_SETTINGS_GUILD, COLLECTIONS, COLLECTIONS_INK_SACK:3, COLLECTIONS_CARROT_ITEM, COLLECTIONS_CACTUS, COLLECTIONS_RAW_CHICKEN, COLLECTIONS_SUGAR_CANE, COLLECTIONS_PUMPKIN, COLLECTIONS_WHEAT, COLLECTIONS_SEEDS, COLLECTIONS_MUSHROOM_COLLECTION, COLLECTIONS_RABBIT, COLLECTIONS_NETHER_STALK, COLLECTIONS_MUTTON, COLLECTIONS_MELON, COLLECTIONS_POTATO_ITEM, COLLECTIONS_LEATHER, COLLECTIONS_PORK, COLLECTIONS_FEATHER, COLLECTIONS_INK_SACK:4, COLLECTIONS_REDSTONE, COLLECTIONS_COAL, COLLECTIONS_ENDER_STONE, COLLECTIONS_QUARTZ, COLLECTIONS_SAND, COLLECTIONS_IRON_INGOT, COLLECTIONS_GEMSTONE_COLLECTION, COLLECTIONS_OBSIDIAN, COLLECTIONS_DIAMOND, COLLECTIONS_COBBLESTONE, COLLECTIONS_GLOWSTONE_DUST, COLLECTIONS_GOLD_INGOT, COLLECTIONS_GRAVEL, COLLECTIONS_HARD_STONE, COLLECTIONS_MITHRIL_ORE, COLLECTIONS_EMERALD, COLLECTIONS_ICE, COLLECTIONS_NETHERRACK, COLLECTIONS_ENDER_PEARL, COLLECTIONS_SLIME_BALL, COLLECTIONS_MAGMA_CREAM, COLLECTIONS_GHAST_TEAR, COLLECTIONS_SULPHUR, COLLECTIONS_ROTTEN_FLESH, COLLECTIONS_SPIDER_EYE, COLLECTIONS_BONE, COLLECTIONS_BLAZE_ROD, COLLECTIONS_STRING, COLLECTIONS_LOG_2, COLLECTIONS_LOG:1, COLLECTIONS_LOG:3, COLLECTIONS_LOG:2, COLLECTIONS_LOG, COLLECTIONS_LOG_2:1, COLLECTIONS_WATER_LILY, COLLECTIONS_PRISMARINE_SHARD, COLLECTIONS_INK_SACK, COLLECTIONS_RAW_FISH, COLLECTIONS_RAW_FISH:3, COLLECTIONS_RAW_FISH:2, COLLECTIONS_RAW_FISH:1, COLLECTIONS_PRISMARINE_CRYSTALS, COLLECTIONS_CLAY, COLLECTIONS_SPONGE");
                #valid_index  = indexof(&valid_guis[],,%&target_gui%);
                &target_gui   = ucase(%&valid_guis[%#valid_index%]%);
                if(%#valid_index% == -1);
                    debug_error(%debug%,%&script_debug_name%,"Invalid TargetGUI &4%&target_gui%&7 passed.");
                    return(False);
                endif;
                debug_log(%debug%,%&script_debug_name%,"TargetGUI: %&target_gui%");
            endif;
            
            // Define different GUI types.
            if(true);
                // SkyBlock Command GUIs (has a shortcut command, no caveats as to when the command can be used).
                if(true);
                    // GUI Parameter Terms
                    &command_guis[] = split(", ","HY_SETTINGS, SB_SETTINGS, SB_MENU, CALENDAR, STORAGE, ENDERCHEST, PROFILES, EFFECTS, CRAFT_ITEM, SKILLS, COLLECTIONS, COLLECTIONS_INK_SACK:3, COLLECTIONS_CARROT_ITEM, COLLECTIONS_CACTUS, COLLECTIONS_RAW_CHICKEN, COLLECTIONS_SUGAR_CANE, COLLECTIONS_PUMPKIN, COLLECTIONS_WHEAT, COLLECTIONS_SEEDS, COLLECTIONS_MUSHROOM_COLLECTION, COLLECTIONS_RABBIT, COLLECTIONS_NETHER_STALK, COLLECTIONS_MUTTON, COLLECTIONS_MELON, COLLECTIONS_POTATO_ITEM, COLLECTIONS_LEATHER, COLLECTIONS_PORK, COLLECTIONS_FEATHER, COLLECTIONS_INK_SACK:4, COLLECTIONS_REDSTONE, COLLECTIONS_COAL, COLLECTIONS_ENDER_STONE, COLLECTIONS_QUARTZ, COLLECTIONS_SAND, COLLECTIONS_IRON_INGOT, COLLECTIONS_GEMSTONE_COLLECTION, COLLECTIONS_OBSIDIAN, COLLECTIONS_DIAMOND, COLLECTIONS_COBBLESTONE, COLLECTIONS_GLOWSTONE_DUST, COLLECTIONS_GOLD_INGOT, COLLECTIONS_GRAVEL, COLLECTIONS_HARD_STONE, COLLECTIONS_MITHRIL_ORE, COLLECTIONS_EMERALD, COLLECTIONS_ICE, COLLECTIONS_NETHERRACK, COLLECTIONS_ENDER_PEARL, COLLECTIONS_SLIME_BALL, COLLECTIONS_MAGMA_CREAM, COLLECTIONS_GHAST_TEAR, COLLECTIONS_SULPHUR, COLLECTIONS_ROTTEN_FLESH, COLLECTIONS_SPIDER_EYE, COLLECTIONS_BONE, COLLECTIONS_BLAZE_ROD, COLLECTIONS_STRING, COLLECTIONS_LOG_2, COLLECTIONS_LOG:1, COLLECTIONS_LOG:3, COLLECTIONS_LOG:2, COLLECTIONS_LOG, COLLECTIONS_LOG_2:1, COLLECTIONS_WATER_LILY, COLLECTIONS_PRISMARINE_SHARD, COLLECTIONS_INK_SACK, COLLECTIONS_RAW_FISH, COLLECTIONS_RAW_FISH:3, COLLECTIONS_RAW_FISH:2, COLLECTIONS_RAW_FISH:1, COLLECTIONS_PRISMARINE_CRYSTALS, COLLECTIONS_CLAY, COLLECTIONS_SPONGE");
                    
                    // Commands to issue to enter the correct GUI while on SkyBlock.
                    &command_text[] = split(", ","/settings, /viewsettings, /sbmenu, /calendar, /storage, /enderchest, /profiles, /effects, /craft, /skills, /collections, /viewcollection INK_SACK:3, /viewcollection CARROT_ITEM, /viewcollection CACTUS, /viewcollection RAW_CHICKEN, /viewcollection SUGAR_CANE, /viewcollection PUMPKIN, /viewcollection WHEAT, /viewcollection SEEDS, /viewcollection MUSHROOM_COLLECTION, /viewcollection RABBIT, /viewcollection NETHER_STALK, /viewcollection MUTTON, /viewcollection MELON, /viewcollection POTATO_ITEM, /viewcollection LEATHER, /viewcollection PORK, /viewcollection FEATHER, /viewcollection INK_SACK:4, /viewcollection REDSTONE, /viewcollection COAL, /viewcollection ENDER_STONE, /viewcollection QUARTZ, /viewcollection SAND, /viewcollection IRON_INGOT, /viewcollection GEMSTONE_COLLECTION, /viewcollection OBSIDIAN, /viewcollection DIAMOND, /viewcollection COBBLESTONE, /viewcollection GLOWSTONE_DUST, /viewcollection GOLD_INGOT, /viewcollection GRAVEL, /viewcollection HARD_STONE, /viewcollection MITHRIL_ORE, /viewcollection EMERALD, /viewcollection ICE, /viewcollection NETHERRACK, /viewcollection ENDER_PEARL, /viewcollection SLIME_BALL, /viewcollection MAGMA_CREAM, /viewcollection GHAST_TEAR, /viewcollection SULPHUR, /viewcollection ROTTEN_FLESH, /viewcollection SPIDER_EYE, /viewcollection BONE, /viewcollection BLAZE_ROD, /viewcollection STRING, /viewcollection LOG_2, /viewcollection LOG:1, /viewcollection LOG:3, /viewcollection LOG:2, /viewcollection LOG, /viewcollection LOG_2:1, /viewcollection WATER_LILY, /viewcollection PRISMARINE_SHARD, /viewcollection INK_SACK, /viewcollection RAW_FISH, /viewcollection RAW_FISH:3, /viewcollection RAW_FISH:2, /viewcollection RAW_FISH:1, /viewcollection PRISMARINE_CRYSTALS, /viewcollection CLAY, /viewcollection SPONGE");
                    
                    // Regular Expression to match against CONTAINERNAME to determine whether we are in the correct GUI.
                    &command_expr[] = split(", ","Game Settings, Settings, SkyBlock Menu, Calendar and Events, Storage, Ender Chest, Profile Management, Active Effects, Craft Item, Your Skills, ^Collection$, ^Cocoa Beans Collection$, ^Carrot Collection$, ^Cactus Collection$, ^Raw Chicken Collection$, ^Sugar Cane Collection$, ^Pumpkin Collection$, ^Wheat Collection$, ^Seeds Collection$, ^Mushroom Collection$, ^Raw Rabbit Collection$, ^Nether Wart Collection$, ^Mutton Collection$, ^Melon Collection$, ^Potato Collection$, ^Leather Collection$, ^Raw Porkchop Collection$, ^Feather Collection$, ^Lapis Lazuli Collection$, ^Redstone Collection$, ^Coal Collection$, ^End Stone Collection$, ^Nether Quartz Collection$, ^Sand Collection$, ^Iron Ingot Collection$, ^Gemstone Collection$, ^Obsidian Collection$, ^Diamond Collection$, ^Cobblestone Collection$, ^Glowstone Dust Collection$, ^Gold Ingot Collection$, ^Gravel Collection$, ^Hard Stone Collection$, ^Mithril Collection$, ^Emerald Collection$, ^Ice Collection$, ^Netherrack Collection$, ^Ender Pearl Collection$, ^Slimeball Collection$, ^Magma Cream Collection$, ^Ghast Tear Collection$, ^Gunpowder Collection$, ^Rotten Flesh Collection$, ^Spider Eye Collection$, ^Bone Collection$, ^Blaze Rod Collection$, ^String Collection$, ^Acacia Wood Collection$, ^Spruce Wood Collection$, ^Jungle Wood Collection$, ^Birch Wood Collection$, ^Oak Wood Collection$, ^Dark Oak Wood Collection$, ^Lily Pad Collection$, ^Prismarine Shard Collection$, ^Ink Sack Collection$, ^Raw Fish Collection$, ^Pufferfish Collection$, ^Clownfish Collection$, ^Raw Salmon Collection$, ^Prismarine Crystals Collection$, ^Clay Collection$, ^Sponge Collection$");
                    
                    // SkyBlock Skill GUIs
                    if(true);
                        // GUI Parameter Terms
                        &sb_skill_guis[] = split(", ","SKILLS_FARMING, SKILLS_MINING, SKILLS_COMBAT, SKILLS_FORAGING, SKILLS_FISHING, SKILLS_ENCHANTING, SKILLS_ALCHEMY, SKILLS_RUNECRAFTING, SKILLS_SOCIAL, SKILLS_TAMING, SKILLS_DUNGEONEERING");
                        
                        // Commands to issue to enter the correct GUI while on SkyBlock.
                        &sb_skill_text[] = split(", ","/viewskill FARMING, /viewskill MINING, /viewskill COMBAT, /viewskill FORAGING, /viewskill FISHING, /viewskill ENCHANTING, /viewskill ALCHEMY, /viewskill RUNECRAFTING, /viewskill SOCIAL, /viewskill TAMING, /viewskill DUNGEONEERING");
                        
                        // Regular Expression to match against CONTAINERNAME to determine whether we are in the correct GUI.
                        &sb_skill_expr[] = split(", ","Farming Skill, Mining Skill, Combat Skill, Foraging Skill, Fishing Skill, Enchanting Skill, Alchemy Skill, Runecrafting Skill, Social Skill, Taming Skill, Dungeoneering");
                        
                        push(&command_guis[],&sb_skill_guis[*]);
                        push(&command_text[],&sb_skill_text[*]);
                        push(&command_expr[],&sb_skill_expr[*]);
                    endif;
                endif;
                
                // SBMENU GUIs (must type /sbmenu before continuing).
                if(true);
                    // GUI Parameter Terms
                    &sbmenu_guis[] = split(", ","TRADES, BOOSTER, STATS, ACCESSORY_BAG");
                    
                    // Item Base Items to look for in SBMENU to click on to progress
                    &sbmenu_item[] = split(", ","emerald, cookie, skull, skull");
                    
                    // Item Display Names to look for in SBMENU to click on to progress
                    &sbmenu_name[] = split(", ","Trades, Booster Cookie, Your SkyBlock Profile, Accessory Bag");
                    
                    // Regular Expressions to match against CONTAINERNAME to determine whether we are in the correct GUI.
                    &sbmenu_expr[] = split(", ","Trades, Booster Cookie, Your SkyBlock Profile, Accessory Bag");
                endif;
                
                // SkyBlock Setting GUIs (must type /viewsettings before continuing).
                if(true);
                    // GUI Parameter Terms
                    &sbsetting_guis[] = split(", ","SB_SETTINGS_PERSONAL, SB_SETTINGS_COMMS, SB_SETTINGS_IS, SB_SETTINGS_API, SB_SETTINGS_IS_MGMT");
                    
                    // Item Base Items to look for in SB_SETTINGS to click on to progress
                    &sbsetting_item[] = split(", ","skull, sign, repeater, comparator, grass");
                    
                    // Item Display Names to look for in SB_SETTINGS to click on to progress
                    &sbsetting_name[] = split(", ","Personal, Comms, Island Settings, API Settings, Island Management");
                    
                    // Regular Expressions to match against CONTAINERNAME to determine whether we are in the correct GUI.
                    &sbsetting_expr[] = split(", ","Settings - Personal, Settings - Comms, Settings - Island Settings, Settings - API, Island Management");
                endif;
                
                // Hypixel Setting GUIs (must type /settings before continuing).
                if(true);
                    // GUI Parameter Terms
                    &hysetting_guis[] = split(", ","HY_SETTINGS_GAME, HY_SETTINGS_CHAT, HY_SETTINGS_SOCIAL, HY_SETTINGS_LOBBY, HY_SETTINGS_API, HY_SETTINGS_GUILD");
                    
                    // Item Base Items to look for in HY_SETTINGS to click on to progress
                    &hysetting_item[] = split(", ","comparator, paper, iron_bars, nether_star, web, dye");
                    
                    // Item Display Names to look for in HY_SETTINGS to click on to progress
                    &hysetting_name[] = split(", ","Game Settings, Chat Settings, Social Settings, Lobby Settings, API Settings, Personal Guild Settings");
                    
                    // Regular Expressions to match against CONTAINERNAME to determine whether we are in the correct GUI.
                    &hysetting_expr[] = split(", ","Game Settings, Chat Settings, Social Settings, Lobby Settings, API Settings, Personal Guild Settings");
                endif;
                
                // Booster Cookie Effect GUIs (must have Booster Cookie Effect enabled).
                if(true);
                    // GUI Parameter Terms
                    &booster_guis[] = split(", ","BOOSTER, ANVIL, BAZAAR, AUCTION_HOUSE, ENCHANTING");
                    
                    // Commands to issue to enter the correct GUI while on SkyBlock.
                    &booster_text[] = split(", ","/sbmenu, /av, /bz, /ah, /et");
                    
                    // Item Base Items to look for in SBMENU to Progress (only required for 'BOOSTER' exception)
                    &booster_item[] = split(", ","cookie");
                    
                    // Item Display Names to look for in SBMENU to click on to progress (only required for 'BOOSTER' exception)
                    &booster_name[] = split(", ","Booster Cookie");
                    
                    &baz_strings = "(?:Farming|Mining|Combat|Woods & Fishes|Oddities)";
                    
                    // Regular Expression to match against CONTAINERNAME to determine whether we are in the correct GUI.
                    &booster_expr[] = split(", ","Booster Cookie, Anvil, Bazaar \u279C %&baz_strings%, ^(?:Co-op )?Auction House$, ^Enchant Item$");
                endif;
            endif;
            
            // Find the type of GUI we are entering.
            if(true);
                #command_index    = indexof(&command_guis[],,%&target_gui%);
                #sbmenu_index     = indexof(&sbmenu_guis[],,%&target_gui%);
                #sbsetting_index  = indexof(&sbsetting_guis[],,%&target_gui%);
                #hysetting_index  = indexof(&hysetting_guis[],,%&target_gui%);
                #booster_index    = indexof(&booster_guis[],,%&target_gui%);
                #collection_index = indexof(&collection_guis[],,%&target_gui%);
                
                // For any of the GUIs categorized under command_guis, sbmenu_guis, sbsetting_guis, and booster_guis,
                // we have to be on some sort of SkyBlock Server for them to work. So, if we are entering a GUI found
                // in any of those arrays, get onto a SkyBlock Server beforehand.
                if((#collection_index != -1) || (#command_index != -1) || (#sbmenu_index != -1) || (#sbsetting_index != -1) || (#booster_index != -1));
                    debug_log(%debug%,%&script_debug_name%,"Using a SkyBlock Only command, making sure we are on SkyBlock before command execution...");
                    #goto_server_timeout = -1;
                    do;
                        if(%do_timeout%);
                            #goto_server_timeout = %#timeout_sec% - (%TIMESTAMP% - %#start_time%);
                        endif;
                        on_server = call("gotoServer","SKYBLOCK",100,%#goto_server_timeout%);
                        if(%on_server%);
                            break;
                        endif;
                        wait("1t");
                        
                        func_timeout = ((%do_timeout%) && ((%TIMESTAMP% - %#start_time%) >= %#timeout_sec%));
                    until((%func_timeout%) || (%on_server%));
                    if(%func_timeout%);
                        #elapsed_sec  = %TIMESTAMP% - %#start_time%;
                        &elapsed_time = sectotime(%#elapsed_sec%);
                        debug_error(%debug%,%&script_debug_name%,"Function timed out during gotoServer calls (elapsed time: &4%&elapsed_time%&7).");
                        return(False);
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"On a valid SkyBlock Server, continuing on...");
                endif;
                
                // Handle Booster stuff beforehand if needed (check if effect is applied).
                if(%#booster_index% != -1);
                    debug_log(%debug%,%&script_debug_name%,"Using a Booster Cookie function");
                    booster_enabled = isEffectEnabled("COOKIE");
                    if(!%booster_enabled%);
                        debug_error(%debug%,%&script_debug_name%,"Booster Cookie effect required for TargetGUI: &4%&target_gui%&7.");
                        return(False);
                    endif;
                endif;
                
                // Handle the unique actions required of each remote GUI type.
                if(true);
                    if((%#booster_index% != -1) || (%#command_index% != -1));
                        // Can just issue commands, no need to open GUIs beforehand.
                        if(%#booster_index% != -1);
                            &command_text     = %&booster_text[%#booster_index%]%;
                            &exit_expr        = %&booster_expr[%#booster_index%]%;
                            booster_exception = %&target_gui% == "BOOSTER";
                            if(%booster_exception%);
                                init_gui   = true;
                                &init_gui  = "SB_MENU";
                                &next_item = %&booster_item[%#booster_index%]%;
                                &next_name = %&booster_name[%#booster_index%]%;
                            endif;
                        elseif(%#command_index% != -1);
                            &command_text     = %&command_text[%#command_index%]%;
                            &exit_expr        = %&command_expr[%#command_index%]%;
                        endif;
                    else;
                        init_gui = true;
                        // Must enter some holding menu before continuing.
                        if(%#sbmenu_index% != -1);
                            // Must enter the 'SkyBlock Menu' (SB_MENU) GUI before continuing.
                            &init_gui  = "SB_MENU";
                            &next_item = %&sbmenu_item[%#sbmenu_index%]%;
                            &next_name = %&sbmenu_name[%#sbmenu_index%]%;
                            &exit_expr = %&sbmenu_expr[%#sbmenu_index%]%;
                        elseif(%#sbsetting_index% != -1);
                            // Must enter the 'SkyBlock Settings' (SB_SETTINGS) GUI before continuing.
                            &init_gui  = "SB_SETTINGS";
                            &next_item = %&sbsetting_item[%#sbsetting_index%]%;
                            &next_name = %&sbsetting_name[%#sbsetting_index%]%;
                            &exit_expr = %&sbsetting_expr[%#sbsetting_index%]%;
                        elseif(%#hysetting_index% != -1);
                            // Must enter the 'Hypixel Settings' (HY_SETTINGS) GUI before continuing.
                            &init_gui  = "HY_SETTINGS";
                            &next_item = %&hysetting_item[%#hysetting_index%]%;
                            &next_name = %&hysetting_name[%#hysetting_index%]%;
                            &exit_expr = %&hysetting_expr[%#hysetting_index%]%;
                        endif;
                    endif;
                    
                    do;
                        ifmatches(%CONTAINERNAME%,%&exit_expr%);
                            debug_log(%debug%,%&script_debug_name%,"Breaking, containername matches exit expr (%CONTAINERNAME%, %&exit_expr%)");
                            break;
                        endif;
                        
                        // Check for function timeout
                        if(%do_timeout%);
                            func_timeout = ((%TIMESTAMP% - %#start_time%) >= %#timeout_sec%);
                            if(%func_timeout%);
                                debug_error(%debug%,%&script_debug_name%,"Function timed out while attempting to open a GUI Container.");
                                break;
                            endif;
                        endif;
                        
                        // Execute GUI actions depending on what type of GUI we are currently in and where we need to go.
                        if(true);
                            // Enter the "pre-requisite" GUI, or echo the Command needed to enter the GUI we want to enter.
                            if(%GUI% == "NONE");
                                in_init_gui = false;
                                // Enter the "pre-requisite" GUI.
                                if(%init_gui%);
                                    in_init_gui = call("remoteGUI",%&init_gui%,%#tick_wait%);
                                else;
                                    // Echo the Command needed to enter the GUI we want to enter.
                                    debug_log(%debug%,%&script_debug_name%,"echoing command %&command_text%...");
                                    unset(@remote_gui_collection_unlock_exception);
                                    echo("%&command_text%");
                                    do(%#tick_wait%);
                                        wait("1t");
                                    while((%GUI% == "NONE") && (!%@remote_gui_collection_unlock_exception%));
                                    if(%@remote_gui_collection_unlock_exception%);
                                        debug_error(%debug%,%&script_debug_name%,"Do not have collection '%&target_gui%' unlocked yet!");
                                        break;
                                    endif;
                                endif;
                            elseif((%init_gui%) && (%in_init_gui%));
                                // In the "pre-requisite" GUI, find the item we want to click.
                                if(true);
                                    // Iterate over Dynamic Container Slots
                                    if(true);
                                        #found_slot = -1;
                                        #r_start    = 0;
                                        #r_end      = %CONTAINERSLOTS% - 37;
                                        &r_item     = "%&next_item%";
                                        &r_name     = "%&next_name%";
                                        for(#r_slot,%#r_start%,%#r_end%);
                                            #f_slot = %#r_slot%;
                                            if(%&r_item%);
                                                getslot(%&r_item%,#f_slot,%#r_offset%);
                                            endif;
                                            
                                            if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                                                #r_offset = %#f_slot% + 1;
                                                &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                                &f_nbt    = strip(%&f_nbt%);
                                                &f_name   = getItemName(%&f_nbt%,%&f_item%);
                                                &f_sbid   = getItemSBID(%&f_nbt%);
                                                m_item    = ((!%&r_item%) || (%&r_item% == %&f_item%));
                                                m_name    = ((!%&r_name%) || (%&r_name% == %&f_name%));
                                                m_sbid    = ((!%&r_sbid%) || (%&r_sbid% == %&f_sbid%));
                                                m_match   = ((%m_item%) && (%m_name%) && (%m_sbid%));
                                                if(%m_match%);
                                                    #found_slot = %#f_slot%;
                                                    break;
                                                endif;
                                            else;
                                                break;
                                            endif;
                                        next;
                                    endif;
                                    
                                    if(%#found_slot% != -1);
                                        &init_gui_string = getContainerString();
                                        entered_new_gui  = false;
                                        do;
                                            slotclick(%#found_slot%);
                                            do(%#tick_wait%);
                                                wait("1t");
                                                entered_new_gui = enteredNewGUI(%&init_gui_string%);
                                            while(!%entered_new_gui%);
                                        while(!%entered_new_gui%);
                                        in_init_gui = !%entered_new_gui%;
                                    else;
                                        debug_error(%debug%,%&script_debug_name%,"Cannot find 'next' item (base: %&next_item%, name: %&next_name%). GUI: %GUI%, CONTAINERNAME: %CONTAINERNAME%, CONTAINERSLOTS: %CONTAINERSLOTS%.");
                                        break;
                                    endif;
                                endif;
                            else;
                                // In a GUI that is not "NONE", have to leave it.
                                exited_gui = localGUI("NONE",%#tick_wait%);
                            endif;
                        endif;
                    untilmatches(%CONTAINERNAME%,%&exit_expr%);
                endif;
            endif;
            
            ifmatches(%CONTAINERNAME%,%&exit_expr%);
                debug_log(%debug%,%&script_debug_name%,"Success!");
                return_boolean = true;
            else;
                debug_log(%debug%,%&script_debug_name%,"Failure!");
            endif;
            return(%return_boolean%);
        endfunction;
    // tablist/index/isCookieEnabled
        // Checks if the Booster Cookie effect is currently enabled.
            // Params:
            //      {number} [#expiry_offset_sec=0] An offset in seconds to apply to the real expiry timestamp used
            //                                      to report whether the effect should be considered 'active' or not.
            //                                      For example, if set to 300, if the cookie expires within 300 seconds / 5 min,
            //                                      will return false (when otherwise, it would return true.)
            //
            // Returns a Boolean that is true if Cookie is enabled, false otherwise.
        function isCookieEnabled(#expiry_offset_sec=0);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/tablist/index.txt:48
            #cookie_exp_ts = getCookieExpiryTimestamp();
            cookie_enabled = %TIMESTAMP% < (#cookie_exp_ts - #expiry_offset_sec);
            return(%cookie_enabled%);
        endfunction;
    // auctions/index/auctionsOpen
        // Opens the Auction House to the Main GUI.
            // Params:
                // {boolean} [allow_command=true]    Whether or not to allow the usage of the /bz Command.
                // {number} [#tick_wait=20]          Amount of ticks to wait between clicks.
                // {number} [#timeout_sec=30]        Max seconds fn can run for before timing out. <= 0 to infinite loop until success.
            // Returns a String ENUM of:
                // SUCCESS          Function was successful
                // ERROR_TIMEOUT    Function timed out
                // ERROR_CLOSED     Auction House is Closed
                // ERROR_UNKNOWN    Unknown Error occurred
            // Example:
            //    &auctions_opened = auctionsOpen(%allow_command%,%#tick_wait%,%#timeout_sec%);
            //    if(%&auctions_opened% == "SUCCESS");
            //    else;
            //        if(%&auctions_opened% == "ERROR_TIMEOUT");
            //        elseif(%&auctions_opened% == "ERROR_CLOSED");
            //        elseif(%&auctions_opened% == "ERROR_UNKNOWN");
            //        endif;
            //    endif;
        function auctionsOpen(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/index.txt:20
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&9auctionsOpen&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &target_guis[]     = split(", ","Co-op Auction House, Auction House");
                &str_enum_success  = "SUCCESS";
                &str_enum_timeout  = "ERROR_TIMEOUT";
                &str_enum_closed   = "ERROR_CLOSED";
                &str_enum_unknown  = "ERROR_UNKNOWN";
                
                debug_log(%debug%,%&script_debug_name%,"allow_command: %allow_command%, tick_wait: %#tick_wait%, timeout_sec: %#timeout_sec%");
            endif;
            
            // Begin Looping until we are in the correct GUI.
            if(true);
                &exact_auction_guis[] = split(", ","Create Auction, Create BIN Auction, Auction Stats, Auctions Browser, Your Bids");
                &rough_auction_guis[] = split(", ","BIN Auction View, Auction View");
                &regex_auction_gui    = "^Auctions: \".*";
                do;
                    // 1. Check if we are in a valid GUI
                    if(%GUI% == "GUICHEST");
                        #target_index = indexof(&target_guis[],,%CONTAINERNAME%);
                        if(%#target_index% != -1);
                            &return_string = %&str_enum_success%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Check if the Function has timed out
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out");
                            &return_string = %&str_enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 3. Figure out what action to take dependant on which GUI we are currently in.
                    if(true);
                        &action_type = "OPEN";
                        if(%GUI% == "GUICHEST");
                            #exact_index = indexof(&exact_auction_guis[],,%CONTAINERNAME%);
                            #rough_index = indexof(&rough_auction_guis[],,%CONTAINERNAME%);
                            ifmatches(%CONTAINERNAME%,%&regex_auction_gui%);
                                &action_type = "BACK";
                            elseif(%#exact_index% != -1);
                                &action_type = "BACK";
                            elseif(%#rough_index% != -1);
                                &action_type = "CLOSE";
                                #arrow_slot = findItemContainer(false,"MCID: arrow","NAME: Go Back");
                                if(%#arrow_slot% != -1);
                                    &action_type = "BACK";
                                endif;
                            else;
                                &action_type = "CLOSE";
                            endif;
                        elseif(%GUI% != "NONE");
                            &action_type = "CLOSE";
                        endif;
                        
                        if(%&action_type% == "CLOSE");
                            localGUI("NONE");
                        elseif(%&action_type% == "BACK");
                            #arrow_slot = findItemContainer(false,"MCID: arrow","NAME: Go Back");
                            if(%#arrow_slot% != -1);
                                &init_gui     = getContainerString(true);
                                #waited_ticks = 0;
                                do;
                                    // 1. Check if we are in a valid GUI
                                    if(%GUI% == "GUICHEST");
                                        #target_index = indexof(&target_guis[],,%CONTAINERNAME%);
                                        if(%#target_index% != -1);
                                            &return_string = %&str_enum_success%;
                                            break;
                                        endif;
                                    endif;
                                    
                                    // 2. Check if the Function has timed out
                                    if(%do_timeout%);
                                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        if(%func_timeout%);
                                            debug_error(%debug%,%&script_debug_name%,"Function timed out");
                                            &return_string = %&str_enum_timeout%;
                                            break;
                                        endif;
                                    endif;
                                    
                                    // 3. Check if we can click
                                    can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                                    if(%can_click%);
                                        slotclick(%#arrow_slot%);
                                    endif;
                                    
                                    // 4. Check if the GUI has updated
                                    gui_updated = enteredNewGUI(%&init_gui%,true);
                                    if(%gui_updated%);
                                        break;
                                    endif;
                                    
                                    wait("1t");
                                    inc(#waited_ticks);
                                until((%gui_updated%) || (%&return_string% != ""));
                            endif;
                        elseif(%&action_type% == "OPEN");
                            if(%allow_command%);
                                use_command = isCookieEnabled(30);
                            endif;
                            
                            debug_log(%debug%,%&script_debug_name%,"allow_command: %allow_command%, use_command: %use_command%");
                            
                            #use_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            if(%use_command%);
                                entered_gui  = remoteGUI("AUCTION_HOUSE",%#tick_wait%,%#use_timeout%);
                            else;
                                entered_gui  = goto("AUCTION",true,%#use_timeout%);
                            endif;
                        endif;
                    endif;
                    
                    wait("1t");
                until(%&return_string% != "");
            endif;
            
            return(%&return_string%);
        endfunction;
    // auctions/indexAuctions/auctionsIndexPersonalListings
        // Indexes all of the Auctions we have listed for Sale and returns their State.
            // Params:
                // {boolean} [allow_command=true]    Whether or not to allow the usage of the /bz Command.
                // {number} [#tick_wait=20]          Amount of ticks to wait between clicks.
                // {number} [#timeout_sec=30]        Max seconds fn can run for before timing out. <= 0 to infinite loop until success.
        function auctionsIndexPersonalListings(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/indexAuctions.txt:176
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&eauctionsIndexBids&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
            endif;
            
            // Loop until we get a valid return value.
            if(true);
                bids_indexed = false;
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out!");
                            break;
                        endif;
                    endif;
                    
                    // 2. Get into the Main Auctions GUI
                    if(true);
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &auctions_opened   = auctionsOpen(%allow_command%,%#tick_wait%,%#recursive_timeout%);
                        if(%&auctions_opened% == "SUCCESS");
                            #found_slot = findItemContainer(false,"MCID: golden_horse_armor","NAME: Manage Auctions","SLOT: 15");
                            if(%#found_slot% != -1);
                                &found_item = getslotitemnbt(%#found_slot%,,#found_stack,#found_data,&found_nbt);
                                &found_nbt  = strip(%&found_nbt%);
                                ifmatches(%&found_nbt%,"You own (\d+) auctions",#auctions,1);
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    updated_gui        = containerClick(%#found_slot%,%#recursive_timeout%,%#tick_wait%);
                                    if(%updated_gui%);
                                        #container_start = 0;
                                        #container_end   = %CONTAINERSLOTS% - 37;
                                        for(#container_slot,%#container_start%,%#container_end%);
                                            &container_item = getslotitemnbt(%#container_slot%,,#container_stack,#container_data,&container_nbt);
                                            &container_nbt  = strip(%&container_nbt%);
                                            if((%&container_item% != "air") && ((%&container_item% != "stained_glass_pane") || (%#container_data% != 15)));
                                                &container_name      = getItemName(%&container_nbt%,%&container_item%);
                                                &container_sbid      = getItemSBID(%&container_nbt%);
                                                &test_container_name = trim(%&container_name%);
                                                if((%&test_container_name% != "") && (%&test_container_name% != "Claim All") && (%&test_container_name% != "Go Back") && (%&test_container_name% != "Sort") && (%&test_container_name% != "Create Auction"));
                                                    &listing_info[]     = auctionsIndexSlotData(%#container_slot%);
                                                    listing_info_valid := %&listing_info[0]%;
                                                    if(%listing_info_valid%);
                                                        &return_array[] = join("|",&listing_info[]);
                                                    endif;
                                                endif;
                                            endif;
                                        next;
                                        bids_indexed = true;
                                    endif;
                                elseifnotmatches(%&found_nbt%,"Refreshing");
                                    debug_error(%debug%,%&script_debug_name%,"No bids are available to index!");
                                    bids_indexed = true;
                                    break;
                                endif;
                            endif;
                        elseif(%&auctions_opened% == "ERROR_CLOSED");
                            debug_error(%debug%,%&script_debug_name%,"Auction House is temporarily closed, cannot access it!");
                            break;
                        endif;
                    endif;
                    
                    wait("1t");
                until(%bids_indexed%);
            endif;
            return(&return_array[]);
        endfunction;
    // auctions/indexAuctions/auctionsIndexBids
        // Indexes all of the Auctions we have placed bids for and returns their State.
            // Params:
                // {boolean} [allow_command=true]    Whether or not to allow the usage of the /bz Command.
                // {number} [#tick_wait=20]          Amount of ticks to wait between clicks.
                // {number} [#timeout_sec=30]        Max seconds fn can run for before timing out. <= 0 to infinite loop until success.
        function auctionsIndexBids(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/indexAuctions.txt:254
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&eauctionsIndexBids&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
            endif;
            
            // Loop until we get a valid return value.
            if(true);
                bids_indexed = false;
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function timed out!");
                            break;
                        endif;
                    endif;
                    
                    // 2. Get into the Main Auctions GUI
                    if(true);
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &auctions_opened   = auctionsOpen(%allow_command%,%#tick_wait%,%#recursive_timeout%);
                        if(%&auctions_opened% == "SUCCESS");
                            #found_slot = findItemContainer(false,"MCID: golden_carrot","NAME: View Bids","SLOT: 13");
                            if(%#found_slot% != -1);
                                &found_item = getslotitemnbt(%#found_slot%,,#found_stack,#found_data,&found_nbt);
                                &found_nbt  = strip(%&found_nbt%);
                                ifmatches(%&found_nbt%,"You placed (\d+) bids",#bids_placed,1);
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    updated_gui        = containerClick(%#found_slot%,%#recursive_timeout%,%#tick_wait%);
                                    if(%updated_gui%);
                                        #container_start = 0;
                                        #container_end   = %CONTAINERSLOTS% - 37;
                                        for(#container_slot,%#container_start%,%#container_end%);
                                            &container_item = getslotitemnbt(%#container_slot%,,#container_stack,#container_data,&container_nbt);
                                            &container_nbt  = strip(%&container_nbt%);
                                            if((%&container_item% != "air") && ((%&container_item% != "stained_glass_pane") || (%#container_data% != 15)));
                                                &container_name      = getItemName(%&container_nbt%,%&container_item%);
                                                &container_sbid      = getItemSBID(%&container_nbt%);
                                                &test_container_name = trim(%&container_name%);
                                                if((%&test_container_name% != "") && (%&test_container_name% != "Claim All") && (%&test_container_name% != "Go Back"));
                                                    &listing_info[]     = auctionsIndexSlotData(%#container_slot%);
                                                    listing_info_valid := %&listing_info[0]%;
                                                    if(%listing_info_valid%);
                                                        &return_array[] = join("|",&listing_info[]);
                                                    endif;
                                                endif;
                                            endif;
                                        next;
                                        bids_indexed = true;
                                    endif;
                                elseifnotmatches(%&found_nbt%,"Refreshing");
                                    debug_error(%debug%,%&script_debug_name%,"No bids are available to index!");
                                    bids_indexed = true;
                                    break;
                                endif;
                            endif;
                        elseif(%&auctions_opened% == "ERROR_CLOSED");
                            debug_error(%debug%,%&script_debug_name%,"Auction House is temporarily closed, cannot access it!");
                            break;
                        endif;
                    endif;
                    
                    wait("1t");
                until(%bids_indexed%);
            endif;
            return(&return_array[]);
        endfunction;
    // auctions/indexAuctions/auctionsIndexAll
        // Indexes all of the Auctions we have placed bids for, and/or listed for Sale and returns their State.
        function auctionsIndexAll(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/indexAuctions.txt:328
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&eauctionsIndexAll&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
            endif;
            
            &indexed_bids[]     = auctionsIndexBids(%allow_command%,%#tick_wait%,%#timeout_sec%);
            #recursive_timeout  = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
            &indexed_listings[] = auctionsIndexPersonalListings(%allow_command%,%#tick_wait%,%#recursive_timeout%);
            
            push(&return_array[],&indexed_bids[*],&indexed_listings[*]);
            return(&return_array[]);
        endfunction;
    // api/index/getSkyBlockProfile
        // Fetches a given SkyBlock Profile from Hypixel's API.
            // Params:
            //        {string} <&profile_id>            The Profile ID to fetch
            //        {string} [&api_key=%@&api_key]    The API Key to make Requests with. If left blank, defaults to @&api_key
            //
            // Returns an array:
            //    0    {boolean} success    Whether or not we were able to get any data from the API (false if request fails)
            //    1    {string} &profile    The JSON Data of the Profile
        function getSkyBlockProfile(&profile_id,&api_key=%@&api_key%);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:364
            &script_debug_name = "&9getSkyBlockProfile&7";
            debug              = true;
            test_profile_id    = isStringUUID(%&profile_id%);
            if(!%test_profile_id%);
                debug_error(%debug%,%&script_debug_name%,"Invalid formatted Profile ID passed: &4%&profile_id%&7.");
                return(false,"");
            endif;
        
            // Make the API request.
            if(true);
                &api_url     = "skyblock/profile?profile=%&profile_id%";
                &api_data[]  = hypixelAPICall(%&api_url%);
                req_success := %&api_data[0]%;
                api_success := %&api_data[1]%;
                #api_code   := %&api_data[2]%;
                &api_resp    = %&api_data[3]%;
        
                if(%api_success%);
                    &profile = jsonget("profile",%&api_resp%);
                    ifmatches(%&profile%,"^(?:ERROR_.*|null)$");
                        debug_error(%debug%,%&script_debug_name%,"Profile with ID &4%&profile_id%&7 does not exist.");
                        return(false,"");
                    endif;
                    debug_log(%debug%,%&script_debug_name%,"&aFound Profile, returning.");
                    return(true,%&profile%);
                else;
                    debug_error(%debug%,%&script_debug_name%,"API Call failed!");
                    return(false,"");
                endif;
            endif;
        endfunction;
    // api/index/getSkyBlockProfiles
        // Fetches a player's SkyBlock Profiles from Hypixel's API.
            // Params:
            //        {string} [&search_term=%UUID%]     The player username/UUID to search for. If left blank, defaults to player's UUID.
            //        {string} [&api_key=%@&api_key%]    The API Key to make Requests with. If left blank, defaults to @&api_key
            //
            // Returns an array:
            //    0         {boolean}    success       Whether or not we were able to get any data from the API (false if request fails)
            //    1, ...    {string}     &profile[]    The JSON Objects of the Profiles. Only provided if success == true and profiles !== null.
        function getSkyBlockProfiles(&search_term=%UUID%,&api_key=%@&api_key%);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:261
            &script_debug_name = "&9getSkyBlockProfiles&7";
            debug              = false;
        
            &player_identity[] = getMinecraftProfile(%&search_term%);
            identity_found    := %&player_identity[0]%;
            &player_username   = %&player_identity[1]%;
            &player_joint_uuid = %&player_identity[2]%;
            &player_split_uuid = %&player_identity[3]%;
            if(%identity_found%);
                &api_url     = "skyblock/profiles?uuid=%&player_split_uuid%";
                &api_data[]  = hypixelAPICall(%&api_url%);
                req_success := %&api_data[0]%;
                api_success := %&api_data[1]%;
                #api_code   := %&api_data[2]%;
                &api_resp    = %&api_data[3]%;
                success      = %req_success%;
                
        
                if((!%req_success%) || (!%api_success%));
                    if(%req_success%);
                        &cause = jsonget("cause",%&api_resp%);
                    else;
                        &cause = "Cloudflare Request Throttle";
                    endif;
                    debug_error(%debug%,%&script_debug_name%,"An error occurred while fetching SkyBlock Profiles for &4%&player_username%&7: &4%&cause%&7.");
                else;
                    &player_profiles = jsonget("profiles",%&api_resp%);
                    #profile_index   = 0;
                    do;
                        &profile_data = jsonget(%#profile_index%,%&player_profiles%);
                        ifmatches(%&profile_data%,"ERROR_");
                            #found_profiles  = arraysize(&player_profiles[]);
                            debug_log(%debug%,%&script_debug_name%,"Found a total of &a%#found_profiles% profiles&7 for &a%&player_username%&7.");
                            no_more_profiles = true;
                            break;
                        else;
                            &profile_id        = jsonget("profile_id",%&profile_data%);
                            &profile_name      = jsonget("cute_name",%&profile_data%);
                            &profile_ids[]     = %&profile_id%;
                            &profile_names[]   = %&profile_name%;
                            &player_profiles[] = %&profile_data%;
                        endif;
                        #profile_index = %#profile_index% + 1;
                    until(%no_more_profiles%);
        
                    #player_cache_index = indexof(@&cached_profile_player_uuids[],,%&player_split_uuid%);
                    if(%#player_cache_index% == -1);
                        @&cached_profile_player_uuids[]         = %&player_split_uuid%;
                        @&cached_profile_player_profile_ids[]   = join("|",&profile_ids[]);
                        @&cached_profile_player_profile_names[] = join("|",&profile_names[]);
                        debug_log(%debug%,%&script_debug_name%,"&eInitialized&7 cached profile IDs and Names for &a%&player_username%&7.");
                    else;
                        &player_cached_profile_ids[]   = split("|",%@&cached_profile_player_profile_ids[%#player_cache_index%]%);
                        &player_cached_profile_names[] = split("|",%@&cached_profile_player_profile_names[%#player_cache_index%]%);
        
                        // Trim the cache if anything is not found.
                        foreach(&player_cached_profile_ids[],&cached_profile_id,#cpii);
                            #found_index = indexof(&profile_ids[],,%&cached_profile_id%);
                            if(%#found_index% == -1);
                                // This profile is no longer available for this member, trim it from the new array.
                                debug_log(%debug%,%&script_debug_name%,"Profile ID &e%&cached_profile_id%&7 (Name: &d%&player_cached_profile_names[%#cpii%]%&7) is no longer available, trimming");
                                &player_cached_profile_ids[]   = arrayDelete(&player_cached_profile_ids[],%#cpii%);
                                &player_cached_profile_names[] = arrayDelete(&player_cached_profile_names[],%#cpii%);
                            endif;
                        next;
        
                        // Append to the cache with any new finds.
                        foreach(&profile_ids[],&profile_id,#pii);
                            #cached_index = indexof(&player_cached_profile_ids[],,%&profile_id%);
                            if(%#cached_index% == -1);
                                debug_log(%debug%,%&script_debug_name%,"Found new Profile ID: &e%&profile_id%&7 (Name: &d%&profile_names[%#pii%]%&7).");
                                put(&player_cached_profile_ids[],%&profile_id%);
                                put(&player_cached_profile_names[],%&profile_names[%#pii%]%);
                            endif;
                        next;
        
                        // Update the cache
                        if(true);
                            @&cached_profile_player_profile_ids[%#player_cache_index%]   = join("|",&player_cached_profile_ids[]);
                            @&cached_profile_player_profile_names[%#player_cache_index%] = join("|",&player_cached_profile_names[]);
                        endif;
        
                        debug_log(%debug%,%&script_debug_name%,"&dUpdated&7 cached profile IDs and Names for &a%&player_username%&7.");
                    endif;
                endif;
            else;
                debug_error(%debug%,%&script_debug_name%,"Could not resolve search_term &4%&search_term%&7 into a valid UUID!");
            endif;
        
            &return_array[] = %success%;
            push(&return_array[],&player_profiles[*]);
            return(&return_array[]);
        endfunction;
    // api/index/getActiveProfile
        // Fetches the specified player's currently active SkyBlock Profile from Hypixel's API.
            // Params:
                // {string} [&search_term=%UUID%]     The username or UUID of the player to look up. Defaults to the bot's UUID.
                // {string} [&api_key=%@&api_key%]    The API Key to make Requests with. If left blank, defaults to @&api_key
                // {boolean} [player_only=false]      If true, will return the bot's data from the Profile only. Defaults to false.
            // Returns a String Array:
                //    0 {boolean} success     Whether or not we were able to get any data from the API (false if request fails)
                //    1 {string}  &profile    The JSON Data of the Profile
            // Example:
                //    &active_profile[] = getActiveProfile();
                //    profile_found    := %&active_profile[0]%;
                //    if(%profile_found%);
                //        &profile_data = %&active_profile[1]%;
                //    endif;
        function getActiveProfile(&search_term=%UUID%,&api_key=%@&api_key%,player_only=false);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:411
            &script_debug_name = "&9getActiveProfile&7";
            debug              = true;
        
            // Get the Minecraft Profile associated with the Search Term.
            if(true);
                &player_identity[] = getMinecraftProfile(%&search_term%);
                identity_found    := %&player_identity[0]%;
                &player_username   = %&player_identity[1]%;
                &player_joint_uuid = %&player_identity[2]%;
                &player_split_uuid = %&player_identity[3]%;
        
                if(!%identity_found%);
                    debug_error(%debug%,%&script_debug_name%,"Could not find Identity for Search Term: &4%&search_term%&7.");
                    return(false,"");
                endif;
            endif;
        
            // If the Minecraft Profile we are executing this query on is the active bot account,
            // try and get the Profile ID from reading Scoreboard and checking the Cache.
            if(%&player_split_uuid% == %UUID%);
                #player_cache_index = indexof(@&cached_profile_player_uuids[],,%&player_split_uuid%);
                if(%#player_cache_index% != -1);
                    &active_profile = getSkyBlockPlayerListInfo("PROFILE");
                    if(%&active_profile% != "-1");
                        &cached_ids[]   = split("|",%@&cached_profile_player_profile_ids[%#player_cache_index%]%);
                        &cached_names[] = split("|",%@&cached_profile_player_profile_names[%#player_cache_index%]%);
                        #profile_index  = indexof(&cached_names[],,%&active_profile%);
                        debug_log(%debug%,%&script_debug_name%,"profile name &d%&active_profile%&7 found at index &e%#profile_index%&7 in cached_names array.");
                        if(%#profile_index% != -1);
                            skip_all_profiles_req = true;
                            &active_profile_id    = %&cached_ids[%#profile_index%]%;
                            &active_profile_name  = %&cached_names[%#profile_index%]%;
                            debug_log(%debug%,%&script_debug_name%,"&aHit cache! ID is: &e%&active_profile_id%");
                        endif;
                    endif;
                endif;
            endif;
        
            // Get the active Profile ID & Data from API, if we do not already have it.
            if(true);
                if(!%skip_all_profiles_req%);
                    debug_log(%debug%,%&script_debug_name%,"Calling getSkyBlockProfiles, did not hit cache.");
        
                    // Get the profiles for the Minecraft Profile we are querying.
                    &profile_data[]  = getSkyBlockProfiles(%&player_split_uuid%);
                    #player_profiles = arraysize(&profile_data[]);
                    profile_success := %&profile_data[0]%;
        
                    // Iterate over all Profiles and find the one with the most recent save.
                    if((%profile_success%) && (%#player_profiles% > 1));
                        #final_profile_index = %#player_profiles% - 1;
                        #start_profile_index = 1;
        
                        for(#i,%#start_profile_index%,%#final_profile_index%);
                            &profile_data = %&profile_data[%#i%]%;
                            &profile_id   = jsonget("profile_id",%&profile_data%);
                            &profile_name = jsonget("cute_name",%&profile_data%);
                            &profile_mbrs = jsonget("members",%&profile_data%);
                            &player_data  = jsonget(%&player_joint_uuid%,%&profile_mbrs%);
                            ifmatches(%&player_data%,"ERROR_");
                                debug_error(%debug%,%&script_debug_name%,"Could not find Profile Member data for User: &4%&player_username%&7 in Profile ID &e%&profile_id%&7 (name: &d%&profile_name%&7).");
                            else;
                                &init_save = %&best_save%;
        
                                if(%&best_save% == "");
                                    &best_save           = jsonget("last_save",%&player_data%);
                                    &active_profile_data = %&profile_data%;
                                else;
                                    &last_save = jsonget("last_save",%&player_data%);
                                    eval(&ms_diff,"%&best_save% - %&last_save%"); // if last_save > best_save, result ms_diff will start with -1.
                                    ifmatches(%&ms_diff%,"^-");
                                        &best_save           = %&last_save%;
                                        &active_profile_data = %&profile_data%;
                                    endif;
                                endif;
                            endif;
                        next;
                    endif;
                else;
                    // Only need to make one request for the correct Profile.
                    &profile_data[]      = getSkyBlockProfile(%&active_profile_id%);
                    profile_success     := %&profile_data[0]%;
                    &active_profile_data = %&profile_data[1]%;
                endif;
        
                if((%profile_success%) && (%player_only%));
                    &active_profile_data = jsonget("members.%&player_joint_uuid%",%&active_profile_data%);
                    ifmatches(%&active_profile_data%,"ERROR_");
                        debug_error(%debug%,%&script_debug_name%,"Could not find Player UUID %&player_joint_uuid% in Active Profile, wtf?");
                        &active_profile_data = "";
                    endif;
                endif;
            endif;
            return(%profile_success%,%&active_profile_data%);
        endfunction;
    // api/index/getActiveProfileID
        // Fetches the specified player's currently active SkyBlock Profile ID from Hypixel's API.
            // Params:
            //        {string} [&search_term=%UUID%]     The username or UUID of the player to look up. Defaults to the bot's UUID.
            //        {string} [&api_key=%@&api_key%]    The API Key to make Requests with. If left blank, defaults to @&api_key
            //
            // Returns an Array:
            //    0 {boolean} success        Whether or not we were able to get any data from the API (false if request fails)
            //    1 {string}  &profile_id    The Active Profile's ID.
        function getActiveProfileID(&search_term=%UUID%,&api_key=%@&api_key%);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/index.txt:516
            &script_debug_name = "&9getActiveProfileID&7";
            debug              = true;
            
            // Get the Minecraft Profile associated with the Search Term.
            if(true);
                &player_identity[] = getMinecraftProfile(%&search_term%);
                identity_found    := %&player_identity[0]%;
                &player_username   = %&player_identity[1]%;
                &player_joint_uuid = %&player_identity[2]%;
                &player_split_uuid = %&player_identity[3]%;
                if(!%identity_found%);
                    debug_error(%debug%,%&script_debug_name%,"Could not find Identity for Search Term: &4%&search_term%&7.");
                    return(false,"");
                endif;
            endif;
        
            // If the Player we are looking up is the Bot, see if we can hit the Profile Cache to get the ID early.
            if(%&player_split_uuid% == %UUID%);
                #player_cache_index = indexof(@&cached_profile_player_uuids[],,%&player_split_uuid%);
                if(%#player_cache_index% != -1);
                    &active_profile = getSkyBlockPlayerListInfo("AREA");
                    if(%&active_profile% != "-1");
                        &cached_ids[]   = split("|",%@&cached_profile_player_profile_ids[%#player_cache_index%]%);
                        &cached_names[] = split("|",%@&cached_profile_player_profile_names[%#player_cache_index%]%);
                        #profile_index  = indexof(&cached_names[],,%&active_profile%);
                        if(%#profile_index% != -1);
                            active_profile_success = true;
                            &active_profile_id     = %&cached_ids[%#profile_index%]%;
                            &active_profile_name   = %&cached_names[%#profile_index%]%;
                        endif;
                    endif;
                    #
                endif;
            endif;
        
            // Call getActiveProfile if we did not hit the Cache.
            if(!%active_profile_success%);
                &active_profile_data[]  = getActiveProfile(%&search_term%,%&api_key%);
                active_profile_success := %&active_profile_data[0]%;
                if(%profile_success%);
                    &active_profile_id = jsonget("profile_id",%&profile_data[1]%);
                endif;
            endif;
        
            return(%active_profile_success%,%&active_profile_id%);
        endfunction;
    // auctions/indexAuctions/auctionsIndexCoinsAvailable
        // Indexes all of the Auctions we have placed bids for and/or listed for Sale that have Coins available for us to Claim.
        function auctionsIndexCoinsAvailable(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/indexAuctions.txt:346
            &indexed_auctions[] = auctionsIndexAll(%allow_command%,%#tick_wait%,%#timeout_sec%);
            &curr_profile_id    = getActiveProfileID();
            &curr_uuid          = %UUID%;
            &curr_uuid          = replace(&curr_uuid,"-");
            foreach(&indexed_auctions[],&indexed_auction,#ia);
                &listing_info[]    = split("|",%&indexed_auction%);
                listing_hit       := %&listing_info[0]%;
                &listing_id        = %&listing_info[1]%;
                &listing_type      = %&listing_info[2]%;
                #listing_price    := %&listing_info[3]%;
                #listing_bids     := %&listing_info[4]%;
                listing_ended     := %&listing_info[5]%;
                listing_claimed   := %&listing_info[6]%;
                &listing_owner     = %&listing_info[7]%;
                &listing_profile   = %&listing_info[8]%;
                &listing_sbid      = %&listing_info[9]%;
                &listing_name      = %&listing_info[10]%;
                &listing_mcid      = %&listing_info[11]%;
                #listing_data     := %&listing_info[12]%;
                #listing_stack    := %&listing_info[13]%;
                &listing_buyers    = %&listing_info[14]%;
                #listing_end_time := %&listing_info[15]%;
                
                if((%listing_ended%) || (%listing_claimed%) || (%TIMESTAMP% >= %#listing_end_time%));
                    coins_available = ((%&listing_owner% == %PLAYER%) || (%&listing_owner% == %&curr_uuid%) || (%&listing_owner% == %UUID%) || (%&listing_profile% == %&curr_profile_id%));
                    if(!%coins_available%);
                        ifnotmatches(%&listing_buyers%,%&curr_uuid%);
                            coins_available = true;
                        endif;
                    endif;
                    
                    if(%coins_available%);
                        &return_array[] = %&indexed_auction%;
                    endif;
                endif;
            next;
            return(&return_array[]);
        endfunction;
    // bazaar/index/getBazaarIndex
        // Given a Search Term (Display Name or SBID), searches for the specified Product in @&mkb_baz_sbids & @&mkb_baz_names. If a Product
        // is found, it's Index is returned. If not, -1 is returned.
            // Params:
                // {string} <&search_term>    The Product's Display Name or SBID to search up.
                //
            // Returns the Index of the Search Term in the @&mkb_baz_[sbids|names|paths] Arrays, or -1 if it is not found.
        function getBazaarIndex(&search_term);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:128
            #sbid_index = indexof(@&mkb_baz_sbids[],,%&search_term%);
            if(%#sbid_index% != -1);
                return(%#sbid_index%);
            endif;
            
            #name_index = indexof(@&mkb_baz_names[],,%&search_term%);
            if(%#name_index% != -1);
                return(%#name_index%);
            endif;
            
            #path_index = indexof(@&mkb_baz_paths[],,%&search_term%);
            return(%#path_index%);
        endfunction;
    // bazaar/index/getCurrentBazaarProductPath
        // Finds the Currently Selected Bazaar Product's Path.
        function getCurrentBazaarProductPath();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:515
            &return_string = "NONE";
            ifmatches(%CONTAINERNAME%,"\u279c");
                // Check the Item Slots that we can expect to contain the Item's Name or SBID.
                if(true);
                    #check_slots[] = split(", ","13, 10, 11, 15, 16");
                    &check_names[] = split(", ","NULL, Buy Instantly, Sell Instantly, Create Buy Order, Create Sell Offer");
                    #found_index   = -1;
                    foreach(#check_slots[],#check_slot,#csi);
                        &check_name = %&check_names[%#csi%]%;
                        &f_item     = getslotitemnbt(%#check_slot%,,#f_stack,#f_data,&f_nbt);
                        &f_nbt      = strip(%&f_nbt%);
                        &f_name     = getItemName(%&f_nbt%,%&f_item%);
                        if((%&check_name% == "NULL") || (%&check_name% == %&f_name%));
                            if(%&check_name% == "NULL");
                                // Can do lookup from the Name we got.
                                #found_index = getBazaarIndex(%&f_name%);
                                if(%#found_index% != -1);
                                    break;
                                endif;
                                
                                // Name lookup didn't work, check if we can get anything with the SBID.
                                &f_sbid      = getItemSBID(%&f_nbt%);
                                #found_index = getBazaarIndex(%&f_sbid%);
                                if(%#found_index% != -1);
                                    break;
                                endif;
                            else;
                                // Do lookup from the Lore of the Item.
                                &name_from_lore = jsonget("display.Lore.0",%&f_nbt%);
                                #found_index    = getBazaarIndex(%&name_from_lore%);
                                if(%#found_index% != -1);
                                    break;
                                endif;
                            endif;
                        endif;
                    next;
                    if(%#found_index% != -1);
                        &return_string = %@&mkb_baz_paths[%#found_index%]%;
                    endif;
                endif;
            endif;
            
            return(%&return_string%);
        endfunction;
    // bazaar/index/getCurrentBazaarSubcategoryPath
        // Finds the Currently Selected Bazaar Subcategory's Path.
            // Params: None
            // Returns the JSON dot-separated path of the Subcategory that is currently selected, or "NONE" if not found.
        function getCurrentBazaarSubcategoryPath();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:478
            &return_string = "NONE";
            ifmatches(%CONTAINERNAME%,"(Farming|Mining|Combat|Woods & Fishes|Oddities) \u279c",&category_name,1);
                // Find the Index of this Category.
                if(true);
                    #category_index = -1;
                    for(#i,0,4);
                        &button_name = jsonget("holds.%#i%.button.name",%@&mkb_baz_json%);
                        if(%&button_name% == %&category_name%);
                            #category_index = %#i%;
                            break;
                        endif;
                    next;
                    
                    if(%#category_index% == -1);
                        return("NONE");
                    endif;
                endif;
                
                // Find the Subcategory within the Parent Category who's exp_container value matches whatever ours is.
                if(true);
                    for(#i,0,99);
                        &subentry_expr = jsonget("holds.%#category_index%.holds.%#i%.button.exp_container",%@&mkb_baz_json%);
                        ifmatches(%CONTAINERNAME%,%&subentry_expr%);
                            &return_string = "holds.%#category_index%.holds.%#i%";
                            break;
                        elseifmatches(%&subentry_expr%,"^ERROR_");
                            break;
                        endif;
                    next;
                endif;
            endif;
            
            return(%&return_string%);
        endfunction;
    // bazaar/index/getCurrentBazaarCategoryPath
        // Finds the Currently Selected Bazaar Category's Path.
            // Params: None
            // Returns the JSON dot-separated path of the Category that is currently selected, or "NONE" if not found.
        function getCurrentBazaarCategoryPath();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:463
            &return_string = "NONE";
            for(#i,0,4);
                &container_expr = jsonget("holds.%#i%.button.exp_container",%@&mkb_baz_json%);
                ifmatches(%CONTAINERNAME%,%&container_expr%);
                    &return_string = "holds.%#i%";
                    break;
                endif;
            next;
            return(%&return_string%);
        endfunction;
    // bazaar/index/searchItemNBT
        // Searches for an Item with a given Name in the Container, Mouse, and/or Inventory. If found, returns the NBT of that Item. Otherwise, empty string.
            // Params:
                // {string} [&item_name='Go Back']    The Name of the Item to search for.
                // {string} [&item_mcid='arrow']      The MCID of the Item to search for.
            // Returns the NBT of the Item if it was found, or an empty string if it was not.
        function searchItemNBT(&item_name="Go Back",&item_mcid="arrow");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:378
            &r_item = %&item_mcid%;
            &r_name = %&item_name%;
            
            // Check the Container first.
            if(%CONTAINERSLOTS% > 0);
                #r_offset = 0;
                #r_start  = 0;
                #r_end    = %CONTAINERSLOTS% - 37;
                for(#r_slot,%#r_start%,%#r_end%);
                    #f_slot = %#r_slot%;
                    if(%&r_item%);
                        getslot(%&r_item%,#f_slot,%#r_offset%);
                    endif;
                    
                    if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                        #r_offset = %#f_slot% + 1;
                        &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                        &f_nbt    = strip(%&f_nbt%);
                        &f_name   = getItemName(%&f_nbt%,%&f_item%);
                        m_item    = ((!%&r_item%) || (%&r_item% == %&f_item%));
                        m_name    = ((!%&r_name%) || (%&r_name% == %&f_name%));
                        m_match   = ((%m_item%) && (%m_name%));
                        if(%m_match%);
                            &return_string = %&f_nbt%;
                            break;
                        endif;
                    else;
                        break;
                    endif;
                next;
                if(%&return_string% != "");
                    return(%&return_string%);
                endif;
            endif;
            
            // Check the Mouse.
            if(true);
                &m_item = getmouseitem(,#m_stack,#m_data,&m_nbt);
                if(%&m_item% == %&r_item%);
                    &m_nbt  = strip(%&m_nbt%);
                    &m_name = getItemName(%&m_nbt%,%&m_item%);
                    if(%&m_name% == %&r_name%);
                        return(%&m_nbt%);
                    endif;
                endif;
            endif;
            
            // Check the Inventory.
            if(true);
                if(true);
                    #r_offset = 9;
                    #r_start  = 9;
                    #r_end    = 44;
                    for(#r_slot,%#r_start%,%#r_end%);
                        #f_slot = %#r_slot%;
                        if(%&r_item%);
                            getslotinv(%&r_item%,#f_slot,%#r_offset%);
                        endif;
                        
                        if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                            #r_offset = %#f_slot% + 1;
                            &f_item   = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                            &f_nbt    = strip(%&f_nbt%);
                            &f_name   = getItemName(%&f_nbt%,%&f_item%);
                            m_item    = ((!%&r_item%) || (%&r_item% == %&f_item%));
                            m_name    = ((!%&r_name%) || (%&r_name% == %&f_name%));
                            m_match   = ((%m_item%) && (%m_name%));
                            if(%m_match%);
                                &return_string = %&f_nbt%;
                                break;
                            endif;
                        else;
                            break;
                        endif;
                    next;
                endif;
            endif;
            
            return(%&return_string%);
        endfunction;
    // bazaar/index/bazaarNameCheck
        // Identical to bazaarItemCheck, except does not use GETSLOT, instead uses GETSLOTITEMEXT and checks if all Item Names are found.
            // Params:
                // {string} <&find_names[]>    The Names of the Items to look for
            // Returns a Boolean indicating whether or not every single Item was found in the GUI, Inventory, or Mouse.
        function bazaarNameCheck(&find_names[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:293
            return_boolean = false;
            foreach(&find_names[],&find_name,#fi);
                found_names[%#fi%] = false;
            next;
            
            if(true);
                // Look for the Item in all available Slots.
                if(true);
                    // Check the Container
                    if(%CONTAINERSLOTS% > 0);
                        #r_start  = 0;
                        #r_end    = %CONTAINERSLOTS% - 37;
                        for(#f_slot,%#r_start%,%#r_end%);
                            getslotitemext(%#f_slot%,&f_item,,,&t);
                            if((%&f_item% != "air") && (%&f_item% != "stained_glass_pane"));
                                &f_name   = strip(%&t%);
                                #f_index  = indexof(&find_names[],,%&f_name%);
                                if(%#f_index% != -1);
                                    found_names[%#f_index%] = true;
                                    #false_index            = indexof(found_names[],,false);
                                    if(%#false_index% == -1);
                                        full_break = true;
                                        break;
                                    endif;
                                endif;
                            endif;
                        next;
                        if(%full_break%);
                            return(True);
                        endif;
                    endif;
                    
                    // Check the Mouse
                    if(!%f_match%);
                        &m_item = getmouseitem(,#m_stack,#m_data,&m_nbt);
                        if(%&m_item% != "air");
                            &m_nbt  = strip(%&m_nbt%);
                            &m_name = getItemName(%&m_nbt%,%&m_item%);
                            #f_index  = indexof(&find_names[],,%&m_name%);
                            if(%#f_index% != -1);
                                found_names[%#f_index%] = true;
                                #false_index            = indexof(found_names[],,false);
                                if(%#false_index% == -1);
                                    return(True);
                                endif;
                            endif;
                        endif;
                    endif;
                    
                    // Check the Inventory
                    if(!%f_match%);
                        #r_start  = 9;
                        #r_end    = 43;
                        for(#f_slot,%#r_start%,%#r_end%);
                            &f_item = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                            if((%&f_item% != "air") && (%&f_item% != "stained_glass_pane"));
                                &f_nbt   = strip(%&f_nbt%);
                                &f_name  = getItemName(%&f_nbt%,%&f_item%);
                                #f_index = indexof(&find_names[],,%&f_name%);
                                if(%#f_index% != -1);
                                    found_names[%#f_index%] = true;
                                    #false_index            = indexof(found_names[],,false);
                                    if(%#false_index% == -1);
                                        break;
                                    endif;
                                endif;
                            endif;
                        next;
                    endif;
                endif;
            endif;
            
            #false_index = indexof(found_names[],,false);
            if(%#false_index% == -1);
                return(True);
            endif;
            return(False);
        endfunction;
    // bazaar/index/bazaarItemCheck
        // Iterates over all available Slots, looking for a match for each Item defined in the &find_items[] and &find_names[] Arrays.
        // If a match for each item is found, will return True. Else, returns False. Checks Mouse as well.
            // Params:
                // {string} <&find_items[]>    The MCIDs of the Items to look for
                // {string} <&find_names[]>    The Names of the Items to look for
            // Returns a Boolean indicating whether or not every single Item was found in the GUI, Inventory, or Mouse.
        function bazaarItemCheck(&find_items[],&find_names[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:219
            return_boolean = true;
            foreach(&find_items[],&find_item,#fi);
                &find_name = %&find_names[%#fi%]%;
                f_match    = false;
                
                // Look for the Item in all available Slots.
                if(true);
                    // Check the Container
                    if(%CONTAINERSLOTS% > 0);
                        #r_start  = 0;
                        #r_end    = %CONTAINERSLOTS% - 37;
                        #r_offset = 0;
                        for(#r_slot,%#r_start%,%#r_end%);
                            getslot(%&find_item%,#f_slot,%#r_offset%);
                            if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                                #r_offset = %#f_slot% + 1;
                                &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                &f_nbt    = strip(%&f_nbt%);
                                &f_name   = getItemName(%&f_nbt%,%&f_item%);
                                f_match   = ((%&f_item% == %&find_item%) && (%&f_name% == %&find_name%));
                                if(%f_match%);
                                    break;
                                endif;
                            else;
                                break;
                            endif;
                        next;
                    endif;
                    
                    // Check the Mouse
                    if(!%f_match%);
                        &m_item = getmouseitem(,#m_stack,#m_data,&m_nbt);
                        &m_nbt  = strip(%&m_nbt%);
                        &m_name = getItemName(%&m_nbt%,%&m_item%);
                        f_match = ((%&m_item% == %&find_item%) && (%&m_name% == %&find_name%));
                    endif;
                    
                    // Check the Inventory
                    if(!%f_match%);
                        #r_start  = 9;
                        #r_end    = 43;
                        #r_offset = 9;
                        for(#r_slot,%#r_start%,%#r_end%);
                            getslotinv(%&find_item%,#f_slot,%#r_offset%);
                            if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                                #r_offset = %#f_slot% + 1;
                                &f_item   = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                &f_nbt    = strip(%&f_nbt%);
                                &f_name   = getItemName(%&f_nbt%,%&f_item%);
                                f_match   = ((%&f_item% == %&find_item%) && (%&f_name% == %&find_name%));
                                if(%f_match%);
                                    break;
                                endif;
                            else;
                                break;
                            endif;
                        next;
                    endif;
                endif;
                
                // Break early if we did not find a match for this Item.
                if(!%f_match%);
                    return_boolean = false;
                    break;
                endif;
            next;
            return(%return_boolean%);
        endfunction;
    // bazaar/index/getBazaarGUIType
        // Reads variables regarding the currently opened Bazaar GUI to determine it's Type.
            // Params: None
            // Returns a String ENUM of:
                //    CATEGORY, SUBCATEGORY, PRODUCT,
                //    BUY_INSTANT_QTY, BUY_INSTANT_QTY_SIGN, BUY_INSTANT_CONFIRM,
                //    BUY_ORDER_QTY, BUY_ORDER_QTY_SIGN, BUY_ORDER_PRICE, BUY_ORDER_PRICE_SIGN, BUY_ORDER_CONFIRM, BUY_ORDER_MANAGE, BUY_ORDER_FLIP,
                //    SELL_INSTANT_QTY, SELL_INSTANT_INVENTORY,
                //    SELL_ORDER_QTY, SELL_ORDER_QTY_SIGN, SELL_ORDER_PRICE, SELL_ORDER_PRICE_SIGN, SELL_ORDER_CONFIRM, SELL_ORDER_MANAGE,
                //    ORDER_MANAGE,
                //    GRAPHS,
                //    NONE
            // If not currently in a Bazaar GUI, "NONE" will be returned.
                //  ENUM                      |    VALUE
                //  CATEGORY                  |    Category Path
                //  SUBCATEGORY               |    Subcategory Path
                //  PRODUCT                   |    Product Path
                //  BUY_INSTANT_QTY           |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  BUY_INSTANT_QTY_SIGN      |    NULL
                //  BUY_INSTANT_CONFIRM       |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  BUY_ORDER_QTY             |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  BUY_ORDER_QTY_SIGN        |    NULL
                //  BUY_ORDER_PRICE           |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  BUY_ORDER_PRICE_SIGN      |    NULL
                //  BUY_ORDER_CONFIRM         |    Product Path (Buy Order nbt => display.lore.4 == /Order: .*?x (?<itemName>.+)/)
                //  BUY_ORDER_MANAGE          |    NULL
                //  BUY_ORDER_FLIP            |    NULL
                //  SELL_INSTANT_QTY          |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  SELL_INSTANT_INVENTORY    |    NULL
                //  SELL_ORDER_QTY            |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  SELL_ORDER_QTY_SIGN       |    NULL
                //  SELL_ORDER_PRICE          |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  SELL_ORDER_PRICE_SIGN     |    NULL
                //  SELL_ORDER_CONFIRM        |    Product Path (Buy Order nbt => display.lore.4 == /Selling: .*?x (?<itemName>.+)/)
                //  SELL_ORDER_MANAGE         |    NULL (Category), Subcategory Path, Product Path (Go Back Arrow's nbt => display.lore.0 == /To (?<ambiguous>.+)/)
                //  ORDER_MANAGE              |    NULL
                //  GRAPHS                    |    Product Path (Go Back Arrow's nbt => display.Lore.0 == /To (?<itemName>.+)/)
                //  NONE                      |    NULL
        function getBazaarGUIType();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:598
            // Setup GUI Type Path Arrays to influence our logic on how to find the Path to the current GUI.
            if(true);
                // GUI Types where we should not attempt to determine the Path.
                &gui_nulls[] = split(", ","BUY_INSTANT_QTY_SIGN, BUY_ORDER_QTY_SIGN, BUY_ORDER_PRICE_SIGN, BUY_ORDER_MANAGE, BUY_ORDER_FLIP, SELL_INSTANT_INVENTORY, SELL_ORDER_QTY_SIGN, SELL_ORDER_PRICE_SIGN, SELL_ORDER_MANAGE, ORDER_MANAGE, NONE, SELL_ORDER_MANAGE");
                
                // GUI Types where we should attempt to determine the Path by finding the Go Back Arrow and reading the Item Name.
                &gui_path_back_arrow[] = split(", ","BUY_INSTANT_QTY, BUY_ORDER_QTY, BUY_ORDER_PRICE, SELL_INSTANT_QTY, SELL_ORDER_QTY, SELL_ORDER_PRICE, GRAPHS");
                
                // GUI Types that have a function to extract the Path.
                &gui_path_functions[] = split(", ","CATEGORY, SUBCATEGORY, PRODUCT");
                
                // GUI Types that have a non-standard Path determining logic
                &gui_path_non_standard[] = split(", ","BUY_ORDER_CONFIRM, SELL_ORDER_CONFIRM, BUY_INSTANT_CONFIRM");
            endif;
            
            if((%GUI% == "GUICHEST") || (%GUI% == "GUIEDITSIGN"));
                if(%GUI% == "GUICHEST");
                    // Can be any of:
                        // CATEGORY, SUBCATEGORY, PRODUCT, BUY_INSTANT_QTY, BUY_INSTANT_CONFIRM, BUY_ORDER_QTY, BUY_ORDER_PRICE, BUY_ORDER_CONFIRM, BUY_ORDER_MANAGE,
                        // SELL_INSTANT_QTY, SELL_INSTANT_INVENTORY, SELL_ORDER_QTY, SELL_ORDER_PRICE, SELL_ORDER_CONFIRM, SELL_ORDER_MANAGE, ORDER_MANAGE, GRAPHS, NONE
                    
                    // Rule out simple CONTAINERNAME Checks
                        // After this check, can be any of:
                        // CATEGORY, SUBCATEGORY, PRODUCT, BUY_INSTANT_QTY, BUY_ORDER_MANAGE, SELL_INSTANT_QTY, SELL_ORDER_MANAGE, GRAPHS, NONE
                    if(true);
                        &exact_containers[]  = split(", ","How many do you want?, How much do you want to pay?, Confirm Buy Order, How many are you selling?, At what price are you selling?, Confirm Sell Offer, Co-op Bazaar Orders, Your Bazaar Orders, Confirm Instant Buy, Are you sure?");
                        &exact_gui_types[]   = split(", ","BUY_ORDER_QTY, BUY_ORDER_PRICE, BUY_ORDER_CONFIRM, SELL_ORDER_QTY, SELL_ORDER_PRICE, SELL_ORDER_CONFIRM, ORDER_MANAGE, ORDER_MANAGE, BUY_INSTANT_CONFIRM, SELL_INSTANT_INVENTORY");
                        #exact_container_idx = indexof(&exact_containers[],,%CONTAINERNAME%);
                        if(%#exact_container_idx% != -1);
                            &bazaar_gui = %&exact_gui_types[%#exact_container_idx%]%;
                        endif;
                    endif;
                    
                    // Check if we are in a Category
                        // After this check, can be any of:
                        // SUBCATEGORY, PRODUCT, BUY_INSTANT_QTY, BUY_ORDER_MANAGE, SELL_INSTANT_QTY, SELL_ORDER_MANAGE, GRAPHS, NONE
                    if(%&bazaar_gui% == "");
                        ifmatches(%CONTAINERNAME%,"^Bazaar \u279c (?:Farming|Mining|Combat|Woods & Fishes|Oddities)$");
                            &bazaar_gui = "CATEGORY";
                        endif;
                    endif;
                    
                    // Check if we are in a Subcategory GUI. Subcategory GUIs will have Sell Inventory Now (Chest), Go Back (Arrow), Manage Orders (Book).
                        // After this check, can be any of:
                        // PRODUCT, BUY_INSTANT_QTY, BUY_ORDER_MANAGE, SELL_INSTANT_QTY, SELL_ORDER_MANAGE, GRAPHS, NONE
                    if(%&bazaar_gui% == "");
                        &check_items[]  = split(", ","chest, book");
                        &check_names[]  = split(", ","Sell Inventory Now, Manage Orders");
                        subcategory_gui = bazaarItemCheck(&check_items[],&check_names[]);
                        if(%subcategory_gui%);
                            &bazaar_gui = "SUBCATEGORY";
                        endif;
                    endif;
                    
                    // Check if we are in a Product GUI. Product GUIs will have View Graphs item.
                        // After this check, can be any of:
                        // BUY_INSTANT_QTY, BUY_ORDER_MANAGE, SELL_INSTANT_QTY, SELL_ORDER_MANAGE, GRAPHS, NONE
                    if(%&bazaar_gui% == "");
                        &check_items[] = split(", ","paper, filled_map");
                        &check_names[] = split(", ","View Graphs, Create Buy Order");
                        product_gui    = bazaarItemCheck(&check_items[],&check_names[]);
                        if(%product_gui%);
                            &bazaar_gui = "PRODUCT";
                        endif;
                    endif;
                    
                    // Check if we are in a Order Manage GUI.
                        // After this check, can be any of:
                        // BUY_INSTANT_QTY, SELL_INSTANT_QTY, GRAPHS, NONE
                    if((%&bazaar_gui% == "") && (%CONTAINERNAME% == "Order options"));
                        &check_items[]       = split(", ","stained_hardened_clay, name_tag");
                        &check_names[]       = split(", ","Cancel Order, Flip Order");
                        buy_order_manage_gui = bazaarItemCheck(&check_items[],&check_names[]);
                        if(%buy_order_manage_gui%);
                            &bazaar_gui = "BUY_ORDER_MANAGE";
                        else;
                            &bazaar_gui = "SELL_ORDER_MANAGE";
                        endif;
                    endif;
                    
                    // Check if we are in a BUY_INSTANT_QTY GUI.
                        // After this check, can be any of:
                        // SELL_INSTANT_QTY, GRAPHS, NONE
                    if(%&bazaar_gui% == "");
                        &check_names[]      = split(", ","Buy only one!, Fill my inventory!");
                        buy_instant_qty_gui = bazaarNameCheck(&check_names[]);
                        if(%buy_instant_qty_gui%);
                            &bazaar_gui = "BUY_INSTANT_QTY";
                        endif;
                    endif;
                    
                    // Check if we are in a SELL_INSTANT_QTY GUI.
                        // After this check, can be any of:
                        // GRAPHS, NONE
                    if(%&bazaar_gui% == "");
                        &check_names[]       = split(", ","Sell a single item!, Sell a stack!");
                        sell_instant_qty_gui = bazaarNameCheck(&check_names[]);
                        if(%sell_instant_qty_gui%);
                            &bazaar_gui = "SELL_INSTANT_QTY";
                        endif;
                    endif;
                    
                    // Check if we are in a GRAPHS GUI.
                        // After this check, can be any of:
                        // NONE
                    if(%&bazaar_gui% == "");
                        &check_names[] = split(", ","Buy Price 31d 7d 24h, Buy Orders Volume 31d 7d 24h");
                        &check_items[] = split(", ","paper, paper");
                        graphs_gui     = bazaarItemCheck(&check_items[],&check_names[]);
                        if(%graphs_gui%);
                            &bazaar_gui = "GRAPHS";
                        endif;
                    endif;
                elseif(%GUI% == "GUIEDITSIGN");
                    // Can be any of:
                        // BUY_ORDER_QTY_SIGN, BUY_ORDER_PRICE_SIGN, BUY_ORDER_FLIP, SELL_ORDER_QTY_SIGN, SELL_ORDER_PRICE_SIGN, BUY_INSTANT_QTY_SIGN, NONE
                        //
                        
                    // Rule out simple CONTAINERNAME Checks
                        // After this check, can be any of:
                        // BUY_INSTANT_QTY_SIGN, NONE
                    if(true);
                        &exact_containers[]  = split(", ","How many do you want?, How much do you want to pay?, How many are you selling?, At what price are you selling?, Order options");
                        &exact_gui_types[]   = split(", ","BUY_ORDER_QTY_SIGN, BUY_ORDER_PRICE_SIGN, SELL_ORDER_QTY_SIGN, SELL_ORDER_PRICE_SIGN, BUY_ORDER_FLIP");
                        #exact_container_idx = indexof(&exact_containers[],,%CONTAINERNAME%);
                        if(%#exact_container_idx% != -1);
                            &bazaar_gui = %&exact_gui_types[%#exact_container_idx%]%;
                        endif;
                    endif;
                    
                    // Check if we are in BUY_INSTANT_QTY_SIGN GUI.
                        // After this check, can be any of:
                        // NONE
                    if(%&bazaar_gui% == "");
                        // CONTAINERNAME will always be maximum of 31 characters long, in format:
                        // <product> <arrow> Instant Buy
                        // <arrow> Instant Buy length = 14
                        // <product> + <...arrow> = 31
                        
                        &try_suffixes[]         = split(", "," \u279c Instant Buy, \u279c Instant Bu,  \u279c Instant B,  \u279c Instant ,  \u279c Instant,  \u279c Instan,  \u279c Insta,  \u279c Inst,  \u279c Ins,  \u279c In,  \u279c I,  \u279c ,  \u279c,  ");
                        #enforce_max_len_at_idx = 10; // If we match any of the suffixes above past this Index, only accept it if CONTAINERNAME's length >= 31.
                        #container_name_length  = strlen(%CONTAINERNAME%);
                        foreach(&try_suffixes[],&try_suffix,#tsi);
                            ifmatches(%CONTAINERNAME%,"%&try_suffix%$");
                                if((%#tsi% < %#enforce_max_len_at_idx%) || (%#container_name_length% >= 31));
                                    buy_instant_qty_gui = true;
                                    break;
                                elseif((%#tsi% >= %#enforce_max_len_at_idx%) && (%#container_name_length% < 31));
                                    break;
                                endif;
                            endif;
                        next;
                        
                        if(%buy_instant_qty_gui%);
                            &bazaar_gui = "BUY_INSTANT_QTY_SIGN";
                        endif;
                    endif;
                endif;
            endif;
            
            // Apply GUI Path Detection Logic
            if(true);
                if(%&bazaar_gui% == "");
                    &bazaar_gui = "NONE";
                endif;
                
                #null_index         = indexof(&gui_nulls[],,%&bazaar_gui%);
                #arrow_index        = indexof(&gui_path_back_arrow[],,%&bazaar_gui%);
                #non_standard_index = indexof(&gui_path_non_standard[],,%&bazaar_gui%);
                #function_index     = indexof(&gui_path_functions[],,%&bazaar_gui%);
                if(true);
                    if(%#null_index% != -1);
                        &bazaar_path = "NULL";
                    elseif(%#arrow_index% != -1);
                        &arrow_nbt = searchItemNBT("Go Back","arrow");
                        ifmatches(%&arrow_nbt%,".");
                            &match_string = jsonget("display.Lore.0",%&arrow_nbt%);
                            ifmatches(%&match_string%,"To (.+)",&previous_name,1);
                                #product_index = getBazaarIndex(%&previous_name%);
                                if(%#product_index% == -1);
                                    &bazaar_path = "ERROR_NOT_FOUND";
                                else;
                                    &bazaar_path = %@&mkb_baz_paths[%#product_index%]%;
                                endif;
                            endif;
                        endif;
                    elseif(%#non_standard_index% != -1);
                        &gui_enums[]                 = split(", ","BUY_INSTANT_CONFIRM, BUY_ORDER_CONFIRM, SELL_ORDER_CONFIRM");
                        &gui_names[]                 = split(", ","Custom Amount, Buy Order, Sell Offer");
                        &gui_lore_regex[]            = split("!, ","(.+)!, Order: [\d\.,\-]+x (.+)!, Selling: [\d\.,\-]+x (.+)");
                        #gui_lore_index[]            = split(", ","0, 4, 4");
                        #gui_enum_index              = indexof(&gui_enums[],,%&bazaar_gui%);
                        if(%#gui_enum_index% != -1);
                            &search_nbt = searchItemNBT(%&gui_names[%#gui_enum_index%]%,"");
                            ifmatches(%&search_nbt%,".");
                                &gui_lore_string = jsonget("display.Lore.%#gui_lore_index[%#gui_enum_index%]%",%&search_nbt%);
                                ifmatches(%&gui_lore_string%,"^ERROR_");
                                    log("&4Error: Could not extract a Lore String from index &c%#gui_lore_index[%#gui_enum_index%]%&4 from NBT: &c%&search_nbt%&4!");
                                    &bazaar_path = "ERROR_NOT_FOUND";
                                elseifmatches(%&gui_lore_string%,%&gui_lore_regex[%#gui_enum_index%]%,&capture_group,1);
                                    log("&aFound capture group &d%&capture_group%&a from string &d%&gui_lore_string%&a.");
                                    #product_index = getBazaarIndex(%&capture_group%);
                                    if(%#product_index% == -1);
                                        &bazaar_path = "ERROR_NOT_FOUND";
                                        log("&4Error: Could not find index of &d%&capture_group%&7 as a Bazaar Product!");
                                    else;
                                        &bazaar_path = %@&mkb_baz_paths[%#product_index%]%;
                                        log("&aFound index of &d%&capture_group%&a to be &e%#product_index%&a!");
                                    endif;
                                else;
                                    &bazaar_path = "ERROR_NOT_FOUND";
                                    log("&4Error: Could not match &d%&gui_lore_regex[%#gui_enum_index%]%&4 against Lore String: &c%&gui_lore_string%&4.");
                                endif;
                            else;
                                &bazaar_path = "ERROR_NOT_FOUND";
                                log("&4Error: Could not find any Item named &d%&gui_names[%#gui_enum_index%]%&4 in the Current GUI!");
                            endif;
                        else;
                            &bazaar_path = "ERROR_NOT_FOUND";
                            log("&4Error: Could not find &&bazaar_gui &c%&bazaar_gui%&4 in &gui_enums[]!");
                        endif;
                    elseif(%#function_index% != -1);
                        if(%&bazaar_gui% == "CATEGORY");
                            &bazaar_path = getCurrentBazaarCategoryPath();
                        elseif(%&bazaar_gui% == "SUBCATEGORY");
                            &bazaar_path = getCurrentBazaarSubcategoryPath();
                        elseif(%&bazaar_gui% == "PRODUCT");
                            &bazaar_path = getCurrentBazaarProductPath();
                        endif;
                    endif;
                endif;
            endif;
            
            return(%&bazaar_gui%,%&bazaar_path%);
        endfunction;
    // bazaar/index/isPathSiblingOf
        // Checks if the Current Path is a Sibling (same Subcategory) as the Other Path.
            // Params:
                // {string} <&other_path>
                // {string} [&current_path]    If omitted, will calculate
            // Returns a Boolean
        function isPathSiblingOf(&other_path,&current_path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1231
            if(%&current_path% == "");
                &current_path[] = getBazaarGUIType();
                if(%&current_path[0]% == "NONE");
                    return(False);
                endif;
                &current_path = %&current_path[1];
            endif;
            
            &other_parts[] = split(".",%&other_path%);
            &curr_parts[]  = split(".",%&current_path%);
            foreach(&other_parts[],&other_part,#op);
                &curr_part = %&curr_parts[%#op%]%;
                if(%&other_part% != %&curr_part%);
                    break;
                else;
                    &matched_parts[] = %&other_part%;
                    &matched_path    = join(".",&matched_parts[]);
                    &matched_type    = jsonget("%&matched_path%.type",%@&mkb_baz_json%);
                    if(%&matched_type% == "SUBCATEGORY");
                        return_boolean = true;
                    endif;
                endif;
            next;
            return(%return_boolean%);
        endfunction;
    // bazaar/index/openBazaar
        // Opens the Bazaar Main Menu GUI.
            // Params:
            //      {boolean} [allow_command=true]  Whether or not to use the /bazaar command if a Booster Cookie effect is enabled.
            //
            // Returns a boolean indicating whether or not we are in the Bazaar Main Menu GUI.
        function openBazaar(allow_command=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:6
            &script_debug_name = "&6openBazaar";
            debug              = true;
            
            // Check if we are already in a valid Bazaar GUI.
            ifmatches(%CONTAINERNAME%,"^Bazaar \u279c (?:Farming|Mining|Combat|Woods & Fishes|Oddities)$");
                if(%GUI% == "GUICHEST");
                    return(True);
                endif;
            endif;
            
            // Make sure that we are on some sort of SkyBlock Server.
            do;
                debug_log(%debug%,%&script_debug_name%,"Getting onto a SkyBlock Server...");
                on_sb_server = gotoServer("SKYBLOCK");
                if(%on_sb_server%);
                    debug_log(%debug%,%&script_debug_name%,"On a valid SkyBlock Server.");
                    break;
                endif;
                debug_log(%debug%,%&script_debug_name%,"Still not on a valid SkyBlock Server...");
                wait("1t");
            until(%on_sb_server%);
            
            // Check if we can/should use the Command.
            if(%allow_command%);
                debug_log(%debug%,%&script_debug_name%,"Checking to see if we can use the Booster Cookie command...");
                cookie_active = isCookieEnabled(300);
                use_command   = %cookie_active%;
                
                // Try to enter the Bazaar GUI via RemoteGUI if we are using the Command.
                if(%use_command%);
                    bazaar_open = remoteGUI("BAZAAR");
                    if(%bazaar_open%);
                        debug_log(%debug%,%&script_debug_name%,"RemoteGUI successfully opened Bazaar.");
                        return(True);
                    endif;
                endif;
            endif;
            
            // If we could not open the Bazaar GUI via RemoteGUI / cannot use the Command, go there in person.
            if(true);
                debug_log(%debug%,%&script_debug_name%,"Could not use Command, or failed to open using RemoteGUI. Using goto...");
                in_bazaar = goto("BAZAAR",true);
                wait("1t");
                return(%in_bazaar%);
            endif;
        endfunction;
    // bazaar/index/progressPath
        // Given a Master Path and the Current Bazaar GUI Path, finds the next Item to click on in the GUI to progress the GUI
        // towards the End Goal and clicks on it until the GUI updates.
            // Params:
                // {string} <&master_path>           The Master (end target) Path
                // {boolean} [allow_command=true]    Whether or not to allow the usage of the /bz command if it is available
                // {number} [#tick_wait=20]          How many Ticks to wait between Item Clicks
                // {number} [#timeout_sec=30]        How many Seconds to wait before fn timeout. <= 0 = no timeout
        function progressPath(&master_path,allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1265
            // Setup fn vars
            if(true);
                debug              = true;
                &script_debug_name = "&9progressPath&7";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
                &current_baz_gui[] = getBazaarGUIType();
                &current_gui_type  = %&current_baz_gui[0]%;
                if((%GUI% == "GUIEDITSIGN") || (%GUI% == "NONE") || (%&current_gui_type% == "NONE"));
                    in_bazaar    = openBazaar(%allow_command%);
                    #timeout_sec = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                    return_bool  = call("progressPath",%&master_path%,%allow_command%,%#tick_wait%,%#timeout_sec%);
                    return(%return_bool%);
                endif;
                &current_gui_path    = %&current_baz_gui[1]%;
                &current_gui_parts[] = split(".",%&current_gui_path%);
                &master_gui_parts[]  = split(".",%&master_path%);
            endif;
            
            // Find whether we are ahead of the Master Path (have to go back), or behind of it (have to go forward), or at the end of the Master Path.
            if(true);
                if(%&master_path% == %&current_gui_path%);
                    debug_log(%debug%,%&script_debug_name%,"master path reached");
                    return(True);
                endif;
                
                foreach(&master_gui_parts[],&master_gui_part,#mgpi);
                    &current_gui_part = %&current_gui_parts[%#mgpi%]%;
                    debug_log(%debug%,%&script_debug_name%,"%#mgpi% > master_part = %&master_gui_part%, current_part = %&current_gui_part%");
                    &read_gui_parts[] = %&master_gui_part%;
                    &last_gui_path    = join(".",&read_gui_parts[]);
                    if((%&current_gui_part% == "") || ((%&current_gui_part% != %&master_gui_part%) && (%&current_gui_type% == "CATEGORY"));
                        &pos_to_master = "FORWARD";
                    elseif(%&current_gui_part% != %&master_gui_part%);
                        &pos_to_master = "BACK";
                    endif;
                    
                    if(%&pos_to_master% != "");
                        debug_log(%debug%,%&script_debug_name%,"pos_to_master: %&pos_to_master%");
                        if(%&master_gui_part% == "holds");
                            &read_gui_path = join(".",&read_gui_parts[]);
                            &read_gui_json = jsonget(%&read_gui_path%,%@&mkb_baz_json%);
                            ifbeginswith(%&read_gui_json%,"[");
                                #next_index       = %#mgpi% + 1;
                                &read_gui_parts[] = %&master_gui_parts[%#next_index%]%;
                            endif;
                        endif;
                        break;
                    endif;
                next;
                debug_log(%debug%,%&script_debug_name%,"curr gui type is %&curr_gui_type%");
                
                if(%&pos_to_master% == "FORWARD");
                    debug_log(%debug%,%&script_debug_name%,"have to go forward");
                    &read_gui_path = join(".",&read_gui_parts[]);
                    &read_gui_json = jsonget(%&read_gui_path%,%@&mkb_baz_json%);
                    &r_name        = jsonget("button.name",%&read_gui_json%);
                    &r_item        = jsonget("button.mcid",%&read_gui_json%);
                    &r_sbid        = jsonget("button.sbid",%&read_gui_json%);
                    ifmatches(%&r_sbid%,"^ERROR_");
                        unset(&r_sbid);
                    endif;
                elseif(%&pos_to_master% == "BACK");
                    debug_log(%debug%,%&script_debug_name%,"have to go backward");
                    &r_name = "Go Back";
                    &r_item = "arrow";
                    ifmatches(%&current_gui_type%,"PRODUCT");
                        sibling_product = isPathSiblingOf(%&master_path%,%&current_gui_path%);
                        if(!%sibling_product%);
                            &r_item = "skull";
                        endif;
                    endif;
                endif;
            endif;
            
            // Attempt to progress the GUI.
            if(true);
                &vars[] = split(" ","&r_name &r_item &r_sbid");
                foreach(&vars[],&var,#v);
                    &val = %%&var%%;
                    &logvar = regexreplace(&var,"(?<!&)&","&&");
                    debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar% : %&val%");
                next;
                &init_gui = getContainerString(True);
                do;
                    // 1. Check if our Container has updated
                    gui_updated = enteredNewGUI(%&init_gui%,True);
                    if(%gui_updated%);
                        debug_log(%debug%,%&script_debug_name%,"GUI Updated, breaking");
                        break;
                    endif;
                    
                    // 2. Check if the Function has timed out
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        debug_error(%debug%,%&script_debug_name%,"Function timed out, breaking");
                        break;
                    endif;
                    
                    // 3. If we can Click, try to find the Item in the Container.
                    can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                    if(%can_click%);
                        #i_slot    = -1;
                        #r_start   = 0;
                        #r_end     = %CONTAINERSLOTS% - 37;
                        #r_offset  = %#r_start%;
                        for(#r_slot,%#r_start%,%#r_end%);
                            #f_slot = %#r_slot%;
                            if(%&r_item%);
                                getslot(%&r_item%,#f_slot,%#r_offset%);
                            endif;
                            
                            if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                                #r_offset = %#f_slot% + 1;
                                &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                &f_nbt    = strip(%&f_nbt%);
                                &f_name   = getItemName(%&f_nbt%,%&f_item%);
                                if(%&r_sbid%);
                                    &f_sbid = getItemSBID(%&f_nbt%);
                                endif;
                                debug_log(%debug%,%&script_debug_name%,"found item %&f_item% %&f_name% at slot %#f_slot%");
                                m_item  = ((!%&r_item%) || (%&r_item% == %&f_item%));
                                m_name  = ((!%&r_name%) || (%&r_name% == %&f_name%));
                                m_sbid  = ((!%&r_sbid%) || (%&r_sbid% == %&f_sbid%));
                                m_match = ((%m_item%) && (%m_name%) && (%m_sbid%));
                                debug_log(%debug%,%&script_debug_name%,"m_match: %m_match%");
                                if(%m_match%);
                                    #i_slot = %#f_slot%;
                                    break;
                                endif;
                            else;
                                break;
                            endif;
                        next;
                        
                        if(%#i_slot% != -1);
                            slotclick(%#i_slot%);
                        endif;
                    endif;
                    
                    wait("1t");
                    inc(#waited_ticks);
                until((%func_timeout%) || (%gui_updated%));
            endif;
            
            // Recursive call self.
            if(true);
                if(!%func_timeout%);
                    #timeout_sec   = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                    return_boolean = call("progressPath",%&master_path%,%allow_command%,%#tick_wait%,%#timeout_sec%);
                    return(%return_boolean%);
                endif;
                return(False);
            endif;
        endfunction;
    // bazaar/index/getSubcategoryProductInventorySlotFromPath
        // Given a Subproduct's Path, extracts the relevant variables and checks in our Inventory to see whether or not we have any
        // of the Item described in the Subproduct. If we do, returns the first Inventory Slot where the Subproduct was found. If not,
        // returns -1. Slot IDs are Inventory Indexed.
            // Params:
                // {string} <&subproduct_path>    The dot-separated JSON Path of the Subproduct to look for within the Inventory.
                //
            // Returns the first Inventory Slot where the Subproduct was found. If not, returns -1. Slot IDs are Inventory Indexed.
        function getSubcategoryProductInventorySlotFromPath(&subproduct_path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:888
            #return_number = -1;
            #r_start       = 9;
            #r_end         = 43;
            &subprod_json  = jsonget(%&subproduct_path%,%@&mkb_baz_json%);
            &item[]        = jsonget("holds.mcid",%&subprod_json%);
            &name[]        = jsonget("holds.name",%&subprod_json%);
            &sbid[]        = jsonget("holds.sbid",%&subprod_json%);
            &item[]        = jsonget("button.mcid",%&subprod_json%);
            &name[]        = jsonget("button.name",%&subprod_json%);
            &sbid[]        = jsonget("button.sbid",%&subprod_json%);
            &terms[]       = split(", ","item, name, sbid");
            foreach(&terms[],&term,#t);
                &r_ptr = "&r_%&term%";
                &r_arr = "&%&term%[]";
                foreach(%&r_arr%,&entry);
                    ifnotbeginswith(%&entry%,"ERROR");
                        set(%&r_ptr%,%&entry%);
                        break;
                    endif;
                next;
            next;
            
            for(#r_slot,%#r_start%,%#r_end%);
                #f_slot = %#r_slot%;
                if(%&r_item%);
                    getslotinv(%&r_item%,#f_slot,%#r_offset%);
                endif;
                
                if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                    #r_offset = %#f_slot% + 1;
                    &f_item   = getslotiteminv(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                    &f_nbt    = strip(%&f_nbt%);
                    if(%&r_sbid%);
                        &f_sbid = getItemSBID(%&f_nbt%);
                    endif;
                    if(%&r_name%);
                        &f_name = getItemName(%&f_nbt%,%&f_item%);
                    endif;
                    m_item    = ((!%&r_item%) || (%&r_item% == %&f_item%));
                    m_name    = ((!%&r_name%) || (%&r_name% == %&f_name%));
                    m_sbid    = ((!%&r_sbid%) || (%&r_sbid% == %&f_sbid%));
                    m_match   = ((%m_item%) && (%m_name%) && (%m_sbid%));
                    if(%m_match%);
                        #return_number = %#f_slot%;
                        break;
                    endif;
                else;
                    break;
                endif;
            next;
            return(%#return_number%);
        endfunction;
    // bazaar/index/getSubcategoryProductPaths
        // Extracts all the Subproducts of a Subcategory's `holds` field and returns them as an Array.
            // Params:
                // {string} <&subcategory_path>    The dot-separated JSON Path of the Subcategory to get the Subproducts from.
                //
            // Returns an Array of the JSON Paths that are of type SUBPRODUCT within the specified Subcategory.
        function getSubcategoryProductPaths(&subcategory_path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:864
            for(#i,0,99);
                &subproduct_type = jsonget("%&subcategory_path%.holds.%#i%.type",%@&mkb_baz_json%);
                if(%&subproduct_type% == "SUBPRODUCT");
                    &return_array[] = "%&subcategory_path%.holds.%#i%";
                else;
                    break;
                endif;
            next;
            
            #return_array_sz = arraysize(&return_array[]);
            if(%#return_array_sz% == 0);
                &return_array[] = "NONE";
            endif;
            return(&return_array[]);
        endfunction;
    // bazaar/index/getJSONParent
        // Walks back a Bazaar JSON Path to the Object Type specified in [&stop_at]. Returns the JSON dot-separated path.
            // Params:
                // {string} <&json_path>             The dot-separated JSON Path of the lower-most Object that we want to walk back up from.
                // {string} [&stop_at="CATEGORY"]    The Object Type ENUM to stop at. Valid strings are:
                //                                   CATEGORY, SUBCATEGORY, SUBPRODUCT, BUTTON, PRODUCT.
            // Returns the dot-separated JSON Path in @&mkb_baz_json that can be used to get the Parent Object, or "NONE" if some error occurred.
        function getJSONParent(&json_path,&stop_at="CATEGORY");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:841
            &stop_at       = miscValidate(%&stop_at%,0,"CATEGORY","SUBCATEGORY","SUBPRODUCT","BUTTON","PRODUCT");
            &return_string = "NONE";
            &split_path[]  = split(".",%&json_path%);
            #split_path    = arraylength(&split_path[]);
            for(#to_index,%#split_path%,0);
                unset(&to_index[]);
                push(&to_index[],&split_path[0:%#to_index%]);
                &to_index = join(".",&to_index[]);
                &obj_type = jsonget("%&to_index%.type",%@&mkb_baz_json%);
                if(%&obj_type% == %&stop_at%);
                    &return_string = %&to_index%;
                    break;
                endif;
            next;
            return(%&return_string%);
        endfunction;
    // bazaar/index/getPartsPath
        // Gets the Path corresponding to an Array of Parts.
            // Params:
                // {string} <&parts[]>    The Parts of the Path to join together.
                //
            // Returns the Path String.
        function getPartsPath(&parts[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1001
            #parts = arraysize(&parts[]);
            if((%#parts% >= 1) && (%&parts[0]% != ""));
                &path = join(".",&parts[]);
            endif;
            return(%&path%);
        endfunction;
    // bazaar/index/getPathParts
        // Returns an Array of the 'parts' of a given Path.
            // Params:
                // {string} <&path>    The Path to get the 'parts' of.
                //
            // Returns a String Array.
        function getPathParts(&path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:989
            if(%&path% != "");
                &parts[] = split(".",%&path%);
            endif;
            return(&parts[]);
        endfunction;
    // bazaar/index/getPathJSON
        // Gets the JSON Object found at the specified Path.
            // Params:
                // {string} <&path>    The Path to the JSON Object to retrieve from @&mkb_baz_json.
                //
            // Returns the JSON String Object.
        function getPathJSON(&path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1039
            debug              = true;
            &script_debug_name = "&9getPathJSON";
            
            if(%&path% != "");
                debug_log(%debug%,%&script_debug_name%,"path %&path% not null");
                &object = jsonget(%&path%,%@&mkb_baz_json%);
                ifbeginswith(%&object%,"[");
                    &path_parts[] = getPathParts(%&path%);
                    pop(&path_parts[]);
                    &call_path  = getPartsPath(&path_parts[]);
                    debug_log(%debug%,%&script_debug_name%,"path is array, recursive calling with %&call_path%");
                    &path_json  = call("getPathJSON",%&call_path%);
                    return(%&path_json%);
                endif;
                return(%&object%);
            endif;
            debug_log(%debug%,%&script_debug_name%,"returning root");
            return(%@&mkb_baz_json%);
        endfunction;
    // bazaar/index/getPathType
        // Gets the Type of the JSON Object found at the specified Path.
            // Params:
                // {string} <&path>    The Path to the JSON Object to retrieve from @&mkb_baz_json.
                //
            // Returns the JSON Object's Type: ROOT, CATEGORY, SUBCATEGORY, SUBPRODUCT, PRODUCT, BUTTON.
        function getPathType(&path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1065
            &path_json = getPathJSON(%&path%);
            &path_type = jsonget("type",%&path_json%);
            return(%&path_type%);
        endfunction;
    // bazaar/index/getPathDepth
        // Calculates the 'depth' of a Path based off it's Type property in the mkb_baz_json Object.
            // Params:
                // {string} <&path>    The Path to calculate the Depth of.
                //
            // Returns the Integer 'depth' of the Path.
        function getPathDepth(&path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1076
            &path_type = getPathType(%&path%);
            if(%&path_type% == "ROOT");
                #path_depth = 0;
            elseif(%&path_type% == "CATEGORY");
                #path_depth = 1;
            elseif((%&path_type% == "PRODUCT") || (%&path_type% == "SUBCATEGORY"));
                #path_depth = 2;
            else;
                #path_depth = 3;
            endif;
            return(%#path_depth%);
        endfunction;
    // bazaar/index/getFromNewGUICost
        // Calculates the amount of Clicks required to get us from a new Bazaar GUI to <&target_path>.
            // Params:
                // {string} <&target_path>      JSON dot Path
                // {string} [&ancestor_path]    The Type of the Ancestor if known. If is ROOT, will add an additional
                //                              point of cost to the depth. If not, will return the Target's Depth as-is.
        function getFromNewGUICost(&target_path,&ancestor_path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1156
            #target_depth  = getPathDepth(%&target_path%);
            &ancestor_type = getPathType(%&ancestor_path%);
            if(%&ancestor_type% == "ROOT");
                #target_depth = %#target_depth% + 1;
            endif;
            return(%#target_depth%);
        endfunction;
    // bazaar/index/getCommonAncestorPath
        // Finds the Common Ancestor Path String between the Origin Path and the Target Path.
            // Params:
                // {string} <&origin_path>    The Origin JSON Path in @&mkb_baz_json
                // {string} <&target_path>    The Target JSON Path in @&mkb_baz_json
            // Returns the Path to the Common Ancestor, or an empty String if the Root JSON is the Common Ancestor.
        function getCommonAncestorPath(&origin_path,&target_path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1014
            debug              = true;
            &script_debug_name = "&6getCommonAncestorPath";
            
            &origin_parts[]    = getPathParts(%&origin_path%);
            &target_parts[]    = getPathParts(%&target_path%);
            foreach(&origin_parts[],&origin_part,#opi);
                &target_part = %&target_parts[%#opi%]%;
                if(%&origin_part% == %&target_part%);
                    debug_log(%debug%,%&script_debug_name%,"%#opi% > origin_part = %&origin_part%, target_part = %&target_part%");
                    &ancestor_parts[] = %&origin_part%;
                else;
                    break;
                endif;
            next;
            &ancestor_path = getPartsPath(&ancestor_parts[]);
            debug_log(%debug%,%&script_debug_name%,"ancestor path is %&ancestor_path%");
            return(%&ancestor_path%);
        endfunction;
    // bazaar/index/getFromOriginCost
        // Calculates the amount of Clicks required to get us from <&origin_path> to <&target_path>.
            // Params:
                // {string} <&origin_path>      JSON dot Path
                // {string} <&target_path>      JSON dot Path
                // {string} [&origin_type]      String ENUM of GUI Type: BUY_INSTANT_QTY, BUY_INSTANT_QTY_SIGN, BUY_INSTANT_CONFIRM, BUY_ORDER_QTY, BUY_ORDER_QTY_SIGN,
                //                              BUY_ORDER_CONFIRM, BUY_ORDER_MANAGE, BUY_ORDER_FLIP, SELL_INSTANT_QTY, SELL_INSTANT_INVENTORY, SELL_ORDER_QTY, SELL_ORDER_QTY_SIGN,
                //                              SELL_ORDER_PRICE, SELL_ORDER_PRICE_SIGN, SELL_ORDER_CONFIRM, SELL_ORDER_MANAGE, ORDER_MANAGE, GRAPHS
                // {string} [&ancestor_path]    The Ancestor Path between Origin and Target, if known. Will calculate if not known.
        function getFromOriginCost(&origin_path,&target_path,&origin_type,&ancestor_path);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1098
            debug              = true;
            &script_debug_name = "getFromOriginCost";
            
            // Calculate the additional cost of whatever Origin Type we are in.
            if(true);
                &cost_inf[] = split(", ","SELL_INSTANT_INVENTORY, NONE");
                &cost_one[] = split(", ","BUY_INSTANT_QTY, BUY_INSTANT_QTY_SIGN, BUY_ORDER_QTY, BUY_ORDER_QTY_SIGN, BUY_ORDER_PRICE, BUY_ORDER_PRICE_SIGN, BUY_ORDER_CONFIRM, SELL_INSTANT_QTY, SELL_ORDER_QTY, SELL_ORDER_QTY_SIGN, SELL_ORDER_PRICE, SELL_ORDER_PRICE_SIGN, SELL_ORDER_CONFIRM, ORDER_MANAGE, GRAPHS");
                &cost_two[] = split(", ","BUY_INSTANT_CONFIRM, SELL_ORDER_MANAGE, BUY_ORDER_MANAGE, BUY_ORDER_FLIP");
                #inf_index  = indexof(&cost_inf[],,%&origin_type%);
                #one_index  = indexof(&cost_one[],,%&origin_type%);
                #two_index  = indexof(&cost_two[],,%&origin_type%);
                if(%#inf_index% != -1);
                    return(999);
                elseif(%#one_index% != -1);
                    #add_cost = 1;
                elseif(%#two_index% != -1);
                    #add_cost = 2;
                endif;
            endif;
            
            // 1a. Find Common Ancestor between Origin and Target Path.
            if(%&ancestor_path% == "");
                &ancestor_path = getCommonAncestorPath(%&origin_path%,%&target_path%);
            endif;
            
            // 1b. Find all Path's Depths
            #ancestor_depth = getPathDepth(%&ancestor_path%);
            #origin_depth   = getPathDepth(%&origin_path%);
            #target_depth   = getPathDepth(%&target_path%);
            
            // 2a. Calculate the distance from the Origin to the Common Ancestor Path.
            #origin_to_ancestor_dist = %#origin_depth% - %#ancestor_depth%;
            
            // 2b. Calculate the distance from the Common Ancestor to the Target Path.
            &ancestor_type = getPathType(%&ancestor_path%);
            if(%&ancestor_type% == "ROOT");
                #ancestor_augment = 1;
            endif;
            #ancestor_to_target_dist = (%#target_depth% - %#ancestor_depth%) - %#ancestor_augment%;
            
            // 3a. Calculate and return the sum of the distances
            #sum_dist = (%#origin_to_ancestor_dist% + %#ancestor_to_target_dist%) + %#add_cost%;
            
            &vars[] = split(" ","&ancestor_path #ancestor_depth &origin_path #origin_depth &target_path #target_depth #origin_to_ancestor_dist &ancestor_type #ancestor_augment #ancestor_to_target_dist #add_cost #sum_dist");
            foreach(&vars[],&var,#v);
                &val = %%&var%%;
                &logvar = regexreplace(&var,"(?<!&)&","&&");
                debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar% : %&val%");
            next;
            return(%#sum_dist%);
        endfunction;
    // bazaar/index/getTravelOptions
        // Calculates the cost of each 'travel' option (origin path to target path, close and re-open Bazaar GUI,
        // subproduct => subcategory => subproduct, subproduct click), then sorts them by their cost and returns them.
            // Params:
                // {string} <&origin_path>    JSON dot Path
                // {string} <&target_path>    JSON dot Path
                // {string} [&origin_type]    String ENUM of GUI Type: BUY_INSTANT_QTY, BUY_INSTANT_QTY_SIGN, BUY_INSTANT_CONFIRM, BUY_ORDER_QTY, BUY_ORDER_QTY_SIGN,
                //                            BUY_ORDER_CONFIRM, BUY_ORDER_MANAGE, BUY_ORDER_FLIP, SELL_INSTANT_QTY, SELL_INSTANT_INVENTORY, SELL_ORDER_QTY, SELL_ORDER_QTY_SIGN,
                //                            SELL_ORDER_PRICE, SELL_ORDER_PRICE_SIGN, SELL_ORDER_CONFIRM, SELL_ORDER_MANAGE, ORDER_MANAGE, GRAPHS
            // Returns an Array of Strings in format: '<#cost>|<&enum>', where <#cost> is the cost of taking that Path,
            // and <&enum> is one of: FROM_ORIGIN, FROM_NEW_GUI, FROM_SUBCATEGORY, FROM_PRODUCT.
        function getTravelOptions(&origin_path,&target_path,&origin_type);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1175
            &cost_inf[] = split(", ","SELL_INSTANT_INVENTORY, NONE");
            #cost_inf   = indexof(&cost_inf[],,%&origin_type%);
            
            // 1a. Determine common ancestor
            &ancestor_path = getCommonAncestorPath(%&origin_path%,%&target_path%);
            
            // 2a. Calculate FROM_ORIGIN cost
            if(%#cost_inf% == -1);
                #cost_from_origin = getFromOriginCost(%&origin_path%,%&target_path%,%&origin_type%,%&ancestor_path%);
                #cost_numbers[]   = %#cost_from_origin%;
                &cost_strings[]   = "%#cost_from_origin%|FROM_ORIGIN";
            endif;
            
            // 2b. Calculate FROM_NEW_GUI cost.
            #cost_from_new_gui = getFromNewGUICost(%&target_path%,%&ancestor_path%);
            #cost_numbers[]    = %#cost_from_new_gui%;
            &cost_strings[]    = "%#cost_from_new_gui%|FROM_NEW_GUI";
            
            // 2c. Calculate FROM_SUBCATEGORY cost.
            if(%#cost_inf% == -1);
                &target_type = getPathType(%&target_path%);
                if((%&target_type% == "SUBPRODUCT") || (%&target_type% == "SUBCATEGORY"));
                    &ancestor_type = getPathType(%&ancestor_type%);
                    if(%&ancestor_type% == "SUBCATEGORY");
                        #cost_from_subcategory = 2;
                    else;
                        #cost_from_subcategory = 3;
                    endif;
                    #cost_numbers[] = %#cost_from_subcategory%;
                    &cost_strings[] = "%#cost_from_subcategory%|FROM_SUBCATEGORY";
                endif;
            endif;
            
            // 2d. Calculate FROM_PRODUCT cost.
            if((%#cost_inf% == -1) && ((%&target_type% == "SUBPRODUCT") || (%&target_type% == "PRODUCT")));
                #cost_from_product = 1;
                #cost_numbers[]    = %#cost_from_product%;
                &cost_strings[]    = "%#cost_from_product%|FROM_PRODUCT";
            endif;
            
            // 3a. Sort cost strings by ascending cost_numbers
            #cost_numbers = arraysize(#cost_numbers[]);
            if(%#cost_numbers% > 1);
                sort("ASC",#cost_numbers[],&cost_strings[]);
            endif;
            
            // 3b. Return sorted cost_strings.
            return(&cost_strings[]);
        endfunction;
    // bazaar/index/openBazaarTo
        // Given one or more compatible GUI ENUMs, navigates through the Bazaar into the specified GUI Type.
            // Params:
                // {string} [&search_term]           The Product Path, SBID, Display Name, or Index in the @&mkb_baz_paths Array. If omitted
                //                                   or invalid, will just open the Bazaar.
                // {boolean} [allow_command=true]    Whether or not to allow the usage of the /bz Command.
                // {number} [#tick_wait=20]          Amount of ticks to wait between clicks.
                // {number} [#timeout_sec=30]        Max seconds fn can run for before timing out. <= 0 to infinite loop until success.
            // Returns a Boolean indicating whether or not the specified GUI was correctly opened.
        function openBazaarTo(&search_term,allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index.txt:1430
            // Setup fn vars
            if(true);
                // Setup fn vars
                if(true);
                    debug              = true;
                    &script_debug_name = "&6openBazaarTo&7";
                    do_timeout         = %#timeout_sec% > 0;
                    #start_time        = %TIMESTAMP%;
                endif;
                
                // Process params
                if(true);
                    ifmatches(%&search_term%,"^\d+$");
                        #bazaar_index := %&search_term%;
                    else;
                        #bazaar_index  = getBazaarIndex(%&search_term%);
                    endif;
                    
                    #bazaar_paths = arraylength(@&mkb_baz_paths[]);
                    if((%#bazaar_index% >= 0) && (%#bazaar_index% <= %#bazaar_paths%));
                        &bazaar_path = %@&mkb_baz_paths[%#bazaar_index%]%;
                        &bazaar_sbid = %@&mkb_baz_sbids[%#bazaar_index%]%;
                        &bazaar_name = %@&mkb_baz_names[%#bazaar_index%]%;
                        product_mode = true;
                        debug_log(%debug%,%&script_debug_name%,"opening Bazaar to Product &d%&bazaar_name% [%&bazaar_sbid%]");
                    else;
                        debug_log(%debug%,%&script_debug_name%,"opening Bazaar");
                    endif;
                endif;
                
                // Enter Bazaar and find GUI Type
                if(true);
                    &bazaar_gui_type[] = getBazaarGUIType();
                    &bazaar_gui_type   = %&bazaar_gui_type[0]%;
                    if(%&bazaar_gui_type% == "NONE");
                        bazaar_opened = openBazaar(%allow_command%);
                        if(!%bazaar_opened%);
                            debug_error(%debug%,%&script_debug_name%,"Could not open the Bazaar.");
                            return(False);
                        endif;
                        &bazaar_gui_type[] = getBazaarGUIType();
                        &bazaar_gui_type   = %&bazaar_gui_type[0]%;
                    endif;
                    
                    if(!%product_mode%);
                        return(True);
                    endif;
                    
                    &bazaar_gui_path = %&bazaar_gui_type[1]%;
                endif;
            endif;
            
            // Find the possible Travel Paths to this Path.
            if(true);
                &possible_paths[] = getTravelOptions(%&bazaar_gui_path%,%&bazaar_path%,%&bazaar_gui_type%);
                foreach(&possible_paths[],&possible_path,#pp);
                    &possible_path[] = split("|",%&possible_path%);
                    #possible_cost  := %&possible_path[0]%;
                    &possible_enum   = %&possible_path[1]%;
                    if(%&possible_enum% == "FROM_PRODUCT");
                        &search_item_paths[] = %&bazaar_path%;
                    elseif(%&possible_enum% == "FROM_SUBCATEGORY");
                        &subcategory         = getJSONParent(%&bazaar_path%,"SUBCATEGORY");
                        &subcategory_paths[] = getSubcategoryProductPaths(%&subcategory%);
                        foreach(&subcategory_paths[],&subcategory_path,#spi);
                            if(%&subcategory_path% != %&bazaar_path%);
                                &search_item_paths[] = %&subcategory_path%;
                            endif;
                        next;
                    elseif(%&possible_enum% == "FROM_ORIGIN");
                        &valid_enum = %&possible_enum%;
                    elseif(%&possible_enum% == "FROM_NEW_GUI");
                        &valid_enum = %&possible_enum%;
                    endif;
                    
                    #search_item_paths_sz = arraysize(&search_item_paths[]);
                    if(%#search_item_paths_sz% >= 1);
                        foreach(&search_item_paths[],&search_item_path,#sip);
                            #search_item_slot = getSubcategoryProductInventorySlotFromPath(%&search_item_path%);
                            debug_log(%debug%,%&script_debug_name%,"search_item_slot for %&search_item_path% is %#search_item_slot%");
                            if(%#search_item_slot% != -1);
                                &valid_enum = %&possible_enum%;
                                #valid_slot = %#search_item_slot%;
                                break;
                            endif;
                        next;
                        unset(&search_item_paths[])
                    endif;
                    
                    if(%&valid_enum% != "");
                        debug_log(%debug%,%&script_debug_name%,"will be using enum type %&valid_enum% with cost %#possible_cost%!");
                        break;
                    endif;
                next;
            endif;
            
            // Execute actions depending on which Valid ENUM we found.
            if(true);
                if((%&valid_enum% == "FROM_PRODUCT") || (%&valid_enum% == "FROM_SUBCATEGORY"));
                    debug_log(%debug%,%&script_debug_name%,"will be clicking on product");
                    &init_gui = getContainerString(True);
                    do;
                        entered_new_gui = enteredNewGUI(%&init_gui%,True);
                        if(%entered_new_gui%);
                            debug_log(%debug%,%&script_debug_name%,"entered new GUI!");
                            break;
                        endif;
                        
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"function timed out!");
                            break;
                        endif;
                        
                        can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                        if(%can_click%);
                            #click_slot = invslot_to_conslot(%#valid_slot%);
                            debug_log(%debug%,%&script_debug_name%,"updated click slot is %#click_slot%");
                            slotclick(%#click_slot%);
                        endif;
                        
                        wait("1t");
                        inc(#waited_ticks);
                    until((%entered_new_gui%) || (%func_timeout%));
                    if(%func_timeout%);
                        return(False);
                    endif;
                elseif(%&valid_enum% == "FROM_NEW_GUI");
                    localGUI("NONE");
                    in_bazaar = openBazaar(%allow_command%);
                    if(!%in_bazaar%);
                        debug_error(%debug%,%&script_debug_name%,"Could not open the Bazaar");
                        return(False);
                    endif;
                endif;
            endif;
            
            // Progress the Path along to fix any Errors and/or continue the Path.
            if(true);
                if(%do_timeout%);
                    #timeout_sec = %#timeout_sec% - (%TIMESTAMP% - %#start_time%);
                endif;
                return_boolean = progressPath(%&bazaar_path%,%allow_command%,%tick_wait%,%#timeout_sec%);
                return(%return_boolean%);
            endif;
        endfunction;
    // bazaar/index_orders/bazaarOpenOrders
        // Opens the Manage Orders GUI.
            // Params:
                // {boolean} [allow_command=true]    Whether or not we want to allow the usage of the /bz command.
                // {number} [#tick_wait=20]          Amount of Ticks to wait in between Actions (clicks).
                // {number} [#timeout_sec=30]        Amount of Seconds Function can run for before timing out. Set to <= 0 to disable.
            // Returns a Boolean indicating whether or not the Function was successful.
        function bazaarOpenOrders(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index_orders.txt:6
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bazaarOpenOrders";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
            endif;
            
            // Start looping until we get into the Manage Orders GUI, or we encounter an Error that cannot be remedied.
            if(true);
                debug_log(%debug%,%&script_debug_name%,"attempting to index bazaar orders...");
                &order_enums[]  = split(", ","CATEGORY, SUBCATEGORY, PRODUCT, BUY_ORDER_MANAGE, BUY_ORDER_FLIP, SELL_ORDER_MANAGE");
                &order_mcids[]  = split(", ","book, book, book, arrow, NULL, arrow");
                &order_names[]  = split(", ","Manage Orders, Manage Orders, Manage Orders, Go Back, NULL, Go Back");
                &order_action[] = split(", ","CLICK, CLICK, CLICK, CLICK, EXIT, CLICK");
                &target_gui     = "ORDER_MANAGE";
                
                do;
                    // 1. Check if the Function has timed out
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        exit_condition_reached = true;
                        debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                        break;
                    endif;
                    
                    // 2. Check what Bazaar GUI we are in. If we are in a GUI that has access to the Manage Orders Button, progress to it.
                    if(true);
                        &bazaar_gui[] = getBazaarGUIType();
                        &bazaar_enum  = %&bazaar_gui[0]%;
                        &bazaar_path  = %&bazaar_gui[1]%;
                        #enum_index   = indexof(&order_enums[],,%&bazaar_enum%);
                        if(%&bazaar_enum% == %&target_gui%);
                            return_boolean         = true;
                            exit_condition_reached = true;
                            break;
                        elseif(%#enum_index% != -1);
                            &order_action = %&order_action[%#enum_index%]%;
                            if(%&order_action% == "EXIT");
                                localGUI("NONE");
                            elseif(%&order_action% == "CLICK");
                                &find_mcid  = "MCID: %&order_mcids[%#enum_index%]%";
                                &find_name  = "NAME: %&order_names[%#enum_index%]%";
                                #found_slot = findItemContainer(false,%&find_mcid%,%&find_name%);
                                if(%#found_slot% != -1);
                                    &init_gui     = getContainerString(true);
                                    #waited_ticks = 0;
                                    do;
                                        // 1. Check if the Function has timed out
                                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        if(%func_timeout%);
                                            exit_condition_reached = true;
                                            debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                                            break;
                                        endif;
                                        
                                        // 2. Check if the GUI has Updated
                                        gui_updated = enteredNewGUI(%&init_gui%,true);
                                        if(%gui_updated%);
                                            break;
                                        endif;
                                        
                                        // 3. Click, if we can click.
                                        can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                                        if(%can_click%);
                                            slotclick(%#found_slot%);
                                        endif;
                                        
                                        wait("1t");
                                        inc(#waited_ticks);
                                    until((%gui_updated%) || (%exit_condition_reached%));
                                endif;
                            endif;
                        else;
                            if(%GUI% != "NONE");
                                localGUI("NONE");
                            endif;
                            
                            #recurse_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            bazaar_opened    = openBazaarTo("",%allow_command%,%#tick_wait%,%#recurse_timeout%);
                            if(!%bazaar_opened%);
                                debug_error(%debug%,%&script_debug_name%,"Could not open the Bazaar!");
                                exit_condition_reached = true;
                                break;
                            else;
                                debug_log(%debug%,%&script_debug_name%,"&aSuccessfully entered the Bazaar.");
                            endif;
                        endif;
                    endif;
                until(%exit_condition_reached%);
            endif;
            
            return(%exit_condition_reached%);
        endfunction;
    // bazaar/manage_order/bazaarCollectOrder
        // Collects an Active Bazaar Order given it's Order String (from bazaarIndexOrders).
            // Params:
                // {string} <&order_string>          The Order String from bazaarIndexOrders.
                // {boolean} [allow_command=true]    Whether or not we want to allow the usage of the /bz command.
                // {number} [#tick_wait=20]          Amount of Ticks to wait in between Actions (clicks).
                // {number} [#timeout_sec=30]        Amount of Seconds Function can run for before timing out. Set to <= 0 to disable.
            // Returns a Boolean indicating whether or not the Order was successfully collected.
        function bazaarCollectOrder(&order_string,allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/manage_order.txt:7
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bazaarCollectOrder";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
                &order_data[]      = split("|",%&order_string%);
                &order_sbid        = %&order_data[0]%;
                &order_type        = %&order_data[1]%;
                &price_per_unit    = %&order_data[2]%;
                #items_filled     := %&order_data[3]%;
                #items_total      := %&order_data[4]%;
                #amount_claimable := %&order_data[5]%;
                order_expired     := %&order_data[6]%;
                
                #order_index = getBazaarIndex(%&order_sbid%);
                if(%#order_index% == -1);
                    debug_error(%debug%,%&script_debug_name%,"Invalid Order String provided.");
                    return(False);
                else;
                    &r_name = "%&order_type%: %@&mkb_baz_names[%#order_index%]%";
                endif;
                
                #order_index = getDatamapItemIndex(%&order_sbid%);
                if(%#order_index% != -1);
                    &r_item = %@&sb_datamap_item_mcids[%#order_index%]%;
                endif;
            endif;
            
            // Start looping until we get into the Manage Orders GUI, or we encounter an Error that cannot be remedied.
            if(true);
                
                &target_gui = "ORDER_MANAGE";
                do;
                    // 1. Check if the Function has timed out
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        exit_condition_reached = true;
                        debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                        break;
                    endif;
                    
                    // 2. Check what Bazaar GUI we are in. If we are in a GUI that has access to the Manage Orders Button, progress to it.
                    if(true);
                        &bazaar_gui[] = getBazaarGUIType();
                        &bazaar_enum  = %&bazaar_gui[0]%;
                        &bazaar_path  = %&bazaar_gui[1]%;
                        if(%&bazaar_enum% == %&target_gui%);
                            #r_start  = 0;
                            #r_end    = %CONTAINERSLOTS% - 37;
                            #r_offset = 0;
                            for(#r_slot,%#r_start%,%#r_end%);
                                #f_slot = %#r_slot%;
                                if(%&r_item%);
                                    getslot(%&r_item%,#f_slot,%#r_offset%);
                                endif;
                                
                                if((%#f_slot% >= %#r_start%) && (%#f_slot% <= %#r_end%));
                                    #r_offset = %#f_slot% + 1;
                                    &f_item   = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                    &f_nbt    = strip(%&f_nbt%);
                                    &f_name   = getItemName(%&f_nbt%,%&f_item%);
                                    if(%&f_name% == %&r_name%);
                                        match(%&f_nbt%,%&price_per_unit_regex%,&f_price_per_unit,1,"0");
                                        match(%&f_nbt%,%&items_filled_regex%,&f_items_filled,1,"0");
                                        match(%&f_nbt%,%&items_total_regex%,&f_items_total,1,"0");
                                        match(%&f_nbt%,%&amount_claimable%,&f_amount_claimable,1,"0");
                                        &f_order_name       = _matchExpressionNBT(%&f_name%,"^(?:BUY|SELL): (.+)");
                                        #f_order_index      = getBazaarIndex(%&f_order_name%);
                                        &f_order_sbid       = %@&mkb_baz_sbids[%#order_index%]%;
                                        if(%&f_order_sbid% == %&order_sbid%);
                                            #f_items_filled     = stringToNumber(%&f_items_filled%);
                                            #f_items_total      = stringToNumber(%&f_items_total%);
                                            #f_amount_claimable = stringToNumber(%&f_amount_claimable%);
                                            
                                            if((%#f_items_total% == %#items_total%) && (%&f_price_per_unit% == %&price_per_unit%));
                                                
                                            endif;
                                        endif;
                                    endif;
                                else;
                                    break;
                                endif;
                            next;
                            
                            #r_start  = 0;
                            #r_end    = %CONTAINERSLOTS% - 37;
                            for(#f_slot,%#r_start%,%#r_end%);
                                &f_item = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                &f_nbt  = strip(%&f_nbt%);
                                if((%&f_item% != "air") && (%&f_item% != "stained_glass_pane") && (%&f_item% != "arrow"));
                                    &f_name = getItemName(%&f_nbt%,%&f_item%);
                                    ifmatches(%&f_name%,"^(BUY|SELL)",&order_type,1);
                                        match(%&f_nbt%,%&price_per_unit_regex%,&price_per_unit,1,"0");
                                        match(%&f_nbt%,%&items_filled_regex%,&items_filled,1,"0");
                                        match(%&f_nbt%,%&items_total_regex%,&items_total,1,"0");
                                        match(%&f_nbt%,%&amount_claimable%,&amount_claimable,1,"0");
                                        &order_name       = _matchExpressionNBT(%&f_name%,"^%&order_type%: (.+)");
                                        #order_index      = getBazaarIndex(%&order_name%);
                                        &order_sbid       = %@&mkb_baz_sbids[%#order_index%]%;
                                        #items_filled     = stringToNumber(%&items_filled%);
                                        #items_total      = stringToNumber(%&items_total%);
                                        #amount_claimable = stringToNumber(%&amount_claimable%);
                                        &output_array[]   = "%&order_sbid%|%&order_type%|%&price_per_unit%|%#items_filled%|%#items_total%|%#amount_claimable%";
                                    endif;
                                endif;
                            next;
                        else;
                            #recurse_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            in_orders_gui    = bazaarOpenOrders(%allow_command%,%#tick_wait%,%#recurse_timeout%);
                            if(!%in_orders_gui%);
                                debug_error(%debug%,%&script_debug_name%,"Could not enter Orders GUI.");
                                exit_condition_reached = true;
                                break;
                            endif;
                        endif;
                    endif;
                until(%exit_condition_reached%);
            endif;
            
            return(%exit_condition_reached%);
        
        endfunction;
    // bazaar/index_orders/bazaarIndexOrders
        // Indexes all active Bazaar Orders.
            // Params:
                // {boolean} [allow_command=true]    Whether or not we want to allow the usage of the /bz command.
                // {number} [#tick_wait=20]          Amount of Ticks to wait in between Actions (clicks).
                // {number} [#timeout_sec=30]        Amount of Seconds Function can run for before timing out. Set to <= 0 to disable.
            // Returns an Tunnel Joint Array Strings of Elements in Format:
                // 0 {string} &sbid                The Order Item's SBID.
                // 1 {string} &type                Indicates whether the Order is a Buy or Sell Order. String ENUM of BUY, SELL.
                // 2 {string} &price_per_unit      Price per unit of the Order (float, 1 decimal point precision).
                // 3 {number} #items_filled        Amount of Items in this Order that have been matched to a 3rd Party.
                // 4 {number} #items_total         Total Amount of Items in this Order
                // 5 {number} #amount_claimable    Amount of Items or Coins that are claimable in this Order
                // 6 {boolean} expired             Whether or not this Order is expired (older than 1 week, will no longer be matched to 3rd parties).
            // Example:
                //    &bazaar_orders[] = bazaarIndexOrders();
                //    foreach(&bazaar_orders[],&bazaar_order,#boi);
                //        &order_data[]      = split("|",%&bazaar_order%);
                //        &order_sbid        = %&order_data[0]%;
                //        &order_type        = %&order_data[1]%;
                //        &price_per_unit    = %&order_data[2]%;
                //        #items_filled     := %&order_data[3]%;
                //        #items_total      := %&order_data[4]%;
                //        #amount_claimable := %&order_data[5]%;
                //        order_expired     := %&order_data[6]%;
                //    next;
        function bazaarIndexOrders(allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/bazaar/index_orders.txt:127
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bazaarIndexOrders";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
                
                // Expressions to Extract Data from the NBT of a Manage Order Slot Item, depending on whether it is a Buy or Sell Order.
                if(true);
                    &number_regex         = "[0-9,.-]+";
                    &string_regex         = "(.+?)\"";
                    &items_filled_regex   = "Filled: (%&number_regex%)";
                    &items_total_regex    = "(?:Order|Offer) amount: (%&number_regex%)x";
                    &price_per_unit_regex = "Price per unit: (%&number_regex%) coins";
                    &amount_claimable     = "You have (%&number_regex%) (?:coins|items) to claim";
                endif;
            endif;
            
            // Start looping until we get into the Manage Orders GUI, or we encounter an Error that cannot be remedied.
            if(true);
                debug_log(%debug%,%&script_debug_name%,"attempting to index bazaar orders...");
                &order_enums[]  = split(", ","CATEGORY, SUBCATEGORY, PRODUCT, BUY_ORDER_MANAGE, BUY_ORDER_FLIP, SELL_ORDER_MANAGE");
                &order_mcids[]  = split(", ","book, book, book, arrow, NULL, arrow");
                &order_names[]  = split(", ","Manage Orders, Manage Orders, Manage Orders, Go Back, NULL, Go Back");
                &order_action[] = split(", ","CLICK, CLICK, CLICK, CLICK, EXIT, CLICK");
                &target_gui     = "ORDER_MANAGE";
                
                do;
                    // 1. Check if the Function has timed out
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        exit_condition_reached = true;
                        debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                        break;
                    endif;
                    
                    // 2. Check what Bazaar GUI we are in. If we are in a GUI that has access to the Manage Orders Button, progress to it.
                    if(true);
                        &bazaar_gui[] = getBazaarGUIType();
                        &bazaar_enum  = %&bazaar_gui[0]%;
                        &bazaar_path  = %&bazaar_gui[1]%;
                        #enum_index   = indexof(&order_enums[],,%&bazaar_enum%);
                        if(%&bazaar_enum% == %&target_gui%);
                            #r_start  = 0;
                            #r_end    = %CONTAINERSLOTS% - 37;
                            for(#f_slot,%#r_start%,%#r_end%);
                                &f_item = getslotitemnbt(%#f_slot%,,#f_stack,#f_data,&f_nbt);
                                &f_nbt  = strip(%&f_nbt%);
                                if((%&f_item% != "air") && (%&f_item% != "stained_glass_pane") && (%&f_item% != "arrow"));
                                    &f_name = getItemName(%&f_nbt%,%&f_item%);
                                    ifmatches(%&f_name%,"^(BUY|SELL)",&order_type,1);
                                        match(%&f_nbt%,%&price_per_unit_regex%,&price_per_unit,1,"0");
                                        match(%&f_nbt%,%&items_filled_regex%,&items_filled,1,"0");
                                        match(%&f_nbt%,%&items_total_regex%,&items_total,1,"0");
                                        match(%&f_nbt%,%&amount_claimable%,&amount_claimable,1,"0");
                                        &order_name       = _matchExpressionNBT(%&f_name%,"^%&order_type%: (.+)");
                                        #order_index      = getBazaarIndex(%&order_name%);
                                        &order_sbid       = %@&mkb_baz_sbids[%#order_index%]%;
                                        #items_filled     = stringToNumber(%&items_filled%);
                                        #items_total      = stringToNumber(%&items_total%);
                                        #amount_claimable = stringToNumber(%&amount_claimable%);
                                        &output_array[]   = "%&order_sbid%|%&order_type%|%&price_per_unit%|%#items_filled%|%#items_total%|%#amount_claimable%";
                                    endif;
                                endif;
                            next;
                            exit_condition_reached = true;
                        elseif(%#enum_index% != -1);
                            &order_action = %&order_action[%#enum_index%]%;
                            if(%&order_action% == "EXIT");
                                localGUI("NONE");
                            elseif(%&order_action% == "CLICK");
                                &find_mcid  = "MCID: %&order_mcids[%#enum_index%]%";
                                &find_name  = "NAME: %&order_names[%#enum_index%]%";
                                #found_slot = findItemContainer(false,%&find_mcid%,%&find_name%);
                                if(%#found_slot% != -1);
                                    &init_gui     = getContainerString(true);
                                    #waited_ticks = 0;
                                    do;
                                        // 1. Check if the Function has timed out
                                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        if(%func_timeout%);
                                            exit_condition_reached = true;
                                            debug_error(%debug%,%&script_debug_name%,"Function timed out.");
                                            break;
                                        endif;
                                        
                                        // 2. Check if the GUI has Updated
                                        gui_updated = enteredNewGUI(%&init_gui%,true);
                                        if(%gui_updated%);
                                            break;
                                        endif;
                                        
                                        // 3. Click, if we can click.
                                        can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                                        if(%can_click%);
                                            slotclick(%#found_slot%);
                                        endif;
                                        
                                        wait("1t");
                                        inc(#waited_ticks);
                                    until((%gui_updated%) || (%exit_condition_reached%));
                                endif;
                            endif;
                        else;
                            if(%GUI% != "NONE");
                                localGUI("NONE");
                            endif;
                            
                            #recurse_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            bazaar_opened    = openBazaarTo("",%allow_command%,%#tick_wait%,%#recurse_timeout%);
                            if(!%bazaar_opened%);
                                debug_error(%debug%,%&script_debug_name%,"Could not open the Bazaar!");
                                exit_condition_reached = true;
                                break;
                            else;
                                debug_log(%debug%,%&script_debug_name%,"&aSuccessfully entered the Bazaar.");
                            endif;
                        endif;
                    endif;
                until(%exit_condition_reached%);
            endif;
            
            return(&output_array[]);
        endfunction;
    // banking/index/bankingActionInternalChangeGUIGetPath
        // Given a Target GUI Type ENUM, and parallel indexed Arrays of all GUI ENUMs, all GUI ENUMs' Child ENUMs, and
        // all GUI ENUM's Parents, compiles a Unique Array of GUI ENUMs in order to click in the GUI.
            // Params:
                // {string} <&target_enum>       The ENUM to get to. Must be present in the <&gui_enums[]> Array.
                // {string} <&gui_enums[]>       Array of GUI ENUM Strings.
                // {string} <&gui_parents[]>     Array of GUI ENUM Strings indexed parallel to <&gui_enums[]>. To indicate
                //                               that a GUI ENUM is the Root Note, make the Parent at that Index an empty string.
                // {string} <&gui_children[]>    Array of Tunnel Joint Array Strings that are GUI ENUMs in the <&gui_enums[]> Array,
                //                               each Entry in this Array will be taken as being a Child of the Element at the same
                //                               index in <&gui_enums[]>. To indicate that a GUI has no Children, use an empty string.
        function bankingActionInternalChangeGUIGetPath(&target_enum,&gui_enums[],&gui_parents[],&gui_children[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:922
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bankingChangeGUIGetPath&7";
            endif;
            
            #target_index = indexof(&gui_enums[],,%&target_enum%);
            if(%#target_index% == -1);
                &return_array[] = "";
                &gui_enums      = join(", ",&gui_enums[]);
                debug_error(%debug%,%&script_debug_name%,"Target Enum (&&target_enum: %&target_enum%) is not present in the GUI ENUMs (&&gui_enums: [%&gui_enums%]) Array!");
                return(&return_array[]);
            endif;
            
            // Compile list of all GUI ENUMs that are a Parent of the Target ENUM, or a Parent of a Parent of the Target ENUM, and so on.
            if(%&gui_parents[%#target_index%]% != "");
                &parent_enums[] = %&gui_parents[%#target_index%]%;
                #parent_enums[] = 0;
                do;
                    #before_length   = arraysize(&parent_enums[]);
                    #final_index     = %#before_length% - 1;
                    &final_parent    = %&parent_enums[%#final_index%]%;
                    #gui_enums_index = indexof(&gui_enums[],,%&final_parent%);
                    if(%&gui_parents[%#gui_enums_index%]% != "");
                        &parent_enums[] = %&gui_parents[%#gui_enums_index%]%;
                        #parent_enums[] = %#parent_enums[%#final_index%]% + 1;
                    else;
                        break;
                    endif;
                    #after_length = arraysize(&parent_enums[]);
                until(%#before_length% == %#after_length%);
                sort("DSC",#parent_enums[],&parent_enums[]);
            endif;
            
            return(&parent_enums[]);
        endfunction;
    // banking/index/bankingActionInternalOpenBank
        // Opens the Banking GUI up by first trying to check if the User has access to (and is off cooldown of)
        // the Personal Bank Item, and if so, uses it. If not, and/or the User does not have access to the Item,
        // goes to the Banker NPC in person and opens the GUI up.
            // Params:
                // {number}  [#timeout_sec=30]       The maximum amount of Seconds that this Function can run for. If set to <= 0,
                //                                   Function will run on a loop until it is successful, without ever timing out.
                // {number}  [#tick_wait=20]         The amount of Ticks to wait between looping repeated actions.
                // {boolean} [personal_bank=true]    Whether or not to try to use the Personal Bank Item.
            // Returns a Boolean indicating whether or not we were able to open the Bank GUI up.
            // Examples:
                // in_bank = bankingActionInternalOpenBank(%#timeout_sec%,%#tick_wait%,%personal_bank%);
        function bankingActionInternalOpenBank(#timeout_sec=30,#tick_wait=20,personal_bank=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:828
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bankingOpenBank";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
        
                // Setup where we expect to find the Item, and what the Item is
                if(true);
                    #f_slot = 33;
                    &f_item = "skull";
                    #f_data = 3;
                    &f_name = "Personal Bank";
                endif;
            endif;
        
            // Start looping until we know whether or not we have access to the Personal Bank Item.
            if(true);
                return_boolean      = false;
                &expected_container = "^(?:Bank|Personal Bank Account)$";
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function Timed out");
                            break;
                        endif;
                    endif;
        
                    // 2. Open up the SBMENU GUI.
                    if((%personal_bank%) && (!%personal_unavailable%));
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        sbmenu_gui         = remoteGUI("SB_MENU",%#tick_wait%,%#recursive_timeout%);
                        if(!%sbmenu_gui%);
                            debug_error(%debug%,%&script_debug_name%,"Could not enter the SBMENU GUI!");
                            break;
                        endif;
        
                        // 2a. Check if we can find the Piggy Bank Item.
                        if(true);
                            #bank_slot = findItemContainer(false,"SLOT: %#f_slot%","MCID: %&f_item%","DATA: %#f_data%","NAME: %&f_name%");
                            if(%#bank_slot% != -1);
                                &bank_item = getslotitemnbt(%#bank_slot%,,#bank_stack,#bank_data,&bank_nbt);
                                &bank_nbt  = strip(%&bank_nbt%);
                                ifmatches(%&bank_nbt%,"(?:Available|No Cooldown)");
                                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                    debug_log(%debug%,%&script_debug_name%,"calling containerClick(%#bank_slot%,%#recursive_timeout%,%#tick_wait%,false,false,false)");
                                    entered_new_gui    = containerClick(%#bank_slot%,%#recursive_timeout%,%#tick_wait%,false,false,false);
                                    debug_log(%debug%,%&script_debug_name%,"got return value %entered_new_gui% from containerClick(%#bank_slot%,%#recursive_timeout%,%#tick_wait%,false,false,false);");
                                    if(%entered_new_gui%);
                                        ifmatches(%CONTAINERNAME%,%&expected_container%);
                                            debug_log(%debug%,%&script_debug_name%,"used bank item successfully");
                                            return_boolean = true;
                                            break;
                                        endif;
                                    endif;
                                else;
                                    personal_unavailable = true
                                endif;
                            else;
                                personal_unavailable = true;
                            endif;
                        endif;
                    endif;
        
                    // 3. SBMENU -> Personal Bank didn't work, so let's try going to the Banker in Person instead.
                    if(true);
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        return_boolean     = goto("BANKER",true,%#recursive_timeout%);
                        if(%return_boolean%);
                            break;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"GOTO failed to get us into the Banker GUI?");
                        endif;
                    endif;
                until(%return_boolean%);
            endif;
        
            debug_log(%debug%,%&script_debug_name%,"outcome of attempt to open bank was: '%return_boolean%' (returning this to caller)");
            return(%return_boolean%);
        endfunction;
    // banking/index/bankingInfoInternalGetGuiType
        // Gets the String ENUM of Banking GUI Type that is currently open.
            // Returns a String ENUM:
                //    UPGRADES         The GUI for upgrading the Bank's Limits
                //    CHOICE           The First Menu GUI for a Coop Profile (can click to choose Coop or Solo Account from here). Solo
                //                     Profiles will be put into the SOLO GUI Type instead of this GUI for their Main Menu.
                //    COOP             The GUI for depositing or withdrawing into a Coop Account
                //    SOLO             The GUI for depositing or withdrawing into a Solo Account
                //    COOP_DEPOSIT     The GUI for depositing into a Coop Account
                //    SOLO_DEPOSIT     The GUI for depositing into a Solo Account
                //    SIGN_DEPOSIT     The GUI for depositing a Custom Amount into an Account (Type would not be known since cannot get GUI Items)
                //    COOP_WITHDRAW    The GUI for withdrawing from a Coop Account
                //    SOLO_WITHDRAW    The GUI for withdrawing from a Solo Account
                //    SIGN_WITHDRAW    The GUI for withdrawing a Custom Amount from an Account (Type would not be known since cannot get GUI Items)
                //    NONE             A Banking GUI is not open.
            // Example:
                //    &bank_gui_type = bankingInfoInternalGetGuiType();
                //    if(%&bank_gui_type% == "NONE");
                //    elseif(%&bank_gui_type% == "UPGRADES");
                //    elseif(%&bank_gui_type% == "CHOICE");
                //    elseif(%&bank_gui_type% == "COOP");
                //    elseif(%&bank_gui_type% == "SOLO");
                //    elseif(%&bank_gui_type% == "COOP_DEPOSIT");
                //    elseif(%&bank_gui_type% == "SOLO_DEPOSIT");
                //    elseif(%&bank_gui_type% == "SIGN_DEPOSIT");
                //    elseif(%&bank_gui_type% == "COOP_WITHDRAW");
                //    elseif(%&bank_gui_type% == "SOLO_WITHDRAW");
                //    elseif(%&bank_gui_type% == "SIGN_WITHDRAW");
                //    endif;
        function bankingInfoInternalGetGuiType();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:158
            // Setup Function Variables
            if(true);
                debug               = true;
                &script_debug_name  = "&6bankingGetGuiType";
                &enum_upgrades      = "UPGRADES";
                &enum_choice        = "CHOICE";
                &enum_coop          = "COOP";
                &enum_solo          = "SOLO";
                &enum_coop_deposit  = "COOP_DEPOSIT";
                &enum_solo_deposit  = "SOLO_DEPOSIT";
                &enum_sign_deposit  = "SIGN_DEPOSIT";
                &enum_coop_withdraw = "COOP_WITHDRAW";
                &enum_solo_withdraw = "SOLO_WITHDRAW";
                &enum_sign_withdraw = "SIGN_WITHDRAW";
                &enum_none          = "NONE";
                &return_string      = %&enum_none%;
        
                // Setup CONTAINERNAME to ENUM Maps
                if(true);
                    &enum_map_enums[]      = %&enum_choice%;
                    &enum_map_containers[] = "Bank";
        
                    &enum_map_enums[]      = %&enum_upgrades%;
                    &enum_map_containers[] = "Bank Account Upgrades";
        
                    &enum_map_enums[]      = %&enum_coop%;
                    &enum_map_containers[] = "Co-op Bank Account";
        
                    &enum_map_enums[]      = %&enum_solo%;
                    &enum_map_containers[] = "Personal Bank Account";
        
                    // Find Type ('COOP' or 'SOLO') Containers
                    &typed_containers[] = split(", ","Bank Deposit, Bank Withdrawal");
                    &typed_suffixes[]   = split(", ","DEPOSIT, WITHDRAW");
                endif;
            endif;
        
            &check_gui       = %GUI%;
            &check_container = %CONTAINERNAME%;
        
            // If we are in a valid GUI, find the GUI ENUM for the Container.
            if((%&check_gui% == "GUICHEST") || (%&check_gui% == "GUIEDITSIGN"));
                #enum_map_index = indexof(&enum_map_containers[],,%&check_container%);
                #typed_index    = indexof(&typed_containers[],,%&check_container%);
                if(%#enum_map_index% != -1);
                    &return_string = %&enum_map_enums[%#enum_map_index%]%;
                elseif(%#typed_index% != -1);
                    &return_suffix = %&typed_suffixes[%#typed_index%]%;
                    &return_prefix = "SIGN";
                    if(%&check_gui% == "GUICHEST");
                        // Find the Type of the Container by finding the 'Go Back' Button and grabbing the 'To (Co-op|Personal) Bank Account'
                        // String from the NBT.
                        #go_back_slot = findItemContainer(false,"MCID: arrow","NAME: Go Back","SLOT: 31","NBT: r$To (Co-op|Personal) Bank Account");
                        if(%#go_back_slot% != -1);
                            &go_back_item = getslotitemnbt(%#go_back_slot%,,#go_back_stack,#go_back_data,&go_back_nbt);
                            &go_back_nbt  = strip(%&go_back_nbt%);
                            ifmatches(%&go_back_nbt%,"To (Co-op|Personal) Bank Account",&capture_group,1);
                                &return_prefix = "COOP";
                                &capture_group = lcase(%&capture_group%);
                                if(%&capture_group% == "personal");
                                    &return_prefix = "SOLO";
                                endif;
                            endif;
                        endif;
                    endif;
                    &return_string = "%&return_prefix%_%&return_suffix%";
                endif;
            endif;
        
            debug_log(%debug%,%&script_debug_name%,"Returning Banking GUI Type: '&d%&return_string%&7' from GUI '&d%&check_gui%&7', CONTAINERNAME '&d%&check_container%&7'.");
            return(%&return_string%);
        endfunction;
    // api/slothpixel/slothpixelGetSkyBlockProfiles
        // Gets a player's Hypixel SkyBlock Profiles from Slothpixel's API.
            // Params:
            //        {string} [&search_term=%UUID%]    The player username/UUID to search for. If left blank, defaults to player's UUID.
            //
            // Returns an array:
            //    0         {boolean}    success       Whether or not we were able to get any data from the API (false if request fails)
            //    1, ...    {string}     &profile[]    The JSON Objects of the Profiles. Only provided if success == true and profiles !== null.
        function slothpixelGetSkyBlockProfiles(&search_term=%UUID%);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/api/slothpixel.txt:8
            &player_data[]   = getMinecraftProfile(%&search_term%);
            player_success  := %&player_data[0]%;
            &return_array[0] = "False";
            if(%player_success%);
                &player_joint_uuid = %&player_data[2]%;
                &api_endpoint      = "https://api.slothpixel.me/api/skyblock/profiles/%&player_joint_uuid%";
                &api_response      = httpget(%&api_endpoint%,,#api_code);
                if(%#api_code% == 200);
                    &return_array[0] = "True";
                    &profile_ids[]   = getjsonkeys(%&api_response%);
                    foreach(&profile_ids[],&profile_id,#pii);
                        &return_array[] = jsonget(%&profile_id%,%&api_response%);
                    next;
                endif;
            endif;
            return(&return_array[]);
        endfunction;
    // info/index/getProfileType
        // Determines whether the current SkyBlock Profile is a Solo or a Coop type Profile.
            // Params: None
            // Returns: {string} ENUM: COOP, SOLO, ERROR
        function getProfileType();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:667
            // Check if we can answer our question by checking the Scoreboard.
            if(true);
                &bank_balances = getSkyBlockPlayerListInfo("BANK");
                if(%&bank_balances% != "-1");
                    &split_array[] = split("/",%&bank_balances%);
                    #split_array   = arraysize(&split_array[]);
                    if(%#split_array% == 1);
                        return("SOLO");
                    elseif(%#split_array% == 2);
                        return("COOP");
                    endif;
                endif;
            endif;
            
            // If we could not answer our question by checking the Scoreboard, try API.
            if(true);
                &active_profile_req[]   = getActiveProfile();
                active_profile_success := %&active_profile_req[0]%;
                if(%active_profile_success%);
                    &profile_members         = jsonget("members",%&active_profile_req[1]%);
                    &profile_members_uuids[] = getjsonkeys(%&profile_members%);
                    #profile_members_uuids   = arraysize(&profile_members_uuids[]);
                    if(%#profile_members_uuids% == 1);
                        return("SOLO");
                    elseif(%#profile_members_uuids% > 1);
                        return("COOP");
                    endif;
                endif;
            endif;
            
            // If we are still bass-ackwards and out of luck, what the fuck else can we do? Try Slothpixel!
            if(true);
                // Try to get the Active Profile ID first.
                if(true);
                    &active_profile_id[]    = getActiveProfileID();
                    active_profile_success := %&active_profile_id[0]%;
                endif;
                
                &player_joint_uuid     = %UUID%;
                &player_joint_uuid     = regexreplace(&player_joint_uuid,"-","");
                &slothpixel_profiles[] = slothpixelGetSkyBlockProfiles();
                slothpixel_success    := %&slothpixel_profiles[0]%;
                if(%slothpixel_success%);
                    #slothpixel_profiles = arraylength(&slothpixel_profiles[]);
                    for(#i,1,%#slothpixel_profiles%);
                        &slothpixel_profile = %&slothpixel_profiles[%#i%]%;
                        &profile_id         = jsonget("id",%&slothpixel_profile%);
                        if((%active_profile_success%) && (%&profile_id% == %&active_profile_id[1]%));
                            &active_profile = %&slothpixel_profile%;
                            break;
                        elseif(!%active_profile_success%);
                            &profile_last_save = jsonget("members.%&player_joint_uuid%.last_save",%&slothpixel_profile%);
                            if(%&best_save% == "");
                                &best_save      = %&profile_last_save%;
                                &active_profile = %&slothpixel_profile%;
                            else;
                                &save_diff = eval("%&profile_last_save% - %&best_save%"); // if profile_last_save bigger (more recent), number will not be negative
                                ifnotmatches(%&save_diff%,"-");
                                    &best_save      = %&profile_last_save%;
                                    &active_profile = %&slothpixel_profile%;
                                endif;
                            endif;
                        endif;
                    next;
                    
                    if(%&active_profile% != "");
                        &profile_members   = jsonget("members",%&active_profile%);
                        &profile_members[] = getjsonkeys(%&profile_members%);
                        #profile_members   = arraysize(&profile_members[]);
                        if(%#profile_members% == 1);
                            return("SOLO");
                        elseif(%#profile_members% >= 2);
                            return("COOP");
                        endif;
                    endif;
                endif;
            endif;
            
            return("ERROR");
        endfunction;
    // banking/index/bankingInfoInternalGetProfileType
        // Checks what the Profile's Type is based on what GUI we are in and what Items are present.
            // Params:
                // {string} [&bank_enum=""]       Optional String ENUM returned from the `bankingInfoInternalGetGuiType()` Function.
                //                                If not provided (or invalid), will call `bankingInfoInternalGetGuiType()`.
                // {number}  [#timeout_sec=30]    The maximum amount of Seconds that this Function can run for. If set to <= 0,
                //                                Function will run on a loop until it is successful, without ever timing out.
            // Returns a String ENUM of COOP, SOLO, or NONE.
            // Example:
                //    &profile_type = bankingInfoInternalGetProfileType(%&bank_enum%);
                //    if(%&profile_type% == "NONE");
                //    elseif(%&profile_type% == "COOP");
                //    elseif(%&profile_type% == "SOLO");
                //    endif;
        function bankingInfoInternalGetProfileType(&bank_enum="",#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:245
            // Setup Function Variables
            if(true);
                debug                = true;
                &script_debug_name   = "&6bankingInfoGetProfileType";
                &return_string       = "NONE";
                do_timeout           = %#timeout_sec% > 0;
                #start_time          = %TIMESTAMP%;
        
                // Wrap ENUM Arrays
                if(true);
                    // All valid ENUMs
                    &valid_gui_enums[] = split(", ","UPGRADES, CHOICE, COOP, SOLO, COOP_DEPOSIT, SOLO_DEPOSIT, SIGN_DEPOSIT, COOP_WITHDRAW, SOLO_WITHDRAW, SIGN_WITHDRAW, NONE");
        
                    // ENUMs where we can skip all Bank-related Profile Checks and return 'COOP'.
                    &coop_gui_enums[] = split(", ","CHOICE, COOP, COOP_DEPOSIT, COOP_WITHDRAW");
        
                    // ENUMs to skip all Bank-related Profile Checks and go to `getProfileType()`
                    &invalid_gui_enums[] = split(", ","SIGN_DEPOSIT, SIGN_WITHDRAW, NONE, SOLO_DEPOSIT, SOLO_WITHDRAW");
        
                    // ENUMs to check for 'Go Back' Arrow NBT presence and/or Destination
                    &check_gui_enums[] = split(", ","UPGRADES, SOLO");
                endif;
        
                #gui_enum_index = indexof(&valid_gui_enums[],,%&bank_enum%);
                &return_string  = "NONE";
                if(%#gui_enum_index% == -1);
                    &bank_enum = bankingInfoInternalGetGuiType();
                endif;
        
                #invalid_gui_index = indexof(&invalid_gui_enums[],,%&bank_enum%);
                #check_gui_index   = indexof(&check_gui_enums[],,%&bank_enum%);
                #coop_gui_index    = indexof(&coop_gui_enums[],,%&bank_enum%);
            endif;
        
            // Do Bank-Specific Profile Checks (to avoid having to possibly hit API, if we can).
            if(%#invalid_gui_index% == -1);
                if(%#coop_gui_index% != -1);
                    &return_string = "COOP";
                elseif(%#check_gui_index% != -1);
                    // Get the 'Go Back' Arrow Slot and check it's NBT. If we do not find the Go Back Arrow,
                    // or it's NBT states 'Personal Bank Account', we are in a Solo Profile. If we do find it,
                    // and it's NBT states 'Bank', we are in a Coop Profile.
                    &return_string = "SOLO";
                    #go_back_slot  = findItemContainer(false,"MCID: arrow","NAME: Go Back");
                    if(%#go_back_slot% != -1);
                        &go_back_item = getslotitemnbt(%#go_back_slot%,,#go_back_stack,#go_back_data,&go_back_nbt);
                        &go_back_nbt  = strip(%&go_back_nbt%);
                        ifmatches(%&go_back_nbt%,"To Bank");
                            &return_string = "COOP";
                        endif;
                    endif;
                endif;
            endif;
        
            // If we failed to match any of the conditions above, fall back on a `getProfileType()` call.
            if(%&return_string% == "NONE");
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Timed out!");
                            break;
                        endif;
                    endif;
        
                    // 2. Try to grab the Profile Type from API/Tab List
                    if(true);
                        &profile_type = getProfileType();
                        if((%&profile_type% == "COOP") || (%&profile_type% == "SOLO"));
                            &return_string = %&profile_type%;
                            break;
                        endif;
                    endif;
                until(%&return_string% != "NONE");
            endif;
        
            debug_log(%debug%,%&script_debug_name%,"Returning Profile Type '&d%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
    // banking/index/bankingGUI
        // Opens the Banking GUI up to the specified GUI ENUM/Type.
            // Params:
                // {string}  [&target_enum=""]       String ENUM of GUI Type to open up to. Valid strings are dependent on what type of
                //                                   Profile is in use. If omitted, will default to 'CHOICE' for COOP Profiles, or 'SOLO' for Solos.
                //                                   SOLO Profiles can use:
                //                                       UPGRADES, SOLO, SOLO_WITHDRAW, SOLO_WITHDRAW_SIGN, SOLO_DEPOSIT, SOLO_DEPOSIT_SIGN
                //                                   COOP Profiles can use all of the SOLO Profile ENUMs, as well as:
                //                                       CHOICE, COOP, COOP_WITHDRAW, COOP_WITHDRAW_SIGN, COOP_DEPOSIT, COOP_DEPOSIT_SIGN
                //                                   If omitted, will default to 'CHOICE' if in a COOP Profile, or 'SOLO' in a SOLO Profile.
                // {string}  [&profile_type=""]      The Profile Type of the Profile, if known. String ENUM of COOP, SOLO. Will fetch
                //                                   via `bankingInfoInternalGetProfileType()` if omitted.
                // {number}  [#timeout_sec=30]       The maximum amount of Seconds that this Function can run for. If set to <= 0,
                //                                   Function will run on a loop until it is successful, without ever timing out.
                // {number}  [#tick_wait=20]         The amount of Ticks to wait between looping repeated actions.
                // {boolean} [personal_bank=true]    Whether or not to try to use the Personal Bank Item.
            // Returns a Boolean indicating whether or not we were able to open the Bank GUI up.
            // Examples:
                //    in_coop_deposit_gui = bankingGUI("COOP_DEPOSIT");
                //    in_solo_deposit_gui = bankingGUI("SOLO_DEPOSIT");
        function bankingGUI(&target_enum="",&profile_type="",#timeout_sec=30,#tick_wait=20,personal_bank=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:979
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bankingGUI&7";
                #start_time        = %TIMESTAMP%;
                do_timeout         = %#timeout_sec% > 0;
                &profile_type      = miscValidate(%&profile_type%,-1,"COOP","SOLO");
                return_boolean     = false;
        
                if(%&profile_type% == "");
                    &profile_type  = bankingInfoInternalGetProfileType(%&bank_enum%,%#timeout_sec%);
                    if(%&profile_type% == "NONE");
                        debug_error(%debug%,%&script_debug_name%,"Could not derive Profile Type (&&bank_enum: '&4%&bank_enum%&c', &&profile_type: '&4%&profile_type%&c'). Returning &4FALSE&c.");
                        return(%return_boolean%);
                    endif;
                endif;
                
                // Wrap GUI ENUMs and Items
                if(true);
                    if(%&profile_type% == "COOP");
                        &gui_enums[]    = "CHOICE";
                        &gui_mcids[]    = "";
                        &gui_names[]    = "";
                        &gui_parents[]  = "";
                        &gui_children[] = "COOP|SOLO|UPGRADES";
                        &gui_slots[]    = "";
                        
                        &gui_enums[]    = "UPGRADES";
                        &gui_mcids[]    = "gold_block";
                        &gui_names[]    = "Bank Upgrades";
                        &gui_parents[]  = "CHOICE";
                        &gui_children[] = "";
                        &gui_slots[]    = "35";
        
                        &gui_enums[]    = "COOP";
                        &gui_mcids[]    = "ender_chest";
                        &gui_names[]    = "Co-op Bank account";
                        &gui_parents[]  = "CHOICE";
                        &gui_children[] = "COOP_WITHDRAW|COOP_DEPOSIT";
                        &gui_slots[]    = "11";
        
                        &gui_enums[]    = "COOP_WITHDRAW";
                        &gui_mcids[]    = "dropper";
                        &gui_names[]    = "Withdraw Coins";
                        &gui_parents[]  = "COOP";
                        &gui_children[] = "COOP_WITHDRAW_SIGN";
                        &gui_slots[]    = "13";
        
                        &gui_enums[]    = "COOP_WITHDRAW_SIGN";
                        &gui_mcids[]    = "sign";
                        &gui_names[]    = "Specific amount";
                        &gui_parents[]  = "COOP_WITHDRAW";
                        &gui_children[] = "";
                        &gui_slots[]    = "16";
        
                        &gui_enums[]    = "COOP_DEPOSIT";
                        &gui_mcids[]    = "chest";
                        &gui_names[]    = "Deposit Coins";
                        &gui_parents[]  = "COOP";
                        &gui_children[] = "COOP_DEPOSIT_SIGN";
                        &gui_slots[]    = "11";
        
                        &gui_enums[]    = "COOP_DEPOSIT_SIGN";
                        &gui_mcids[]    = "sign";
                        &gui_names[]    = "Specific amount";
                        &gui_parents[]  = "COOP_DEPOSIT";
                        &gui_children[] = "";
                        &gui_slots[]    = "15";
        
                        &gui_enums[]    = "SOLO";
                        &gui_mcids[]    = "chest";
                        &gui_names[]    = "Personal Bank Account";
                        &gui_parents[]  = "CHOICE";
                        &gui_children[] = "SOLO_WITHDRAW|SOLO_DEPOSIT";
                        &gui_slots[]    = "15";
        
                        &gui_enums[]    = "SOLO_WITHDRAW";
                        &gui_mcids[]    = "dropper";
                        &gui_names[]    = "Withdraw Coins";
                        &gui_parents[]  = "SOLO";
                        &gui_children[] = "SOLO_WITHDRAW_SIGN";
                        &gui_slots[]    = "13";
        
                        &gui_enums[]    = "SOLO_WITHDRAW_SIGN";
                        &gui_mcids[]    = "sign";
                        &gui_names[]    = "Specific amount";
                        &gui_parents[]  = "SOLO_WITHDRAW";
                        &gui_children[] = "";
                        &gui_slots[]    = "16";
        
                        &gui_enums[]    = "SOLO_DEPOSIT";
                        &gui_mcids[]    = "chest";
                        &gui_names[]    = "Deposit Coins";
                        &gui_parents[]  = "SOLO";
                        &gui_children[] = "SOLO_DEPOSIT_SIGN";
                        &gui_slots[]    = "11";
        
                        &gui_enums[]    = "SOLO_DEPOSIT_SIGN";
                        &gui_mcids[]    = "sign";
                        &gui_names[]    = "Specific amount";
                        &gui_parents[]  = "SOLO_DEPOSIT";
                        &gui_children[] = "";
                        &gui_slots[]    = "15";
                    elseif(%&profile_type% == "SOLO");
                        &gui_enums[]    = "SOLO";
                        &gui_mcids[]    = "";
                        &gui_names[]    = "";
                        &gui_parents[]  = "";
                        &gui_children[] = "SOLO_WITHDRAW|SOLO_DEPOSIT";
                        &gui_slots[]    = "";
                        
                        &gui_enums[]    = "UPGRADES";
                        &gui_mcids[]    = "gold_block";
                        &gui_names[]    = "Bank Upgrades";
                        &gui_parents[]  = "SOLO";
                        &gui_children[] = "";
                        &gui_slots[]    = "35";
        
                        &gui_enums[]    = "SOLO_WITHDRAW";
                        &gui_mcids[]    = "dropper";
                        &gui_names[]    = "Withdraw Coins";
                        &gui_parents[]  = "SOLO";
                        &gui_children[] = "SOLO_WITHDRAW_SIGN";
                        &gui_slots[]    = "13";
        
                        &gui_enums[]    = "SOLO_WITHDRAW_SIGN";
                        &gui_mcids[]    = "sign";
                        &gui_names[]    = "Specific amount";
                        &gui_parents[]  = "SOLO_WITHDRAW";
                        &gui_children[] = "";
                        &gui_slots[]    = "16";
        
                        &gui_enums[]    = "SOLO_DEPOSIT";
                        &gui_mcids[]    = "chest";
                        &gui_names[]    = "Deposit Coins";
                        &gui_parents[]  = "SOLO";
                        &gui_children[] = "SOLO_DEPOSIT_SIGN";
                        &gui_slots[]    = "11";
        
                        &gui_enums[]    = "SOLO_DEPOSIT_SIGN";
                        &gui_mcids[]    = "sign";
                        &gui_names[]    = "Specific amount";
                        &gui_parents[]  = "SOLO_DEPOSIT";
                        &gui_children[] = "";
                        &gui_slots[]    = "15";
                    endif;
                endif;
                
                // Correct the Target ENUM and/or Validate It
                if(true);
                    &real_enum = miscValidate(%&target_enum%,-1,...&gui_enums[]);
                    if(%&real_enum% == "");
                        if(%&profile_type% == "COOP");
                            &real_enum = "CHOICE";
                        elseif(%&profile_type% == "SOLO");
                            &real_enum = "SOLO";
                        endif;
                        debug_log(%debug%,%&script_debug_name%,"Defaulting &&target_enum to '&d%&real_enum%&7' because &&target_enum (&d'%&target_enum%&7') was Invalid (at least, for profile type '&d%&profile_type%&7').");
                    endif;
                    #target_index = indexof(&gui_enums[],,%&real_enum%);
                endif;
                
                &parent_enums[]           = bankingActionInternalChangeGUIGetPath(%&real_enum%,&gui_enums[],&gui_parents[],&gui_children[]);
                &go_back_params[]         = split(", ","MCID: arrow, NAME: Go Back");
                &convert_sign_enums[]     = split(", ","SOLO_WITHDRAW_SIGN, SOLO_DEPOSIT_SIGN, COOP_WITHDRAW_SIGN, COOP_DEPOSIT_SIGN")
                #convert_sign_enums_index = indexof(&convert_sign_enums[],,%&real_enum%);
                convert_sign_enums        = %#convert_sign_enums_index% != -1;
                if(%convert_sign_enums%);
                    &convert_sign_origins[]             = split(", ","SIGN_DEPOSIT, SIGN_WITHDRAW");
                    &convert_sign_origin_predecessors[] = split(", ","COOP_DEPOSIT, COOP_WITHDRAW, SOLO_DEPOSIT, SOLO_WITHDRAW");
                    &convert_sign_origin_conversions[]  = split(", ","COOP_DEPOSIT_SIGN, COOP_WITHDRAW_SIGN, SOLO_DEPOSIT_SIGN, SOLO_WITHDRAW_SIGN");
                endif;
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Beginning attempt to get to &&real_enum='&e%&real_enum%&7'.");
            do;
                //    1.    Check for Function Timeout
                if(%do_timeout%);
                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                    if(%func_timeout%);
                        debug_error(%debug%,%&script_debug_name%,"Timed Out!");
                        break;
                    endif;
                endif;
        
                //    2.    Figure out what Action to Execute based on what GUI we are in.
                if(true);
                    &bank_enum  = bankingInfoInternalGetGuiType();
                    #bank_index = indexof(&gui_enums[],,%&bank_enum%);
                    
                    // Convert 'SIGN_DEPOSIT' and/or 'SIGN_WITHDRAW' to '<SOLO|COOP>_DEPOSIT_SIGN' and '<SOLO|COOP>_WITHDRAW_SIGN'
                    if((%GUI% == "GUIEDITSIGN") && (%convert_sign_enums%));
                        #convert_sign_origins_index = indexof(&convert_sign_origins[],,%&bank_enum%);
                        if(%#convert_sign_origins_index% != -1);
                            #previous_index = indexof(&convert_sign_origin_predecessors[],,%&last_bank_enum%);
                            if(%#previous_index% != -1);
                                &bank_enum  = %&convert_sign_origin_conversions[%#previous_index%]%;
                                #bank_index = indexof(&gui_enums[],,%&bank_enum%);
                            endif;
                        endif;
                    endif;
                    
                    debug_log(%debug%,%&script_debug_name%,"Target/real enum &&real_enum='&e%&real_enum%&7', &&bank_enum='&e%&bank_enum%&7', #bank_index=&e%#bank_index%&7.");
        
                    if(%&bank_enum% == %&real_enum%);
                        debug_log(%debug%,%&script_debug_name%,"Successfully entered Bank ENUM: '&d%&bank_enum%&7'.");
                        return_boolean = true;
                        break;
                    elseif((%GUI% != "GUICHEST") || (%&bank_enum% == "NONE"));
                        debug_log(%debug%,%&script_debug_name%,"In an invalid GUI (GUI='&e%GUI%&7', &&bank_enum='&e%&bank_enum%&7'), exiting...");
                        localGUI("NONE");
                        
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        in_bank            = bankingActionInternalOpenBank(%#recursive_timeout%,%#tick_wait%,%personal_bank%);
                        if(!%in_bank%);
                            debug_error(%debug%,%&script_debug_name%,"Failed to open the Banking GUI, breaking.");
                            break;
                        endif;
                    elseif(%#bank_index% != -1);
                        unset(&action_array[]);
                        &action_type = "CLOSE";
                        if(%#bank_index% > %#target_index%);
                            // We are too deep, we need to go back up a level.
                            &action_type = "CLICK";
                            push(&action_array[],&go_back_params[*]);
                        else;
                            // If the GUI we are currently in is a Parent or Grandparent of the Target GUI, find the Child ENUM
                            // of this GUI that gets us closer to the Target. If it is not a Parent or Grandparent, then exit the GUI
                            // instead of finding an Item to click.
                            #parent_index = indexof(&parent_enums[],,%&bank_enum%);
                            if(%#parent_index% != -1);
                                &child_enum      = "";
                                &curr_children[] = split("|",%&gui_children[%#bank_index%]%);
                                foreach(&curr_children[],&curr_child,#cc);
                                    if(%&curr_child% == %&real_enum%);
                                        &child_enum = %&curr_child%;
                                        break;
                                    else;
                                        #parent_index = indexof(&parent_enums[],,%&curr_child%);
                                        if(%#parent_index% != -1);
                                            &child_enum = %&curr_child%;
                                            break;
                                        endif;
                                    endif;
                                next;
                                
                                #gui_enums_index = indexof(&gui_enums[],,%&child_enum%);
                                if(%#gui_enums_index% != -1);
                                    &action_array[] = split(", ","MCID: %&gui_mcids[%#gui_enums_index%]%, NAME: %&gui_names[%#gui_enums_index%]%, SLOT: %&gui_slots[%#gui_enums_index%]%");
                                    &action_type    = "CLICK";
                                endif;
                            endif;
                        endif;
                        
                        debug_log(%debug%,%&script_debug_name%,"&&action_type: '&d%&action_type%&7', &&action_data: '&e%&action_data%&7'.");
                        if(%&action_type% == "CLOSE");
                            debug_log(%debug%,%&script_debug_name%,"Closing GUI (GUI: '&d%GUI%&7', CONTAINERNAME: '&d%CONTAINERNAME%&7', CONTAINERSLOTS: '&d%CONTAINERSLOTS%&7', ENUM: '&d%&bank_enum%&7').");
                            localGUI("NONE");
                        elseif(%&action_type% == "CLICK");
                            #action_slot   = findItemContainer(false,...&action_array[]);
                            &action_params = join("&7', '&d",&action_array[]);
                            debug_log(%debug%,%&script_debug_name%,"Search for Item with Parameters: ['&d%&action_params%&7'] returned Slot '&e%#action_slot%&7'.");
                            if(%#action_slot% != -1);
                                debug_log(%debug%,%&script_debug_name%,"Found Next Item at Slot &d%#action_slot%&7.");
                                #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                updated_gui        = containerClick(%#action_slot%,%#recursive_timeout%,%#tick_wait%,true,false,false);
                                if(%updated_gui%);
                                    debug_log(%debug%,%&script_debug_name%,"Updated GUI!");
                                endif;
                            else;
                                &action_params = join("&c', '&4",&action_array[]);
                                debug_error(%debug%,%&script_debug_name%,"Failed to find Item with Parameters: ['&4%&action_params%&c']!");
                            endif;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Action Type (&&action_type: '&4%&action_type%&c') is Unknown?");
                        endif;
                    else;
                        debug_error(%debug%,%&script_debug_name%,"GUI ENUM Index for '&d%&bank_enum%&7' is -1! Cannot recover :^(");
                        break;
                    endif;
                    
                    &last_bank_enum = %&bank_enum%;
                endif;
                
                wait("1t");
            until(%return_boolean%);
            
            debug_log(%debug%,%&script_debug_name%,"GUI change outcome (return_boolean='&e%return_boolean%&7') from &&real_enum='&e%&real_enum%&7', &&profile_type='&e%&profile_type%&7'.");
            return(%return_boolean%);
        endfunction;
    // math/index/_gte
        // Wrapper that converts A and B to Numbers, then checks for A being >= B.
            // Params:
                // {string} <&a>    First Number to Parse and Compare.
                // {string} <&b>    Second Number to Parse and Compare.
            // Returns a Boolean
            // Example:
                //    greater_than_or_equal_to = gt("1M","1000000");
        function _gte(&a,&b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:598
            &a_converted = number(%&a%,"F:FLOAT","P:SIGNIFICANT");
            &b_converted = number(%&b%,"F:FLOAT","P:SIGNIFICANT");
            &diff        = eval("%&a_converted% - %&b_converted%");
            ifnotmatches(%&diff%,"^-");
                return_boolean = true;
            endif;
            return(%return_boolean%);
        endfunction;
    // math/index/_eq
        // Wrapper that converts A and B to Numbers, then checks for equality.
            // Params:
                // {string} <&a>    First Number to Parse and Compare.
                // {string} <&b>    Second Number to Parse and Compare.
            // Returns a Boolean
            // Example:
                //    equal = eq("1M","1000000");
        function _eq(&a,&b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:545
            &a_converted   = number(%&a%,"F:FLOAT","P:SIGNIFICANT");
            &b_converted   = number(%&b%,"F:FLOAT","P:SIGNIFICANT");
            return_boolean = %&a_converted% == %&b_converted%;
            return(%return_boolean%);
        endfunction;
    // math/index/_neq
        // Wrapper that converts A and B to Numbers, then checks for inequality.
            // Params:
                // {string} <&a>    First Number to Parse and Compare.
                // {string} <&b>    Second Number to Parse and Compare.
            // Returns a Boolean
            // Example:
                //    not_equal = neq("1M","1000000");
        function _neq(&a,&b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:559
            equal          = _eq(%&a%,%&b%);
            return_boolean = !%equal%;
            return(%return_boolean%);
        endfunction;
    // math/index/getNearestNumber
        // Given a Base Number, finds the Number that is nearest to the Base Number and returns it. Formats any Numbers out of whatever
        // Format they are in into Decimal Form before iterating over the Array. The Element that is returned will always be the 'unedited'
        // version of the Element (so indexof will return a valid index).
            // Params:
                // {string} <&base_number>             The Base Number to compare the other Numbers against.
                // {string} <...&compare_numbers[]>    The Numbers to Compare against the Base Number.
            // Returns the String Number from <...&compare_numbers[]> that is closest to the <&base_number> Parameter. If invalid Number
            // Parameters are passed to this Function (or no Values for ...&compare_numbers[] are passed/no value for <&base_number> is passed),
            // an Empty String will be returned.
            // Example:
                //    &compare_numbers[] = split(", ","1000, -500");
                //    &nearest_number    = getNearestNumber("100",...&compare_numbers[]);
                //    log("nearest number to 100 of 1000 and -500 is: %&nearest_number%"); // 'nearest number to 100 of 1000 and -500 is: -500'
        function getNearestNumber(&base_number,...&compare_numbers[]);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:480
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&5mathGetNearestNumber&7";
            endif;
            
            #nearest_index = -1;
            &nearest_diff  = "";
            &base_number   = replace(&base_number,",");
            &base_number   = convertENote(%&base_number%);
            base_is_metric = isMetricString(%&base_number%);
            if(%base_is_metric%);
                &base_number = convertMetricString(%&base_number%,-1,false);
            endif;
            
            #compare_numbers_sz = arraysize(&compare_numbers[]);
            if(%#compare_numbers_sz% > 1);
                foreach(&compare_numbers[],&compare_number,#cn);
                    &comparison_value = replace(&compare_number,",");
                    ifmatches(%&comparison_value%,"[^\d.-]");
                        &comparison_value = convertENote(%&comparison_value%);
                        ifmatches(%&comparison_value%,"[^\d.-]");
                            comparison_metric = isMetricString(%&comparison_value%);
                            if(%comparison_metric%);
                                &comparison_value = convertMetricString(%&comparison_value%,-1,false);
                            endif;
                        endif;
                    endif;
                    
                    &comparison_diff = xEval("sqrt((%&base_number% - %&comparison_value%)^2)");
                    if(%#cn% == 0);
                        #nearest_index = %#cn%;
                        &nearest_diff  = %&comparison_diff%;
                    else;
                        // If comparison_diff - nearest_diff < 0, comparison_diff is less than nearest_diff.
                        &comparison_eval = xEval("%&comparison_diff% - %&nearest_diff%");
                        ifmatches(%&comparison_eval%,"^-");
                            #nearest_index = %#cn%;
                            &nearest_diff  = %&comparison_diff%;
                        endif;
                    endif;
                next;
            elseif(%#compare_numbers_sz% == 1);
                #nearest_index = 0;
            else;
                debug_error(%debug%,%&script_debug_name%,"No valid Number Arguments passed! Returning empty string.");
            endif;
            
            if(%#nearest_index% != -1);
                &return_string = %&compare_numbers[%#nearest_index%]%;
            endif;
            
            &compare_numbers = join("&7', '&5",&compare_numbers[]);
            debug_log(%debug%,%&script_debug_name%,"Number '&d%&return_string%&7' is nearest to Base Number '&e%&base_number%&7' of Numbers: ['&5%&compare_numbers%&7'].");
            return(%&return_string%);
        endfunction;
    // banking/index/bankingInfoInternalGetLimits
        // Tries to determine the Limit of an Account based on what GUI we are in and what Items are present.
            // Params:
                // {string} [&bank_enum=""]    String ENUM returned from `bankingInfoInternalGetGuiType()` Function. If omitted or invalid, will call
                //                             that Function to grab it.
            // Returns an Array of Strings where Index 0 = Solo Limit, Index 1 = Coop Limit. If either
            // Limit is unable to be determined, it will be an empty String instead.
            // Example:
                //    &bank_limits[] = bankingInfoInternalGetLimits(%&bank_enum%);
                //    &solo_limit    = %&bank_limits[0]%;
                //    &coop_limit    = %&bank_limits[1]%;
        function bankingInfoInternalGetLimits(&bank_enum="");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:606
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bankingInfoGetLimits";
        
                // Setup GUIs we can find the Limits in, Items we can find the Limits in, etc.
                if(true);
                    // Wrap 'Bank Account Upgrades' GUI Items
                    if(true);
                        &upgrade_mcids[]   = "wheat_seeds";
                        &upgrade_names[]   = "Starter Account";
                        &primary_limit[]   = "50000000";
                        &secondary_limit[] = "10000000";
        
                        &upgrade_mcids[]   = "gold_nugget";
                        &upgrade_names[]   = "Gold Account";
                        &primary_limit[]   = "100000000";
                        &secondary_limit[] = "20000000";
        
                        &upgrade_mcids[]   = "gold_ingot";
                        &upgrade_names[]   = "Deluxe Account";
                        &primary_limit[]   = "250000000";
                        &secondary_limit[] = "50000000";
        
                        &upgrade_mcids[]   = "golden_chestplate";
                        &upgrade_names[]   = "Super Deluxe Account";
                        &primary_limit[]   = "500000000";
                        &secondary_limit[] = "100000000";
        
                        &upgrade_mcids[]   = "golden_horse_armor";
                        &upgrade_names[]   = "Premier Account";
                        &primary_limit[]   = "1000000000";
                        &secondary_limit[] = "200000000";
        
                        &upgrade_mcids[]   = "skull";
                        &upgrade_names[]   = "Luxurious Account";
                        &primary_limit[]   = "6000000000";
                        &secondary_limit[] = "1200000000";
        
                        &upgrade_mcids[]   = "skull";
                        &upgrade_names[]   = "Palatial Account";
                        &primary_limit[]   = "60000000000";
                        &secondary_limit[] = "12000000000";
                    endif;
        
                    // Wrap Generic Items
                    if(true);
                        &find_mcids[] = "gold_block";
                        &find_names[] = "Bank Upgrades";
                        &find_exprs[] = "bank limit: ([\d,.-]+)";
                        
                        &find_mcids[] = "redstone_torch";
                        &find_names[] = "Information";
                        &find_exprs[] = "limit: ([\d,.-]+(?: \w+)?)";
                    endif;
        
                    // Wrap GUI Setup
                    if(true);
                        // We can include the 'Co-op Bank Account' CONTAINER even if we are looking for the Solo Balance, because
                        // if we find ourselves in the 'Co-op Bank Account' GUI, we know that the Profile is a Coop, and the Solo Limit
                        // will always be 0.20x the Coop Limit. And vice-versa, we can include the Personal Bank Account in this too,
                        // because the Coop Limit will always be 5.00x the Personal Limit. However, if we are exclusively looking for the
                        // Coop Balance, then we will have to validate that there is a 'Go Back to Bank' Item in the Container's Items,
                        // to rule out the edge case in which we would return a Number for Solo Profiles without a Coop Account (the go
                        // back button will not be available on a Solo Profile, since there is no GUI to go back to from the Personal Bank Account GUI).
        
                        &accept_enums[]           = split(", ","CHOICE, UPGRADES, COOP, SOLO");
                        &get_profile_type_enums[] = split(", ","UPGRADES, SOLO");
                    endif;
        
                    // Wrap Expressions used in findItemContainer calls
                    if(true);
                        &upgrade_item_mcids_expr = join("|",&upgrade_mcids[]);
                        &upgrade_item_mcids_expr = "^(?:%&upgrade_item_mcids_expr%)$";
                        &upgrade_item_names_expr = join("|",&upgrade_names[]);
                        &upgrade_item_names_expr = "^(?:%&upgrade_item_names_expr%)$";
                        &upgrade_item_nbt_expr   = "This is your account!";
                        
                        &find_mcids_expr = join("|",&find_mcids[]);
                        &find_mcids_expr = "^(?:%&find_mcids_expr%)$";
                        &find_names_expr = join("|",&find_names[]);
                        &find_names_expr = "^(?:%&find_names_expr%)$";
                    endif;
                endif;
            endif;
        
            // Get the Limit for the Specified Account, or whichever one is available.
            if(true);
                &coop_limit   = "";
                &solo_limit   = "";
                #accept_index = indexof(&accept_enums[],,%&bank_enum%);
                if(%#accept_index% == -1);
                    &bank_enum    = bankingInfoInternalGetGuiType();
                    #accept_index = indexof(&accept_enums[],,%&bank_enum%);
                endif;
                
                if(%#accept_index% != -1);
                    &bank_enum    = %&accept_enums[%#accept_index%]%;
                    &profile_type = bankingInfoInternalGetProfileType(%&bank_enum%);
                    
                    if(%&bank_enum% == "UPGRADES");
                        &query_params[]     = split(", ","MCID: r$%&upgrade_item_mcids_expr%, NAME: r$%&upgrade_item_names_expr%, NBT: r$%&upgrade_item_nbt_expr%");
                        &query_array_prefix = "&upgrade_names";
                    else;
                        &query_params[]     = split(", ","MCID: r$%&find_mcids_expr%, NAME: r$%&find_names_expr%");
                        &query_array_prefix = "&find_names";
                    endif;
                    &query_array_pointer = "%&query_array_prefix%[]"
        
                    #query_slot = findItemContainer(false,...&query_params[]);
                    debug_log(%debug%,%&script_debug_name%,"query_slot is %#query_slot%");
                    if(%#query_slot% != -1);
                        &query_item  = getslotitemnbt(%#query_slot%,,#query_stack,#query_data,&query_nbt);
                        &query_nbt   = strip(%&query_nbt%);
                        &query_name  = getItemName(%&query_nbt%,%&query_item%);
                        #query_index = indexof(%&query_array_pointer%,,%&query_name%);
                        if(%#query_index% != -1);
                            if(%&bank_enum% == "UPGRADES");
                                &primary_limit   = %&primary_limit[%#query_index%]%;
                                &secondary_limit = %&secondary_limit[%#query_index%]%;
                            elseifmatches(%&query_nbt%,%&find_exprs[%#query_index%]%,&capture_group,1);
                                &formatted_group = number(%&capture_group%,"F: I");
                                #primary_index   = indexof(&primary_limit[],,%&formatted_group%);
                                #secondary_index = indexof(&secondary_limit[],,%&formatted_group%);
                                debug_log(%debug%,%&script_debug_name%,"from &&capture_group='&e%&capture_group%&7', got &&formatted_group='&e%&formatted_group%&7', found indexed #primary_index=&e%#primary_index%&7, #secondary_index=&e%#secondary_index%&7.");
                                
                                if(%#primary_index% != -1);
                                    &primary_limit   = %&primary_limit[%#primary_index%]%;
                                    &secondary_limit = %&secondary_limit[%#primary_index%]%;
                                elseif(%#secondary_index% != -1);
                                    &primary_limit   = %&primary_limit[%#secondary_index%]%;
                                    &secondary_limit = %&secondary_limit[%#secondary_index%]%;
                                else;
                                    debug_error(%debug%,%&script_debug_name%,"...");
                                    &compare_array_prefix = "&primary_limit";
                                    if((%&profile_type% == "COOP") && (%&bank_enum% == "SOLO"));
                                        &compare_array_prefix = "&secondary_limit";
                                    endif;
                                    &compare_array_pointer = "%&compare_array_prefix%[]";
                                    
                                    // Find the nearest number
                                    if(true);
                                        // Create array of Absolute Differences between each comparison value and each formatted group
                                        foreach(%&compare_array_pointer%,&compare_value,#cvi);
                                            &compare_diff[%#cvi%] = xEval("sqrt((%&compare_value% - %&formatted_group%)^2)");
                                        next;
                                        
                                        &nearest_diff    = getNearestNumber(0,...&compare_diff[]);
                                        #nearest_index   = indexof(&compare_diff[],,%&nearest_diff%);
                                        &nearest_number  = "%%&compare_array_prefix%[%#nearest_index%]%";
                                        &compare_diffs   = join("&7, '&e",&compare_diff[]);
                                        &primary_limit   = %&primary_limit[%#nearest_index%]%;
                                        &secondary_limit = %&secondary_limit[%#nearest_index%]%;
                                        debug_log(%debug%,%&script_debug_name%,"smallest diff from &&base_value=&e0&7 in &&compare_diff=[&e'%&compare_diffs%&7'] was &&nearest_diff='&e%&nearest_diff%&7', found at #nearest_index=&e%#nearest_index%&7, correlating to number='&e%&nearest_number%&7', resulting in &&primary_limit='&e%&primary_limit%&7', &&secondary_limit='&e%&secondary_limit%&7'.");
                                    endif;
                                endif;
                            endif;
                            
                            if(%&profile_type% == "COOP");
                                &coop_limit = %&primary_limit%;
                                &solo_limit = %&secondary_limit%;
                            else;
                                &solo_limit = %&primary_limit%;
                            endif;
                        else;
                            &query_array_pointer_joint = join("&7', '&e",%&query_array_pointer%);
                            debug_error(%debug%,%&script_debug_name%,"Could not find &&query_name='&e%&query_name%&7' in &&query_array_pointer[]=['&e%&query_array_pointer_joint%&7'] Array!");
                        endif;
                    endif;
                endif;
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Returning &&solo_limit='&e%&solo_limit%&7', &&coop_limit='&e%&coop_limit%&7' for GUI ENUM &&bank_enum='&e%&bank_enum%&7', &&profile_type='&e%&profile_type%&7'.");
            return(%&solo_limit%,%&coop_limit%);
        endfunction;
    // banking/index/bankingInfoInternalGetAccountType
        // Checks what Account Type we are in based on what GUI we are in and what Items are present.
            // Params:
                // {string} [&bank_gui_type]    Optional String ENUM returned from the `bankingInfoInternalGetGuiType()` Function.
                //                              If not provided (or invalid), will call `bankingInfoInternalGetGuiType()`.
            // Returns a String ENUM of 'COOP' or 'SOLO', or an empty string if it could not be determined.
            // Example:
                //    &current_account = bankingInfoInternalGetAccountType();
                //    if(%&current_account% == "COOP");
                //        log("In a Coop Bank Account GUI")
                //    elseif(%&current_account% == "SOLO");
                //        log("In a Solo Bank Account GUI")
                //    elseif(%&current_account% == "");
                //        log("Not in a Bank Account GUI")
                //    endif;
        function bankingInfoInternalGetAccountType(&bank_gui_type);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:372
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&6bankingInfoGetAccountType";
                &return_string     = "NONE";
                &gui_enum_map[]    = split(", ","UPGRADES, CHOICE, COOP, SOLO, COOP_DEPOSIT, SOLO_DEPOSIT, SIGN_DEPOSIT, COOP_WITHDRAW, SOLO_WITHDRAW, SIGN_WITHDRAW, NONE");
                #gui_enum_index    = indexof(&gui_enum_map[],,%&bank_gui_type%);
                if(%#gui_enum_index% == -1);
                    &bank_gui_type = bankingInfoInternalGetGuiType();
                endif;
            endif;
        
            ifmatches(%&bank_gui_type%,"^(SOLO|COOP)",&profile_type,1);
                &return_string = ucase(%&profile_type%);
            endif;
        
            debug_log(%debug%,%&script_debug_name%,"Returning Account Type '&d%&return_string%&7' from Bank GUI Type '&d%&bank_gui_type%&7'.");
            return(%&return_string%);
        endfunction;
    // banking/index/bankingInfoInternalGetBalances
        // Tries to determine the Balance of the specified Bank Account based on what GUI we are in and what Items are present.
            // Params:
                // {string} [&bank_enum=""]    String ENUM returned from `bankingInfoInternalGetGuiType()` Function. If omitted or invalid, will call
                //                             that Function to grab it.
            // Returns an Array of Strings where Index 0 = Solo Balance, Index 1 = Coop Balance. If either
            // Balance is unable to be determined, it will be an empty String instead.
            // Example:
                //    &bank_balances[] = bankingInfoInternalGetBalances(%&bank_enum%);
                //    &solo_balance    = %&bank_balances[0]%;
                //    &coop_balance    = %&bank_balances[1]%;
        function bankingInfoInternalGetBalances(&bank_enum="");
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:403
            // Setup Function Variables
            if(true);
                debug                 = true;
                &script_debug_name    = "&6bankingInfoGetBalance";
                &current_account_type = bankingInfoInternalGetAccountType();
                if(%&current_account_type% == "");
                    &current_account_type = bankingInfoInternalGetProfileType(%&bank_enum%);
                endif;
                &solo_balance         = "";
                &coop_balance         = "";
        
                // Setup GUIs we can find the Balance(s) in, Items we can find the Balance(s) in, etc.
                if(true);
                    // Wrap Generic Items that we can query for the Balance of the Account.
                    if(true);
                        &percent_sign = char("37");
        
                        &find_mcids[] = "chest";
                        &find_names[] = "Deposit Coins";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "dropper";
                        &find_names[] = "Withdraw Coins";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "chest";
                        &find_names[] = "Your whole purse";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "chest";
                        &find_names[] = "Half your purse";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "dropper";
                        &find_names[] = "Everything in the account";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "dropper";
                        &find_names[] = "Half the account";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "dropper";
                        &find_names[] = "Withdraw 20%&percent_sign%";
                        &find_types[] = %&current_account_type%;
        
                        &find_mcids[] = "sign";
                        &find_names[] = "Specific amount";
                        &find_types[] = %&current_account_type%;
                    endif;
        
                    // Wrap Containers we can find the Balance of an Account in.
                    if(true);
                        &accept_gui     = "GUICHEST";
                        &accept_enums[] = "CHOICE";
                        &solo_enums[]   = "CHOICE";
                        &coop_enums[]   = "CHOICE";
                        
                        push(&accept_enums[],"COOP","COOP_DEPOSIT","COOP_WITHDRAW");
                        push(&coop_enums[],"COOP","COOP_DEPOSIT","COOP_WITHDRAW");
                        &find_mcids[] = "ender_chest";
                        &find_names[] = "Co-op Bank Account";
                        &find_types[] = "COOP";
                        
                        push(&accept_enums[],"SOLO","SOLO_DEPOSIT","SOLO_WITHDRAW");
                        push(&solo_enums[],"SOLO","SOLO_DEPOSIT","SOLO_WITHDRAW");
                        &find_mcids[] = "chest";
                        &find_names[] = "Personal Bank Account";
                        &find_types[] = "SOLO";
                    endif;
                    
                    // Split up '&find_...' into Groups of COOP and SOLO types.
                    if(true);
                        foreach(&find_names[],&find_name,#fn);
                            if(%&find_types[%#fn%]% == "COOP");
                                &coop_mcids[] = %&find_mcids[%#fn%]%;
                                &coop_names[] = %&find_names[%#fn%]%;
                            elseif(%&find_types[%#fn%]% == "SOLO");
                                &solo_mcids[] = %&find_mcids[%#fn%]%;
                                &solo_names[] = %&find_names[%#fn%]%;
                            endif;
                        next;
                    endif;
                endif;
        
                &find_mcids      = join("|",&find_mcids[]);
                &find_mcids_expr = "^(?:%&find_mcids%)$";
                
                &find_names      = join("|",&find_names[]);
                &find_names_expr = "^(?:%&find_names%)$";
                
                &coop_names      = join("|",&coop_names[]);
                &coop_names_expr = "^(?:%&coop_names%)$";
                
                &coop_mcids      = join("|",&coop_mcids[]);
                &coop_mcids_expr = "^(?:%&coop_mcids%)$";
                
                &solo_names      = join("|",&solo_names[]);
                &solo_names_expr = "^(?:%&solo_names%)$";
                
                &solo_mcids      = join("|",&solo_mcids[]);
                &solo_mcids_expr = "^(?:%&solo_mcids%)$";
                
                &balance_expr    = "balance: ([\d,.-]+)";
            endif;
            
            // Get the Balance of each Account that we can get the Balance for.
            if(true);
                #accept_index = indexof(&accept_enums[],,%&bank_enum%);
                if(%#accept_index% == -1);
                    &bank_enum    = bankingInfoInternalGetGuiType();
                    #accept_index = indexof(&accept_enums[],,%&bank_enum%);
                endif;
                
                if(%#accept_index% != -1);
                    &bank_enum  = %&accept_enums[%#accept_index%]%;
                    #coop_index = indexof(&coop_enums[],,%&bank_enum%);
                    #solo_index = indexof(&solo_enums[],,%&bank_enum%);
                    if(%#coop_index% != -1);
                        &check_terms[] = "coop";
                        debug_log(%debug%,%&script_debug_name%,"Current Bank ENUM (&&bank_enum: '&d%&bank_enum%&7') has Item(s) that can contain the COOP Balance, pushing COOP Term to checklist.");
                    endif;
                    if(%#solo_index% != -1);
                        &check_terms[] = "solo";
                        debug_log(%debug%,%&script_debug_name%,"Current Bank ENUM (&&bank_enum: '&d%&bank_enum%&7') has Item(s) that can contain the SOLO Balance, pushing SOLO Term to checklist.");
                    endif;
                    
                    foreach(&check_terms[],&check_term,#ct);
                        &mcids_expr = "%&%&check_term%_mcids_expr%";
                        &names_expr = "%&%&check_term%_names_expr%";
                        #found_slot = findItemContainer(false,"MCID: r$%&mcids_expr%","NAME: r$%&names_expr%","NBT: r$%&balance_expr%");
                        if(%#found_slot% != -1);
                            &found_item = getslotitemnbt(%#found_slot%,,#found_stack,#found_data,&found_nbt);
                            &found_nbt  = strip(%&found_nbt%);
                            ifmatches(%&found_nbt%,%&balance_expr%,&balance_string,1);
                                &balance_string = replace(&balance_string,",");
                                &balance_string = number(%&balance_string%,"F: I","R: T");
                                set("&%&check_term%_balance",%&balance_string%);
                                debug_log(%debug%,%&script_debug_name%,"Set Balance for Variable '&d&&%&check_term%_balance&7' to be '&6%&balance_string%&7' coins.");
                            else;
                                debug_error(%debug%,%&script_debug_name%,"NBT for MCID: '&4%&found_item%&c' did not match Expression '&4%&balance_expr%&7' (NBT: &4%&found_nbt%&7).");
                            endif;
                        else;
                            debug_error(%debug%,%&script_debug_name%,"Could not find any Item that contained the Balance for the '&d%&check_term%&7' Account.");
                        endif;
                    next;
                endif;
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"Found a total of '&6%&coop_balance%&7' coins in the COOP Bank Account, '&6%&solo_balance%&7' coins in the SOLO Bank Account.");
            return(%&solo_balance%,%&coop_balance%);
        endfunction;
    // math/index/_lte
        // Wrapper that converts A and B to Numbers, then checks for A being <= B.
            // Params:
                // {string} <&a>    First Number to Parse and Compare.
                // {string} <&b>    Second Number to Parse and Compare.
            // Returns a Boolean
            // Example:
                //    less_than_or_equal_to = lte("1M","1000000");
        function _lte(&a,&b);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/math/index.txt:615
            &a_converted = number(%&a%,"F:FLOAT","P:SIGNIFICANT");
            &b_converted = number(%&b%,"F:FLOAT","P:SIGNIFICANT");
            &diff        = eval("%&a_converted% - %&b_converted%");
            ifmatches(%&diff%,"^-");
                return_boolean = true;
            elseifmatches(%&diff%,"^[0e.]+$");
                return_boolean = true;
            endif;
            return(%return_boolean%);
        endfunction;
    // info/index/getPurse
        // Returns the amount of coins in the purse, rounded to the nearest integer.
            // Params: None
            // Returns: Integer amount of Coins in the purse (returns -1 if cannot find Purse Coins).
        function getPurse();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:644
            &return_integer = -1;
            foreach("teams");
                &scoreboard_line = strip("%TEAMPREFIX%%TEAMSUFFIX%");
                ifmatches(%&scoreboard_line%,"(?:Purse|Piggy): ([0-9,]+)",&coins,1);
                    &return_integer := regexreplace(&coins,"\D","");
                    break;
                endif;
            next;
            return(%&return_integer%);
        endfunction;
    // banking/index/bankingTransact
        // Executes the specified Transaction with the Bank.
            // Params:
                // {string} [&action="DEPOSIT"]      String ENUM of DEPOSIT or WITHDRAW. As long as String contains 'D', will take as 'DEPOSIT', and vice versa.
                // {string} [&amount=-1]             Amount of Coins to Transact with. Can be a Metric Number, Exp. Notation Number, Formatted,
                //                                   Float, or Integer. If set to <= 0, will transact the maximum amount of Coins with the specified
                //                                   accounts.
                // {boolean} [solo_allow=true]       Whether or not to allow Transacting with the Solo Account.
                // {boolean} [coop_allow=true]       Whether or not to allow Transacting with the Coop Account, if it is available.
                // {boolean} [under_allow=true]      Whether or not to continue on with the Transaction even if the specified amount of Coins cannot be
                //                                   transacted with from the specified Accounts. Setting this to TRUE will make it so the maximum amount
                //                                   of Coins is transacted with when the specified amount cannot be done (e.g. filling up the purse as best
                //                                   as we can, or emptying it out as best as we can).
                // {number} [#timeout_sec=30]        Amount of Seconds Function can run for before Timing Out.
                // {number} [#tick_wait=20]          Amount of Ticks to wait between repeating Actions.
                // {boolean} [personal_bank=true]    Whether or not to allow the usage of the Personal Bank shortcut Item, if it is available.
            // Returns a Boolean indicating whether or not the specified [&amount] of Coins was able to be transacted using [&action] into the specified Accounts.
            // Example:
                //    // Emptying the Purse out into all the Accounts
                //        purse_emptied = bankingTransact("DEPOSIT");
                //    // Filling the Purse up from all the Accounts
                //        purse_filled = bankingTransact("WITHDRAW");
                //    // Emptying the Purse out into the Solo Account
                //        solo_filled = bankingTransact("DEPOSIT",-1,true,false);
                //    // Emptying the Purse out into the Coop Account
                //        coop_filled = bankingTransact("DEPOSIT",-1,false,true);
                //    // Filling the Purse up from the Solo Account
                //        solo_emptied = bankingTransact("WITHDRAW",-1,true,false);
                //    // Filling the Purse up from the Coop Account
                //        coop_emptied = bankingTransact("WITHDRAW",-1,false,true);
        function bankingTransact(&action="DEPOSIT",&amount=-1,solo_allow=true,coop_allow=true,under_allow=true,#timeout_sec=30,#tick_wait=20,personal_bank=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:1447
            // Setup Function Variables
            if(true);
                &transaction_type   = "DEPOSIT";
                &transaction_amount = number(%&amount%);
                transaction_max     = _lte(%&transaction_amount%,0);
                under_allow         = ((%under_allow%) || (%transaction_max%));
                ifmatches(%&action%,"W"); &transaction_type = "WITHDRAW"; endif;
                
                debug              = true;
                &script_debug_name = "&5bTx&7[&e%&transaction_type%&7]";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
                
                if((!%solo_allow%) && (!%coop_allow%));
                    debug_error(%debug%,%&script_debug_name%,"At least one bank account must be permitted to transact with (solo_allow must be true, or coop_allow must be true).");
                    return(False);
                endif;
                
            endif;
            
            // Enter the Main Banking GUI.
            if(true);
                in_bank = bankingActionInternalOpenBank(%#timeout_sec%,%#tick_wait%,%personal_bank%);
                if(!%in_bank%);
                    debug_error(%debug%,%&script_debug_name%,"Failed to open up the Banking GUI!");
                    return(False);
                endif;
            endif;
            
            // Figure out the Balances of the Accounts we are going to be transacting with
            if(true);
                &bank_account_names[]    = split(", ","solo, coop");
                bank_account_bools[]     = split(", ","%solo_allow%, %coop_allow%");
                &bank_account_balances[] = bankingInfoInternalGetBalances();
                &bank_account_limits[]   = bankingInfoInternalGetLimits();
                &b_remaining             = %&transaction_amount%;
                if((%transaction_max%) && (%&transaction_type% == "DEPOSIT"));
                    &b_remaining = getPurse();
                    debug_log(%debug%,%&script_debug_name%,"b_remaining = %&b_remaining%");
                endif;
                
                foreach(bank_account_bools[],bank_account_bool,#bab);
                    &t_amount = "0";
                    if(%bank_account_bool%);
                        if(%&transaction_type% == "DEPOSIT");
                            &b_maximum = xEval("%&bank_account_limits[%#bab%]% - %&bank_account_balances[%#bab%]%");
                            &b_maximum = number(%&b_maximum%,"F:I","R:T");
                        elseif(%&transaction_type% == "WITHDRAW");
                            &b_maximum = number(%&bank_account_balances[%#bab%]%,"F:I","R:T");
                        endif;
                        
                        not_zero = _neq(%&b_maximum%,"0");
                        if(%not_zero%);
                            set_zero = false;
                            if((%&transaction_type% == "DEPOSIT") && (%transaction_max%));
                                // Check if there is even anything more to deposit
                                set_zero = _lte(%&b_remaining%,"0");
                            endif;
                            
                            if(%set_zero%);
                                &t_amount = "0";
                            elseif(%transaction_max%);
                                &t_amount = "-1";
                            else;
                                &t_amount = "-1";
                                is_gte = _gte(%&b_maximum%,%&b_remaining%);
                                if(%is_gte%);
                                    &t_amount = %&b_remaining%;
                                endif;
                            endif;
                        endif;
                    endif;
                    
                    &t_amount = number(%&t_amount%,"F: I","R: T");
                    if(%&t_amount% == "-1");
                        &b_remaining = xEval("%&b_remaining% - %&b_maximum%");
                    else;
                        &b_remaining = xEval("%&b_remaining% - %&t_amount%");
                    endif;
                    
                    &bank_account_transact[%#bab%] = %&t_amount%;
                    &vars[]                        = split(" ","&t_amount &b_maximum &bank_account_limits[%#bab%] &bank_account_balances[%#bab%] &b_remaining &transaction_type &bank_account_names[%#bab%] set_zero transaction_max is_gte not_zero");
                    foreach(&vars[],&var,#v);
                        &val    = "%%&var%%";
                        &logvar = regexreplace(&var,"(?<!&)(&[\w])","&$1");
                        &logval = regexreplace(&val,"(?<!&)(&[\w])","&$1");
                        debug_log(%debug%,%&script_debug_name%,"%#v% > %&logvar%: '&d%&logval%&7'.");
                    next;
                    if(%debug%); log(" "); endif;
                next;
                
                return_boolean = true;
                if(!%under_allow%);
                    &sum_transact  = xEval("%&bank_account_transact[0]% + %&bank_account_transact[1]%");
                    return_boolean = _gte(%&sum_transact%,%&transaction_amount%);
                    if(!%return_boolean%);
                        debug_error(%debug%,%&script_debug_name%,"Sum transaction of Coins is &&sum_transact='&e%&sum_transact%&7' for Action Type &&transaction_type='&e%&transaction_type%&7', does not meet minimum amount of &&transaction_amount='&e%&transaction_amount%&7', cancelling before actions.");
                        return(False);
                    endif;
                endif;
            endif;
            
            // Setup 'Max Items'
            if(true);
                if(%&transaction_type% == "DEPOSIT");
                    &max_find_item = "chest";
                    &max_find_name = "Your whole purse";
                    #max_find_slot = 11;
                else;
                    &max_find_item = "dropper";
                    &max_find_name = "Everything in the account";
                    #max_find_slot = 10;
                endif;
            endif;
            
            // Execute the Transactions for each Account.
            foreach(&bank_account_transact[],&bank_account_transact,#bat);
                debug_log(%debug%,%&script_debug_name%,"bank_account_transact: &d%&bank_account_transact%&7 from name %&bank_account_names[%#bat%]%&7.");
                
                if(%&bank_account_transact% != "0");
                    &target_enum = "%&bank_account_names[%#bat%]%_%&transaction_type%_SIGN";
                    if(%&bank_account_transact% == "-1");
                        &target_enum = "%&bank_account_names[%#bat%]%_%&transaction_type%";
                    endif;
                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                    in_target_enum     = bankingGUI(%&target_enum%,"",%#recursive_timeout%,%#tick_wait%,%personal_bank%);
                    if(%in_target_enum%);
                        debug_log(%debug%,%&script_debug_name%,"Got into GUI_ENUM: '&d%&target_enum%&7'. Executing Transaction...");
                        
                        unset(@banking_failure);
                        unset(@banking_confirm);
                        if(%&bank_account_transact% == "-1");
                            #max_slot = findItemContainer(false,"SLOT: %#max_find_slot%","NAME: %&max_find_name%","MCID: %&max_find_item%");
                            if(%#max_slot% != -1);
                                #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                coins_transacted   = containerClick(%#max_slot%,%#recursive_timeout%,%#tick_wait%);
                            endif;
                        else;
                            wait("1t");
                            type(%&bank_account_transact%);
                            wait("1t");
                            localGUI("NONE");
                        endif;
                        
                        do;
                            // Check for Function Timeout
                            if(%do_timeout%);
                                func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                if(%func_timeout%);
                                    debug_error(%debug%,%&script_debug_name%,"Function Timed Out!");
                                    break;
                                endif;
                            endif;
                            
                            wait("1t");
                        until((%@banking_failure%) || (%@banking_confirm%));
                        
                        if(%func_timeout%);
                            return_boolean = false;
                            break;
                        else;
                            debug_log(%debug%,%&script_debug_name%,"banking_failure='&4%@banking_failure%&7', banking_confirm='&a%@banking_confirm%&7'.");
                            if(%@banking_failure%);
                                debug_error(%debug%,%&script_debug_name%,"Failed Banking Action, reason: '&4%@&banking_failure_string%&7'.");
                                return_boolean = false;
                            endif;
                        endif;
                    endif;
                endif;
            next;
            
            debug_log(%debug%,%&script_debug_name%,"returning boolean '&d%return_boolean%&7'.");
            return(%return_boolean%);
        endfunction;
    // banking/index/bankingWithdraw
        // Wrapper that calls `bankingTransact()` to Deposit the specified amount of Coins.
            // Params:
                // {string} [&amount=-1]             Amount of Coins to Transact with. Can be a Metric Number, Exp. Notation Number, Formatted,
                //                                   Float, or Integer. If set to <= 0, will transact the maximum amount of Coins with the specified
                //                                   accounts.
                // {boolean} [solo_allow=true]       Whether or not to allow Transacting with the Solo Account.
                // {boolean} [coop_allow=true]       Whether or not to allow Transacting with the Coop Account, if it is available.
                // {boolean} [under_allow=true]      Whether or not to continue on with the Transaction even if the specified amount of Coins cannot be
                //                                   transacted with from the specified Accounts. Setting this to TRUE will make it so the maximum amount
                //                                   of Coins is transacted with when the specified amount cannot be done (e.g. filling up the purse as best
                //                                   as we can, or emptying it out as best as we can).
                // {number} [#timeout_sec=30]        Amount of Seconds Function can run for before Timing Out.
                // {number} [#tick_wait=20]          Amount of Ticks to wait between repeating Actions.
                // {boolean} [personal_bank=true]    Whether or not to allow the usage of the Personal Bank shortcut Item, if it is available.
            // Returns a Boolean indicating whether or not the specified [&amount] of Coins was able to be transacted using [&action] into the specified Accounts.
            // Example:
                // coins_withdrawn = bankingWithdraw("1m");
        function bankingWithdraw(&amount=-1,solo_allow=true,coop_allow=true,under_allow=true,#timeout_sec=30,#tick_wait=20,personal_bank=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/banking/index.txt:1640
            return_boolean = bankingTransact("WITHDRAW",%&amount%,%solo_allow%,%coop_allow%,%under_allow%,%#timeout_sec%,%#tick_wait%,%personal_bank%);
            return(%return_boolean%);
        endfunction;
    // misc/refillCoins/refillCoins
        // Attempts to refill the specified amount of Coins by whatever means necessary (will try:
        // bank accounts, bazaar orders, and uncollected auction sales in that order).
            // Params:
                // {string} [&amount=-1]         The amount of Coins to refill. If set to -1, will refill the Maximum
                //                               amount of Coins available. Can pass any type of Number so long as it is parseable by
                //                               `number()`.
                // {number} [#timeout_sec=30]    Max seconds Function can run for before timing out. Set to <= 0 to disable timeouts.
                // {number} [#tick_wait=20]      Ticks to wait between repeating certain actions.
                // {boolean} [solo_bank=true]    Whether or not to try to refill the Coins from the Solo Bank Account.
                // {boolean} [coop_bank=true]    Whether or not to try to refill the Coins from the Coop Bank Account, if it is available.
                // {boolean} [bazaar=true]       Whether or not to try to refill the Coins from uncollected Bazaar Sell Orders, if any are
                //                               available.
                // {boolean} [auctions=true]     Whether or not to try to refill the Coins from uncollected Auction Sales, if any are available.
            // Returns a Boolean indicating whether or not the specified amount of Coins was able to be refilled.
            // Example:
                //    coins_refilled = refillCoins("100k");
        function refillCoins(&amount=-1,#timeout_sec=30,#tick_wait=20,solo_bank=true,coop_bank=true,bazaar=true,auctions=true);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/misc/refillCoins.txt:17
            // Setup Function Variables
            if(true);
                debug              = true;
                &script_debug_name = "&a$&6refillCoins&a$";
                do_timeout         = %#timeout_sec% > 0;
                #start_time        = %TIMESTAMP%;
                &refill_amount     = number(%&amount%,"F:I","R:T");
                refill_maximum     = %&refill_amount% == "-1";
                
                // Sanity Check -- At least one Refill Method must be enabled.
                if((!%solo_bank%) && (!%coop_bank%) && (!%bazaar%) && (!%auctions%));
                    debug_error(%debug%,%&script_debug_name%,"At least one Refill Method must be enabled! (solo_bank, coop_bank, bazaar, and auctions are all disabled)");
                    return(False);
                endif;
            endif;
            
            // Function Logic
            if(true);
                &balance_before = getPurse();
                
                // Try the Bank Account(s) if we are trying Bank.
                if((%solo_bank%) || (%coop_bank%));
                    check_coins = bankingWithdraw(%&refill_amount%,%solo_bank%,%coop_bank%,true,%#timeout_sec%,%#tick_wait%);
                    if((!%refill_maximum%) && (%check_coins%));
                        &balance_current    = getPurse();
                        &balance_difference = xEval("%&balance_current% - %&balance_before%");
                        balance_diff_gte    = _gte(%&balance_difference%,%&refill_amount%);
                        if(%balance_diff_gte%);
                            debug_log(%debug%,%&script_debug_name%,"Successfully refilled &6%&refill_amount%&7 coins from the Bank Account(s).");
                            return(True);
                        endif;
                    endif;
                endif;
                
                // Try the Bazaar if we are trying Bazaar.
                if(%bazaar%);
                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                    &bazaar_orders[]   = bazaarIndexOrders(true,%#tick_wait%,%#recursive_timeout%);
                    foreach(&bazaar_orders[],&bazaar_order,#boi);
                        &order_data[]      = split("|",%&bazaar_order%);
                        &order_sbid        = %&order_data[0]%;
                        &order_type        = %&order_data[1]%;
                        &price_per_unit    = %&order_data[2]%;
                        #items_filled     := %&order_data[3]%;
                        #items_total      := %&order_data[4]%;
                        #amount_claimable := %&order_data[5]%;
                        order_expired     := %&order_data[6]%;
                        
                        if((%#amount_claimable% > 0) && (%&order_type% == "SELL"));
                            #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                            order_collected    = bazaarCollectOrder(%&bazaar_order%,true,%#tick_wait%,%#recursive_timeout%);
                            if((%order_collected%) && (!%refill_maximum%));
                                &balance_current    = getPurse();
                                &balance_difference = xEval("%&balance_current% - %&balance_before%");
                                balance_diff_gte    = _gte(%&balance_difference%,%&refill_amount%);
                                if(%balance_diff_gte%);
                                    debug_log(%debug%,%&script_debug_name%,"Successfully refilled &6%&refill_amount%&7 coins from the Bank Account(s).");
                                    return_boolean = true;
                                    break;
                                endif;
                            endif;
                        endif;
                    next;
                    if(%return_boolean%);
                        return(%return_boolean%);
                    endif;
                endif;
                
                // Try the Auction House if we are trying Auction House.
                if(%auctions%);
                    &available_auctions[] = auctionsIndexCoinsAvailable();
                    foreach(&available_auctions[],&available_auction,#aa);
                        &listing_info[]    = split("|",%&available_auction%);
                        listing_hit       := %&listing_info[0]%;
                        &listing_id        = %&listing_info[1]%;
                        &listing_type      = %&listing_info[2]%;
                        #listing_price    := %&listing_info[3]%;
                        #listing_bids     := %&listing_info[4]%;
                        listing_ended     := %&listing_info[5]%;
                        listing_claimed   := %&listing_info[6]%;
                        &listing_owner     = %&listing_info[7]%;
                        &listing_profile   = %&listing_info[8]%;
                        &listing_sbid      = %&listing_info[9]%;
                        &listing_name      = %&listing_info[10]%;
                        &listing_mcid      = %&listing_info[11]%;
                        #listing_data     := %&listing_info[12]%;
                        #listing_stack    := %&listing_info[13]%;
                        &listing_buyers    = %&listing_info[14]%;
                        #listing_end_time := %&listing_info[15]%;
                        
                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                        &collected_listing = auctionsCollectListing(%#tick_wait%,%#recursive_timeout%,"ID: %&listing_id%");
                        if(%&collected_listing% == "ERROR_UNAVAILABLE");
                            break;
                        elseif((%&collected_listing% == "SUCCESS") && ((!%refill_maximum%) && (%check_coins%)));
                            &balance_current    = getPurse();
                            &balance_difference = xEval("%&balance_current% - %&balance_before%");
                            balance_diff_gte    = _gte(%&balance_difference%,%&refill_amount%);
                            if(%balance_diff_gte%);
                                debug_log(%debug%,%&script_debug_name%,"Successfully refilled &6%&refill_amount%&7 coins from the Bank Account(s).");
                                return_boolean = True;
                                break;
                            endif;
                        endif;
                    next;
                    if(%return_boolean%);
                        return(True);
                    endif;
                endif;
            endif;
            
            &balance_current    = getPurse();
            &balance_difference = xEval("%&balance_current% - %&balance_before%");
            balance_diff_gte    = _gte(%&balance_difference%,%&refill_amount%);
            if(%balance_diff_gte%);
                debug_log(%debug%,%&script_debug_name%,"Successfully refilled &6%&refill_amount%&7 coins from the Bank Account(s).");
                return(True);
            endif;
            return(False);
        endfunction;
    // info/index/getPurseCoins
        // Proxy for a call to `getPurse`.
            // Params: None
            // Returns: Integer amount of Coins in the purse (returns -1 if cannot find Purse Coins).
        function getPurseCoins();
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/info/index.txt:659
            &return_integer = getPurse();
            return(%&return_integer%);
        endfunction;
    // auctions/actions/auctionsPlaceBid
        // Places a bid on an Auction Listing.
            // Params:
                // {string} [&auction_id]            The ID of the Auction to bid on. If omitted, will take it as to place a bid on whatever
                //                                   Listing is currently opened (so long as an Auction Listing GUI is open).
                // {number} [#bid_amount]            The amount of Coins to spend on the bid. If omitted, will take it as meaning the minimum
                //                                   price needed to place the Bid on the Listing specified.
                // {boolean} [refill_coins=true]     Whether or not to allow the automatic refilling of Coins should we not have enough to
                //                                   place the bid.
                // {boolean} [allow_command=true]    Whether or not to allow the usage of the /ah Command, so long as a Booster Cookie is
                //                                   enabled, and/or the current SkyBlock Server Type is HUB.
                // {number} [#tick_wait=20]          The amount of Ticks to wait in between click interactions.
                // {number} [#timeout_sec=30]        The maximum amount of seconds this Function can run for before timing out and returning
                //                                   an Error. Set to <= 0 to disable timeouts.
            // Returns a String ENUM:
                // SUCCESS              The Function executed as expected and was successful.
                // ERROR_TIMEOUT        The Function exited early due to a timeout.
                // ERROR_UNAVAILABLE    The Function exited due to the Auction House being closed for some reason (i.e. Derpy is Mayor).
                // ERROR_NOT_FOUND      The Function exited due to not being able to find the Auction (can occur if the Auction ID
                //                      is invalid, or the Function was called with the Auction ID Parameter omitted without a Listing GUI open).
                // ERROR_COINS          The function exited due to not having enough Coins to place the bid for the Auction.
                // ERROR_EXPIRED        The function exited due to the Auction being expired by the time we went to go place the Bid for it.
                // ERROR_UNKNOWN        The function exited due to an unknown Error.
                // ERROR_SERVER         The function exited due to not being able to get onto SkyBlock.
                // ERROR_BID_AMOUNT     The function exited due to the Bid Amount being invalid.
            // Example:
                //    &auction_bid_placed = auctionsPlaceBid(%&auction_id%,%#bid_amount%,%refill_coins%,%allow_command%,%#tick_wait%,%#timeout_sec%);
                //    if(%&auction_bid_placed% == "SUCCESS");
                //    else;
                //        if(%&auction_bid_placed% == "ERROR_TIMEOUT");
                //        elseif(%&auction_bid_placed% == "ERROR_UNAVAILABLE");
                //        elseif(%&auction_bid_placed% == "ERROR_NOT_FOUND");
                //        elseif(%&auction_bid_placed% == "ERROR_COINS");
                //        elseif(%&auction_bid_placed% == "ERROR_EXPIRED");
                //        elseif(%&auction_bid_placed% == "ERROR_UNKNOWN");
                //        elseif(%&auction_bid_placed% == "ERROR_BID_AMOUNT");
                //        elseif(%&auction_bid_placed% == "ERROR_SERVER");
                //        endif;
                //    endif;
        function auctionsPlaceBid(&auction_id,#bid_amount,refill_coins=true,allow_command=true,#tick_wait=20,#timeout_sec=30);
            // File: G:/G_DRIVE_CODE/mkbFunctionExporterNew/mkbSource/auctions/actions.txt:306
            // Setup Function Variables
            if(true);
                if(true);
                    debug              = true;
                    &script_debug_name = "&6auctionsPlaceBid&7";
                    #start_time        = %TIMESTAMP%;
                    do_timeout         = %#timeout_sec% > 0;
                    do_id_lookup       = %&auction_id% != "";
                    do_custom_bid      = %#bid_amount% > 0;
                    &enum_success      = "SUCCESS";
                    &enum_timeout      = "ERROR_TIMEOUT";
                    &enum_unavailable  = "ERROR_UNAVAILABLE";
                    &enum_not_found    = "ERROR_NOT_FOUND";
                    &enum_coins        = "ERROR_COINS";
                    &enum_expired      = "ERROR_EXPIRED";
                    &enum_unknown      = "ERROR_UNKNOWN";
                    &enum_bid_amount   = "ERROR_BID_AMOUNT";
                    &enum_server       = "ERROR_SERVER";
                    
                    if(%TIMESTAMP% < %@#ah_closed_timestamp%);
                        debug_error(%debug%,%&script_debug_name%,"Auction House is currently closed, cannot place bids!");
                        return(%&enum_unavailable%);
                    endif;
                endif;
                
                // Make sure we are on a SkyBlock Server to begin with.
                if(true);
                    #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                    on_skyblock        = gotoServer("SKYBLOCK",%#tick_wait%,%#recursive_timeout%);
                    if(!%on_skyblock%);
                        debug_error(%debug%,%&script_debug_name%,"Not on a SkyBlock Server!");
                        return(%&enum_server%);
                    endif;
                endif;
                
                // If we are doing a custom bid, check to make sure that we can afford it.
                if(%do_custom_bid%);
                    #purse_coins = getPurseCoins();
                    if(%#purse_coins% < %#bid_amount%);
                        if(%refill_coins%);
                            #refill_coins  = %#bid_amount% - %#purse_coins%;
                            coins_refilled = refillCoins(%#refill_coins%);
                        endif;
                        
                        if(!%coins_refilled%);
                            debug_error(%debug%,%&script_debug_name%,"Cannot afford CUSTOM_BID &4%#bid_amount%&c (purse holds: &6%#purse_coins% coins&7).");
                            return(%&enum_coins%);
                        endif;
                    endif;
                endif;
                
                // Do a lookup on the Auction ID so we know what to expect once we get into the Auction Listing GUI.
                if(true);
                    &listing_info[]  = auctionsGetListingInfo(%&auction_id%);
                    listing_hit     := %&listing_info[0]%;
                    if(!%listing_hit%);
                        debug_error(%debug%,%&script_debug_name%,"Failed to get Listing Info for ID: &d%&auction_id%&7.");
                        return(%&enum_not_found%);
                    endif;
                    &listing_id      = %&listing_info[1]%;
                    &listing_type    = %&listing_info[2]%;
                    #listing_price  := %&listing_info[3]%;
                    #listing_bids   := %&listing_info[4]%;
                    listing_ended   := %&listing_info[5]%;
                    listing_claimed := %&listing_info[6]%;
                    if((%listing_ended%) || (%listing_claimed%));
                        debug_error(%debug%,%&script_debug_name%,"Listing ID &d%&auction_id%&c has already ended (listing_ended: %listing_ended%) or been claimed (listing_claimed: %listing_claimed%).");
                        return(%&enum_expired%);
                    endif;
                    
                    do_custom_bid = ((%do_custom_bid%) && (%&listing_type% == "AUCTION"));
                    #purse_coins  = getPurseCoins();
                    if(((%&listing_type% == "BIN") || (%#listing_bids% == 0)) && (%#purse_coins% < %#listing_price%));
                        if(%refill_coins%);
                            #refill_coins  = %#listing_price% - %#purse_coins%;
                            coins_refilled = refillCoins(%#refill_coins%);
                        endif;
                        
                        if(!%coins_refilled%);
                            debug_error(%debug%,%&script_debug_name%,"Cannot afford Listing Price &4%#listing_price%&c (purse holds: &6%#purse_coins% coins&7).");
                            return(%&enum_coins%);
                        endif;
                    endif;
                    
                    &listing_owner    = %&listing_info[7]%;
                    &listing_profile  = %&listing_info[8]%;
                    &listing_sbid     = %&listing_info[9]%;
                    &listing_name     = %&listing_info[10]%;
                    &listing_mcid     = %&listing_info[11]%;
                    #listing_data    := %&listing_info[12]%;
                    #listing_stack   := %&listing_info[13]%;
                    &listing_buyers   = %&listing_info[14]%;
                    
                    if(%&listing_type% == "BIN");
                        #listing_confirm_bid_slot = 31;
                    elseif(%&listing_type% == "AUCTION");
                        #listing_confirm_bid_slot = 29;
                        #listing_edit_bid_slot    = 31;
                    endif;
                    
                    if(%&auction_id% == "");
                        &auction_id = %&listing_id%;
                    endif;
                endif;
                
                // Unset CHATFILTER Global Variables that will be used to gauge whether our Operation(s) have been successful or not.
                if(true);
                    &init_unset_pointers[]  = split(", ","@auction_house_error, @cannot_use_ah, @ah_failure, @ah_confirm, @&ah_failure_string");
                    &okay_if_set_pointers[] = split(", ","@ah_confirm");
                    &fail_if_set_pointers[] = split(", ","@auction_house_error, @cannot_use_ah, @ah_failure");
                    
                    foreach(&init_unset_pointers[],&init_unset_pointer,#iupi);
                        unset(%&init_unset_pointer%);
                    next;
                endif;
            endif;
            
            // Loop actions until we have successfully placed the Bid for this Auction or an incorrectable Error is encountered.
            if(true);
                // chatfilter
                    // both
                        // server is too laggy: /^This server is too laggy to use the Auction House, sorry!$/
                            // fix by switching servers somehow
                    // auction type
                        // bid amount is not sufficient: /^Your bid must be at least (?<minimumBidPrice>[\d,]+) gold!$/
                        //
                // confirm_bid_slot
                    // both
                        // cannot afford bid: /Cannot afford bid!/
                    // auction type
                        // current price of bid to be placed: /New bid: (?<currentBidPrice>[\d,]+) coins/
                        // current minimum price of bid: /Minimum bid: (?<minimumBidPrice>[\d,]+) coins/
                        // can afford bid: /Click to bid!/
                    // bin type
                        // current price of item: /Price: (?<currentBidPrice>[\d,]+) coins/
                        // can afford bid: /Click to purchase!/
                        
                // &expr_current_price = "(?:New bid|Price): (?<currentPrice>[\d,]+) coins";
                // &expr_minimum_bid   = "Minimum bid: (?<minimumPrice>[\d,]+) coins";
                &expr_current_price    = "(?:New bid|Price): ([\d,]+) coins";
                &expr_minimum_bid      = "Minimum bid: ([\d,]+) coins";
                &expr_cannot_afford    = "Cannot afford bid!";
                &expr_can_afford       = "Click to (?:bid|purchase)!";
                &expr_already_bought   = "(?:Someone else purchased the|Click to pick up) item!";
                #item_var_slot         = 13;
                do;
                    // 1. Check for Function Timeout
                    if(%do_timeout%);
                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                        if(%func_timeout%);
                            debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                            &return_string = %&enum_timeout%;
                            break;
                        endif;
                    endif;
                    
                    // 2. Check if we can place the bid.
                    if(true);
                        if(%check_pointers%);
                            #elapsed_sec   = %TIMESTAMP% - %#check_pointer_time%;
                            check_pointers = %#elapsed_sec% <= 3;
                        else;
                            // 2a. Get into the Listing GUI.
                            if(true);
                                open_listing_gui = ((%GUI% != "GUICHEST") || (!%item_vars_set%));
                                if(!%open_listing_gui%);
                                    &updated_item_var_item = getslotitemnbt(%#item_var_slot%,,#updated_item_var_stack,#updated_item_var_data,&updated_item_var_nbt);
                                    &updated_item_var_nbt  = strip(%&updated_item_var_nbt%);
                                    if(%&updated_item_var_item% != "air");
                                        &updated_item_var_nbt = encode(%&updated_item_var_nbt%);
                                        open_listing_gui      = %&updated_item_var_nbt% != %&item_var_nbt%;
                                    else;
                                        &updated_var_cstring = getContainerString();
                                        open_listing_gui     = %&updated_var_cstring% != %&item_var_cstring%;
                                    endif;
                                endif;
                                
                                if(%open_listing_gui%);
                                    // Save the state of our Pointers so we can restore them afterwards.
                                    foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                                        &saved_state[%#iup%] = "%%&init_unset_pointer%%";
                                    next;
                                    
                                    // Get into the Listing GUI.
                                    if(true);
                                        #recursive_timeout  = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        &opened_listing_gui = auctionsOpenListing(%&auction_id%,&listing_info[],%#tick_wait%,%#recursive_timeout%);
                                        if(%&opened_listing_gui% != "SUCCESS");
                                            debug_error(%debug%,%&script_debug_name%,"Failed to enter Auction Listing GUI: '&4%&opened_listing_gui%&c'.");
                                            &return_string = %&opened_listing_gui%;
                                            break;
                                        endif;
                                    
                                        // Update the item variables so we can skip auctionsOpenListing calls if we are in the correct GUI going forward.
                                        if(true);
                                            &item_var_cstring = getContainerString();
                                            &item_var_item    = getslotitemnbt(%#item_var_slot%,,#item_var_stack,#item_var_data,&item_var_nbt);
                                            &item_var_nbt     = strip(%&item_var_nbt%);
                                            if(%&item_var_item% != "air");
                                                &item_var_nbt = encode(%&item_var_nbt%);
                                                item_vars_set = true;
                                            endif;
                                        endif;
                                    endif;
                                    
                                    // Restore the state of our Pointers.
                                    foreach(&init_unset_pointers[],&init_unset_pointer,#iup);
                                        &saved_state = %&saved_state[%#iup%]%;
                                        set(%&init_unset_pointer%,%&saved_state%);
                                    next;
                                endif;
                            endif;
                            
                            // 2b. Handle bid place / correction logic
                            if(true);
                                &listing_confirm_bid_item = getslotitemnbt(%#listing_confirm_bid_slot%,,,,&listing_confirm_bid_nbt);
                                &listing_confirm_bid_nbt  = strip(%&listing_confirm_bid_nbt%);
                                should_click              = false;
                                
                                // If the confirm bid item is not air (if it is air, then we probably already have it in our Mouse), then we should do some checks.
                                if(%&listing_confirm_bid_item% != "air");
                                    
                                    &current_price    = _matchExpressionNBT(%&listing_confirm_bid_nbt%,%&expr_current_price%);
                                    #current_price   := regexreplace(&current_price,",");
                                    can_place_bid     = regexTest(%&listing_confirm_bid_nbt%,%&expr_can_afford%);
                                    cannot_afford_bid = regexTest(%&listing_confirm_bid_nbt%,%&expr_cannot_afford%);
                                    already_purchased = regexTest(%&listing_confirm_bid_nbt%,%&expr_already_bought%);
                                    should_place_bid  = (((%can_place_bid%) && (!%already_purchased%)) && ((!%do_custom_bid%) || (%#current_price% == %#bid_amount%)));
                                    if(%should_place_bid%);
                                        // Can place Bid, go ahead and do so.
                                        debug_log(%debug%,%&script_debug_name%,"Can place Bid, going ahead and doing so.");
                                        
                                        #click_slot = %#listing_confirm_bid_slot%;
                                        for(confirm_bid_loop,0,1);
                                            if(%confirm_bid_loop%);
                                                #click_slot = findItemContainer(false,"MCID: stained_hardened_clay","NAME: Confirm");
                                                if(%#click_slot% == -1);
                                                    debug_error(%debug%,%&script_debug_name%,"Could not find Confirm Click slot!");
                                                    break;
                                                endif;
                                            endif;
                                            
                                            &init_gui       = getContainerString();
                                            #waited_ticks   = 0;
                                            entered_new_gui = false;
                                            debug_log(%debug%,%&script_debug_name%,"Will attempt to click &d%#click_slot%&7 until GUI updates.");
                                            do;
                                                // 1. Check for Function Timeout
                                                if(%do_timeout%);
                                                    func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                                    if(%func_timeout%);
                                                        debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                                                        &return_string = %&enum_timeout%;
                                                        break;
                                                    endif;
                                                endif;
                                                
                                                // 2. Check if we have entered a new GUI
                                                entered_new_gui = enteredNewGUI(%&init_gui%);
                                                if(%entered_new_gui%);
                                                    break;
                                                endif;
                                                
                                                // 3. Check if we can/should click
                                                can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                                                if(%can_click%);
                                                    slotclick(%#click_slot%);
                                                endif;
                                                
                                                inc(#waited_ticks);
                                                wait("1t");
                                            until((%&return_string% != "") || (%entered_new_gui%));
                                            
                                            if(%&return_string% != "");
                                                break;
                                            elseif((%entered_new_gui%) && (%confirm_bid_loop%));
                                                check_pointers      = true;
                                                #check_pointer_time = %TIMESTAMP%;
                                            endif;
                                        next;
                                    elseif((%do_custom_bid%) && (%#current_price% != %#bid_amount%));
                                        // Cannot place Bid because the Current Price is not equal to the Bid Amount we are trying to set.
                                        debug_log(%debug%,%&script_debug_name%,"Cannot place Bid because the Current Price of the Auction (&6%#current_price% coins&7) is not equal to the Custom Bid Amount we are trying to set it to (&6%#bid_amount% coins&7).");
                                        &listing_edit_bid_item = getslotitemnbt(%#listing_edit_bid_slot%,,,,&listing_edit_bid_nbt);
                                        &listing_edit_bid_nbt  = strip(%&listing_edit_bid_nbt%);
                                        if(%&listing_edit_bid_item% == "gold_ingot");
                                            #click_slot     = %#listing_edit_bid_slot%;
                                            &init_gui       = getContainerString();
                                            #waited_ticks   = 0;
                                            entered_new_gui = false;
                                            
                                            // Click until the GUI Updates.
                                            if(true);
                                                debug_log(%debug%,%&script_debug_name%,"Will edit Bid amount. Clicking slot &d%#click_slot%&7 until GUI updates.");
                                                do;
                                                    // 1. Check for Function Timeout
                                                    if(%do_timeout%);
                                                        func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                                        if(%func_timeout%);
                                                            debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                                                            &return_string = %&enum_timeout%;
                                                            break;
                                                        endif;
                                                    endif;
                                                    
                                                    // 2. Check if we have entered a new GUI
                                                    entered_new_gui = enteredNewGUI(%&init_gui%);
                                                    if(%entered_new_gui%);
                                                        break;
                                                    endif;
                                                    
                                                    // 3. Check if we can/should click
                                                    can_click = canDoInteraction(%#waited_ticks%,%#tick_wait%);
                                                    if(%can_click%);
                                                        slotclick(%#click_slot%);
                                                    endif;
                                                    
                                                    inc(#waited_ticks);
                                                    wait("1t");
                                                until((%&return_string% != "") || (%entered_new_gui%));
                                                
                                                if(%&return_string% != "");
                                                    break;
                                                endif;
                                                
                                                if(%GUI% == "GUIEDITSIGN");
                                                    debug_log(%debug%,%&script_debug_name%,"Got into Bid Amount GUI. Typing: '&d%#bid_amount%&7'.");
                                                    wait("2t");
                                                    type(%#bid_amount%);
                                                    wait("2t");
                                                    press("escape");
                                                    debug_log(%debug%,%&script_debug_name%,"Waiting to re-enter Chest GUI...");
                                                    do;
                                                        // 1. Check for Function Timeout
                                                        if(%do_timeout%);
                                                            func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
                                                            if(%func_timeout%);
                                                                debug_error(%debug%,%&script_debug_name%,"Function has timed out");
                                                                &return_string = %&enum_timeout%;
                                                                break;
                                                            endif;
                                                        endif;
                                                        
                                                        wait("1t");
                                                    until((%&return_string% != "") || (%GUI% == "GUICHEST"));
                                                    if(%&return_string% != "");
                                                        break;
                                                    endif;
                                                else;
                                                    debug_error(%debug%,%&script_debug_name%,"Did not enter the Bid Amount GUI? GUI: &4%GUI%&7, CONTAINERNAME: &4%CONTAINERNAME%&7, CONTAINERSLOTS: &4%CONTAINERSLOTS%&7.");
                                                endif;
                                            endif;
                                        else;
                                            debug_log(%debug%,%&script_debug_name%,"Cannot edit Bid because Edit Bid Item (&&listing_edit_bid_item: '&e%&listing_edit_bid_item%&7') is not 'gold_ingot'.");
                                        endif;
                                    elseif(%cannot_afford_bid%);
                                        // Cannot place Bid because we cannot afford the cost of the Auction.
                                        debug_error(%debug%,%&script_debug_name%,"Cannot place Bid because we cannot afford it.");
                                        if(%refill_coins%);
                                            #purse_coins   = getPurseCoins();
                                            #refill_coins  = %#current_price% - %#purse_coins%;
                                            coins_refilled = refillCoins(%#refill_coins%);
                                        endif;
                                        
                                        if(!%coins_refilled%);
                                            debug_error(%debug%,%&script_debug_name%,"Could not refill enough Coins to afford to cover the cost of the Bid.");
                                            &return_string = %&enum_coins%;
                                            break;
                                        endif;
                                        debug_log(%debug%,%&script_debug_name%,"Successfully refilled enough Coins to afford to cover the cost of the Bid: &6%#current_price% coins&7.");
                                    elseif(%already_purchased%);
                                        // Cannot place Bid because someone has already Purchased it.
                                        &return_string = %&enum_expired%;
                                        debug_error(%debug%,%&script_debug_name%,"Someone has already purchased this Auction. Cannot place Bid.");
                                        break;
                                    else;
                                        // Cannot place Bid because of some other reason, i.e. the Server is closing soon.
                                        &return_string = %&enum_unknown%;
                                        setclipboard(%&listing_confirm_bid_nbt%);
                                        debug_breakpoint(%debug%,%&script_debug_name%,"Cannot place Bid for an unknown reason, maybe the Server is closing soon? NBT: &d%&listing_confirm_bid_nbt%");
                                        break;
                                    endif;
                                endif;
                            endif;
                        endif;
                    endif;
                    
                    // 3. Check if any of our okay/fail pointers have been set
                    if(true);
                        // 3a. Check if any okay pointer has been set
                        if(true);
                            foreach(&okay_if_set_pointers[],&okay_if_set_pointer,#opi);
                                okay_if_set_value := "%%&okay_if_set_pointer%%";
                                if(%okay_if_set_value%);
                                    &return_string = %&enum_success%;
                                    debug_log(%debug%,%&script_debug_name%,"success pointer &d%&okay_if_set_pointer%&7 set!");
                                    break;
                                endif;
                            next;
                            
                            if(%&return_string% != "");
                                break;
                            endif;
                        endif;
                        
                        // 3b. Check if the Auction House is now closed
                        if(%TIMESTAMP% < %@#ah_closed_timestamp%);
                            debug_error(%debug%,%&script_debug_name%,"Auction House is currently closed, cannot place bids!");
                            &return_string = %&enum_unavailable%;
                            break;
                        endif;
                        
                        // 3c. Check if any fail pointer has been set
                        if(true);
                            for(do_break,0,1);
                                if(!%do_break%);
                                    found_failure = false;
                                    unset(&failed_pointers[]);
                                    unset(&string_pointers[]);
                                    foreach(&fail_if_set_pointers[],&fail_if_set_pointer,#fpi);
                                        fail_if_set_value := "%%&fail_if_set_pointer%%";
                                        &safe_pointer      = regexreplace(&fail_if_set_pointer,"(?<!&)&\w","&$1");
                                        if(%fail_if_set_value%);
                                            found_failure      = true;
                                            &failed_pointers[] = %&fail_if_set_pointer%;
                                            &string_pointers[] = "&7%&safe_pointer%&7: '&4true&7'";
                                        else;
                                            &string_pointers[] = "&7%&safe_pointer%&7: '&8false&7'";
                                        endif;
                                    next;
                                else;
                                    if(!%found_failure%);
                                        break;
                                    endif;
                                    
                                    &string_pointers           = join(", ",&string_pointers[]);
                                    #cannot_use_ah_index       = indexof(&failed_pointers[],,"@cannot_use_ah");
                                    #auction_house_error_index = indexof(&failed_pointers[],,"@auction_house_error");
                                    #ah_failure_index          = indexof(&failed_pointers[],,"@ah_failure");
                                    &failure_string            = %@&ah_failure_string%;
                                    debug_error(%debug%,%&script_debug_name%,"a failure pointer is set! Pointer values: %&string_pointers%");
                                    
                                    &error_type   = "UNKNOWN";    // UNKNOWN, INVALID_AUCTION, INVALID_BID
                                    &error_action = "RETRY";      // CANCEL, RETRY
                                    
                                    if(%#ah_failure_index% != -1);
                                        debug_log(%debug%,%&script_debug_name%,"Failure string is '&4%&failure_string%&7'.");
                                        // ifmatches(%&failure_string%,"There was an error with the auction house!.*(?:Error: |\()(?<auctionErrorCode>\w+)(?:\.|\))$",&failure_code,1);
                                        ifmatches(%&failure_string%,"(?:Failed to claim bid!|There was an error with the auction house!).*?(?:Error: |\()(\w+)(?:\.|\))",&failure_code,1);
                                            if(%&failure_code% == "INVALID_BID");
                                                // Bid price changed mid-bid
                                                &error_type   = "INVALID_BID";
                                                &error_action = "RETRY";
                                                debug_log(%debug%,%&script_debug_name%,"failure_code is '&4%&failure_code%&7', Bid Amount is invalid. Will retry.");
                                            elseif((%&failure_code% == "NOT_FOUND_OR_ALREADY_CLAIMED") || (%&failure_code% == "AUCTION_EXPIRED_OR_NOT_FOUND"));
                                                // Auction is no longer valid
                                                &error_type   = "INVALID_AUCTION";
                                                &error_action = "CANCEL";
                                                debug_log(%debug%,%&script_debug_name%,"failure_code is '&4%&failure_code%&7', Auction is invalid. Will cancel.");
                                            else;
                                                debug_error(%debug%,%&script_debug_name%,"Unknown Error Code: '&4%&failure_code%&c'! Will do recursive call to self.");
                                                logto("ah_unknown_error_codes.txt","[%DATETIME%]: Error Code '%&failure_code%', Error String %&failure_string%");
                                                &error_type   = "UNKNOWN";
                                                &error_action = "RETRY";
                                            endif;
                                        elseifmatches(%&failure_string%,"There was an error with the auction house!");
                                            // Generic Error, cannot know what went wrong.
                                            &error_action = "RETRY";
                                            &error_type   = "UNKNOWN";
                                            debug_error(%debug%,%&script_debug_name%,"Generic Error: '&4%&failure_string%&c'! Will do recursive call to self.");
                                        //elseifmatches(%&failure_string%,"Your bid must be at least (?<listingMinPrice>[\d,.]+) gold!",&listing_min_price,1);
                                        elseifmatches(%&failure_string%,"Your bid must be at least ([\d,.]+) gold!",&listing_min_price,1);
                                            // Bid Price is too low.
                                            &error_type         = "INVALID_BID";
                                            &error_action       = "CANCEL";
                                            #listing_min_price := regexreplace(&listing_min_price,",","");
                                            debug_error(%debug%,%&script_debug_name%,"Minimum bid price is '&4%#listing_min_price%&c' coins. Will cancel.");
                                        elseifmatches(%&failure_string%,"Couldn't read this number!");
                                            // Invalid input.
                                            &error_type   = "INVALID_BID";
                                            &error_action = "RETRY";
                                            debug_log(%debug%,%&script_debug_name%,"Failure string is '&4%&failure_string%&7', Bid Amount is Invalid. Will do recursive call to self.");
                                        elseifmatches(%&failure_string%,"You didn't participate in this auction!");
                                            // Auction is no longer valid.
                                            &error_type   = "INVALID_AUCTION";
                                            &error_action = "CANCEL";
                                            debug_log(%debug%,%&script_debug_name%,"Failure string is '&4%&failure_string%&7', Auction is Invalid. Will cancel.");
                                        endif;
                                    elseif(%#cannot_use_ah_index% != -1);
                                        // Might just have to change Servers
                                        debug_error(%debug%,%&script_debug_name%,"Error type is '&4@cannot_use_ah&c', will try to change Servers and if successful, will do recursive call to self.");
                                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        &swap_result       = swapServers(%#tick_wait%,%#recursive_timeout%);
                                        
                                        if(%&swap_result% != "SUCCESS");
                                            debug_error(%debug%,%&script_debug_name%,"swapServers returned error '&4%&swap_result%&c', will return this error code.");
                                            &return_string = %&swap_result%;
                                            &error_action  = "CANCEL";
                                        else;
                                            &error_action  = "RETRY";
                                            debug_log(%debug%,%&script_debug_name%,"swapServers completed successfully. Will do recursive call to self.");
                                        endif;
                                    elseif(%#auction_house_error_index% != -1);
                                        // Might just have to try again
                                        debug_error(%debug%,%&script_debug_name%,"An auction house error occurred. Will do recursive call to self.");
                                    endif;
                                    
                                    debug_error(%debug%,%&script_debug_name%,"Error Action: '&e%&error_action%&c'. Error Type: '&4%&error_type%&c'. Error String: '&4%&failure_string%&c'.");
                                    if((%&return_string% == "") && (%&error_action% == "CANCEL"));
                                        &error_enum_map_terms[]    = split(", ","UNKNOWN, INVALID_BID, INVALID_AUCTION");
                                        &error_enum_map_enums[]    = split(", ","%&enum_unknown%, %&enum_bid_amount%, %&enum_expired%");
                                        #error_enum_map_term_index = indexof(&error_enum_map_terms[],,%&error_type%);
                                        &return_string             = %&error_enum_map_terms[%#error_enum_map_term_index%]%;
                                        debug_log(%debug%,%&script_debug_name%,"will return error_enum '&4%&return_string%&7' due to encountering error_type '&4%&error_type%&7' with CANCEL action");
                                    elseif(%&error_action% == "RETRY");
                                        debug_log(%debug%,%&script_debug_name%,"running self-recursion call, error_action is RETRY, type is '&4%&error_type%&7'.");
                                        #recursive_timeout = getNewTimeoutSec(%#start_time%,%#timeout_sec%,%do_timeout%);
                                        &return_string     = call("auctionsPlaceBid",%&listing_id%,%#bid_amount%,%refill_coins%,%allow_command%,%#tick_wait%,%#recursive_timeout%);
                                        debug_log(%debug%,%&script_debug_name%,"got return_string '&e%&return_string%&7' from recursion call, breaking");
                                    endif;
                                    break;
                                endif;
                            next;
                            
                            if(%&return_string% != "");
                                break;
                            endif;
                        endif;
                    endif;
                    
                    wait("1t");
                    inc(#total_ticks);
                until(%&return_string% != "");
            endif;
            
            debug_log(%debug%,%&script_debug_name%,"returning '&e%&return_string%&7'.");
            return(%&return_string%);
        endfunction;
//! @mkb-import-end