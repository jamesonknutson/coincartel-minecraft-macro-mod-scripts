// info/index.txt
	// Used to determine whether to timeout a function.
		// Params:
			// {number} <#start_time>    	The start timestamp to subtract from current timestamp
			// {number} <#timeout_sec>   	The amount of seconds to check if difference between now & start is >=.
			// {number} [do_timeout=true]	If false, will always return false (used as shorthand for functions that
			//                           	use this function to determine whether or not they have timed out).
		// Returns a boolean indicating whether or not <#start_timestamp> was >= <#seconds> ago.
		// Example:
			//	func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
	function hasTimeExceeded(#start_time,#timeout_sec,do_timeout=true);
		#elapsed_sec   = %TIMESTAMP% - #start_time;
		return_boolean = ((%do_timeout%) && (#elapsed_sec >= #timeout_sec));
		return(%return_boolean%);
	endfunction;
	
	// Checks if a number is <= min && >= max.
		// Params:
		//      {number} <#number>  The number to check if is between min && max.
		//      {number} <#min>     The minimum value for <#number>
		//      {number} <#max>     The maximum value for <#number>
		//
		// Returns a boolean indicating whether or not the number is between the specified values.
	function withinBounds(#number,#min,#max);
		return_boolean = ((#number >= #min) && (#number <= #max));
		return(%return_boolean%);
	endfunction;
	
	// Used by getItemName, getItemUUID, getItemSBID to extract a regular expression capture group from NBT Data.
		// Params:
		//      {string} <&haystack>    The string to extract the first capture group from.
		//      {string} <&expression>  The expression to test against <&haystack>, must have at least one capture group.
		//
		// Returns the first capture group's content from the <&expression> match, or an empty string if no match is found.
	function _matchExpressionNBT(&haystack,&expr);
		&return_string = "";
		ifmatches(%&haystack%,%&expr%,&capture_group,1);
			&return_string = %&capture_group%;
		endif;
		return(%&return_string%);
	endfunction;
	
	// Given the NBT Data of an Item (and optionally it's base item), extracts the Display Name of the Item from the NBT Data.
		// Params:
		//      {string} <&nbt>         The NBT Data to extract the Name from.
		//      {string} [&item="air"]  The Item this NBT Data was collected from (only used in cases where the Item's Name cannot be found).
		//      {boolean} [strip=true]  Whether or not to strip formatting codes from the extracted Name.
		//
		// Returns the Display Name of the Item found from it's NBT Data, with formatting codes stripped if [strip] is true.
	function getItemName(&nbt,&item="air",strip=true);
		ifmatches(%&nbt%,".*\bName\s*:\"\s*(.*?)\"",&found_name,1);
			if(%strip%);
				&found_name = strip(%&found_name%);
			endif;
		elseif(%&item% == "air");
			&found_name = "Air";
		endif;
		return(%&found_name%);
	endfunction;
	
	// Given an item's raw NBT data, returns the rarity level of the Item.
		// Params:
			// {string} <&raw_nbt>             	The Raw NBT Data of the Item (unstripped).
			// {string} [&return_type="number"]	String ENUM of: number, string, color
		// Returns a different type depending on [&return_type] value:
			// number: A number (0 = common, 8 = very special)
			// string: A string (COMMON, UNCOMMON, RARE, EPIC, LEGENDARY, MYTHIC, DIVINE, SPECIAL, VERY SPECIAL)
			// color : A color code (7 = common, a = uncommon, 9 = rare, 5 = epic, 6 = legendary, d = mythic, b = divine, c = special, c = very special)
	function getItemRarity(&raw_nbt,&return_type="number");
		&item_name = getItemName(%&raw_nbt%,"air","false");
		ifmatches(%&item_name%,"^\xa7(\w)",&color_code,1);
			&color_codes[] = split(", ","7, a, 9, 5, 6, d, b, c, c");
			&color_names[] = split(", ","COMMON, UNCOMMON, RARE, EPIC, LEGENDARY, MYTHIC, DIVINE, SPECIAL, VERY SPECIAL");
			#color_index   = indexof(&color_codes[],,%&color_code%);
			if(#color_index != -1);
				if(%&return_type% == "number");
					return(%#color_index%);
				elseif(%&return_type% == "string");
					return(%&color_names[%#color_index%]%);
				elseif(%&return_type% == "color");
					return(%&color_code%);
				endif;
			endif;
		endif;
		return(-1);
	endfunction;

	// Given the NBT Data of an Item, extracts the Item's UUID from the NBT Data.
		// Params:
		//      {string} <&nbt> The NBT Data to extract the Item UUID from.
		//
		// Returns the Item's UUID, or an empty string if one is not found.
	function getItemUUID(&nbt);
		&nbt           = strip(%&nbt%);
		&return_string = _matchExpressionNBT(%&nbt%,"uuid:\"(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})\"");
		return(%&return_string%);
	endfunction;

	// Given the NBT Data of an Item, extracts the Item's SBID from the NBT Data.
		// Params:
		//      {string} <&nbt> The NBT Data to extract the Item SBID from.
		//
		// Returns the Item's SBID, or an empty string if one is not found.
	function getItemSBID(&nbt);
		&nbt           = strip(%&nbt%);
		&return_string = _matchExpressionNBT(%&nbt%,"\bid\"?\s*:\"([A-Z_0-9:]+)\"");
		return(%&return_string%);
	endfunction;
	
	// Given an Item's Display Name or SBID, looks it up in the global arrays @&sb_datamap_item_names[] and/or
	// @&sb_datamap_item_sbids[], then returns the Data found at that index accordingly.
		// Params:
			//	{string} 	<&search_term>           	The Item's Display Name or SBID to search for.
			//	{boolean}	[return_collection=false]	Whether or not to append Collection information to the returned Array.
			//
		// Returns an Array -- first element will be -1 if no match was found.
			//	0	{string} 	&found_name    	The Display Name of the Item found
			//	1	{string} 	&found_sbid    	The SBID of the Item found
			//	2	{string} 	&found_mcid    	The MCID of the Item found
			//	3	{number} 	#found_data    	The Data value of the Item found (0 = no data).
			//	4	{number} 	#found_sell    	The Sell Price of the Item found (0 = not sellable).
			//	5	{number} 	#found_stack   	The maximum stack size of the Item found
			//	6	{string} 	&found_tier    	The Tier of this Item ("" = no Tier, valid strings = COMMON, UNCOMMON, RARE, EPIC, LEGENDARY, MYTHIC, SPECIAL)
			//	7	{string} 	&found_category	The Category of this Item ("" = no Category, valid strings = ACCESSORY, ARROW, ARROW_POISON, AXE, BAIT, BOOTS,
			//	 	         	               	BOW, CHESTPLATE, COSMETIC, DRILL, DUNGEON_PASS, FISHING_ROD, FISHING_WEAPON, GAUNTLET, HELMET, HOE, LEGGINGS,
			//	 	         	               	PET_ITEM, PICKAXE, REFORGE_STONE, SHEARS, SPADE, SWORD, TRAVEL_SCROLL, WAND).
			//	8	{boolean}	found_bazaar   	Whether or not the Item is available for trading on Bazaar.
			//	
			//
			// The following elements will also be returned if [return_collection] is set to True.
				//	9 	{boolean}	has_collection     	Whether or not the Item belongs to a Collection
				//	10	{string} 	&collection_name   	The Name of the Collection this Item belongs to ("NULL" = no collection).
				//	11	{string} 	&collection_cmdname	The Command String (used in /viewcollection <&collection_cmdname>) to directly enter this Collection.
				//	  	         	                   	"NULL" = no collection.
				//	12	{string} 	&collection_sbid   	The SBID of the Base Item in this Collection.
				//	13	{number} 	#collection_tier   	The Tier of the Collection this Item belongs to (0 = no collection).
				//	14	{number} 	#collection_amt    	The Amount of Items required to have been Collected in order for this Item to be unlocked.
				//	  	         	                   	0 = no collection.
		// Example:
			// Without Collection Appended
				//	&item_data[]    = getItemInfoSB("ENCHANTED_DIAMOND_BLOCK");
				//	&found_name     = %&item_data[0]%;
				//	&found_sbid     = %&item_data[1]%;
				//	&found_mcid     = %&item_data[2]%;
				//	#found_data    := %&item_data[3]%;
				//	#found_sell    := %&item_data[4]%;
				//	#found_stack   := %&item_data[5]%;
				//	&found_tier     = %&item_data[6]%;
				//	&found_category = %&item_data[7]%;
				//	found_bazaar   := %&item_data[8]%;
			// With Collection Appended
				//	&item_data[]        = getItemInfoSB("ENCHANTED_DIAMOND_BLOCK",true);
				//	&found_name         = %&item_data[0]%;
				//	&found_sbid         = %&item_data[1]%;
				//	&found_mcid         = %&item_data[2]%;
				//	#found_data        := %&item_data[3]%;
				//	#found_sell        := %&item_data[4]%;
				//	#found_stack       := %&item_data[5]%;
				//	&found_tier         = %&item_data[6]%;
				//	&found_category     = %&item_data[7]%;
				//	found_bazaar       := %&item_data[8]%;
				//	has_collection     := %&item_data[9]%;
				//	&collection_name    = %&item_data[10]%;
				//	&collection_cmdname = %&item_data[11]%;
				//	&collection_sbid    = %&item_data[12]%;
				//	#collection_tier   := %&item_data[13]%;
				//	#collection_amt    := %&item_data[14]%;
	function getItemInfoSB(&search_term,return_collection=false);
		// Find the Index of the Data we are retrieving.
		if(true);
			#name_index = indexof(@&sb_datamap_item_names[],,%&search_term%);
			#sbid_index = indexof(@&sb_datamap_item_sbids[],,%&search_term%);
			if((#name_index == -1) && (#sbid_index == -1));
				&return_array[] = "-1";
				return(&return_array[]);
			elseif(%#sbid_index% != -1);
				#use_index = %#sbid_index%;
			elseif(%#name_index% != -1);
				#use_index = %#name_index%;
			endif;
		endif;
		
		// Extract Data from the JSON Element located at the found Index.
		if(true);
			&found_json      = %@&sb_datamap_item_jsons[%#use_index%]%;
			&return_array[0] = jsonget("name",%&found_json%);
			&return_array[1] = jsonget("sbid",%&found_json%);
			&return_array[2] = jsonget("mcid",%&found_json%);
			&return_array[3] = jsonget("data",%&found_json%);
			&return_array[4] = xJsonGet("sellPrice",%&found_json%);
			&return_array[5] = jsonget("maxStack",%&found_json%);
			&return_array[6] = jsonget("tier",%&found_json%);
			&return_array[7] = jsonget("category",%&found_json%);
			&return_array[8] = jsonget("onBazaar",%&found_json%);
			if(%return_collection%);
				&collection_json = jsonget("collection",%&found_json%);
				has_collection   = jsonget("hasCollection",%&collection_json%);
				&return_array[9] = %has_collection%;
				if(%has_collection%);
					&collection_name  = jsonget("name",%&collection_json%);
					&return_array[10]  = %&collection_name%;
					#coll_ext_index   = indexof(@&sb_datamap_collection_names[],,%&collection_name%);
					&coll_ext_json    = %@&sb_datamap_collection_jsons[%#coll_ext_index%]%;
					&return_array[11]  = jsonget("cmdName",%&coll_ext_json%);
					&return_array[12] = jsonget("sbid",%&coll_ext_json%);
					#collection_tier  = jsonget("tier",%&collection_json%);
					#collection_idx   = %#collection_tier% - 1;
					&return_array[13] = %#collection_tier%;
					&return_array[14] = xJsonGet("tiers.%#collection_idx%.amountRequired",%&coll_ext_json%);
					return(&return_array[]);
				endif;
				&return_array[10]  = "NULL";
				&return_array[11] = "NULL";
				&return_array[12] = "NULL";
				&return_array[13] = "0";
				&return_array[14] = "0";
				return(&return_array[]);
			endif;
			return(&return_array[]);
		endif;
	endfunction;
	
	// Given an Item's ID and Damage Value, joins them together with a <:{#item_damage}> suffix.
	// If the string already has a damage value suffix, it will not join it with the <#item_damage>
	// value UNLESS always_join is false, the damage value on the string at default is 0, and the damage
	// value passed is > 0. If the damage value passed is 0, and always_join is false, it will not join
	// the string together. If the damage value passed is > 0, it will join the string together.
		// Params:
			//	{string} <&item_id>          	The Item's ID.
			//	{number} [#item_damage]      	The Item's Damage.
			//	{boolean} [always_join=false]	Whether or not to always join the Item ID with the Damage Value,
			//	                             	regardless of whether or not the Damage Value == 0.
	function getItemFull(&item_id,#item_damage=0,always_join=false);
		&return_string = %&item_id%;
		ifmatches(%&return_string%,"(.+):(\d+)$");
			match(%&return_string%,"(.+):(\d+)$",{&base_id,#base_damage});
			
			if(%#base_damage% == 0);
				&return_string = %&base_id%;
				if(%#item_damage% > 0);
					&return_string = "%&base_id%:%#item_damage%";
				endif;
			endif;
		elseif((%always_join%) || (%#item_damage% > 0));
			&return_string = "%&item_id%:%#item_damage%";
		endif;
		return(%&return_string%);
	endfunction;
	
	// Returns an Array of information extracted from the Hypixel SkyBlock PlayerList.
		// Params:
		//      {string} [...&extract_vars[]]   The variables to extract from the Player List. Valid values are:
		//                                      'AREA', 'SERVER', 'PROFILE', 'BANK', 'SKILLS', 'SPEED', 'STRENGTH',
		//                                      'CRIT_CHANCE', 'CRIT_DAMAGE', 'ATTACK_SPEED'. If no values are provided,
		//                                      will return variables 'AREA', and 'PROFILE' by default.
		//
		// Returns an Array of the extracted variables indexed in the order they were passed to the Function,
		// or if no variables were able to be extracted, the first element of this Array will be -1.
	function getSkyBlockPlayerListInfo(...&extract_vars[]);
		// Setup valid variables
		if(true);
			&valid_vars[]  = split(", ","AREA, SERVER, PROFILE, BANK, SKILLS, SPEED, STRENGTH, CRIT_CHANCE, CRIT_DAMAGE, ATTACK_SPEED");
			#extract_len   = arraysize(&extract_vars[]);
			assign_default = #extract_len == 0;
			if(!%assign_default%);
				foreach(&valid_vars[],&valid_var);
					#extract_idx = indexof(&extract_vars[],,%&valid_var%);
					if(#extract_idx != -1);
						&use_out_vars[] = %&valid_var%;
						#use_out_idxs[] = %#extract_idx%;
						matched[]       = false;
					endif;
				next;
				#use_out_len   = arraysize(&use_out_vars[]);
				assign_default = #use_out_len == 0;
			endif;
			
			if(!%assign_default%);
				sort("ASC",#use_out_idxs[],&use_out_vars[]);
			else;
				&use_out_vars[] = split(", ","AREA, PROFILE");
				matched[]       = split(", ","false, false");
			endif;
		endif;
		
		// Compile matches
		if(true);
			#return_index = indexof(&use_out_vars[],,"AREA");
			if(#index_area != -1);
				&match_names[] = "!C-b";
				&match_exprs[] = "Area: (.+)"; // Area: Private Island
			endif;
			
			#return_index = indexof(&use_out_vars[],,"SERVER");
			if(#return_index != -1);
				&match_names[%#return_index%] = "!C-c";
				&match_exprs[%#return_index%] = "Server: (.+)"; // Server: mini787Q
			endif;
			
			#return_index = indexof(&use_out_vars[],,"PROFILE");
			if(#return_index != -1);
				&match_names[%#return_index%] = "!D-b";
				&match_exprs[%#return_index%] = "Profile: (.+)"; // Profile: Pineapple
			endif;
			
			#return_index = indexof(&use_out_vars[],,"BANK");
			if(#return_index != -1);
				&match_names[%#return_index%] = "!D-d";
				&match_exprs[%#return_index%] = "Bank: (.+)"; // Bank: 50/50
			endif;
			
			#return_index = indexof(&use_out_vars[],,"SKILLS");
			if(#return_index != -1);
				&match_names[%#return_index%] = "!D-g";
				&match_exprs[%#return_index%] = "Skills: (.+)"; // Skills: Foraging 17: 24.1%
			endif;
			
			#return_index = indexof(&use_out_vars[],,"SPEED");
			if(#return_index != -1);
				&tmp_expr_char                = char("10022");
				&match_names[%#return_index%] = "!D-h";
				&match_exprs[%#return_index%] = "Speed: %&tmp_expr_char%(.+)"; // Speed: ✦220
			endif;
			
			#return_index = indexof(&use_out_vars[],,"STRENGTH");
			if(#return_index != -1);
				&tmp_expr_char                = char("10049");
				&match_names[%#return_index%] = "!D-i";
				&match_exprs[%#return_index%] = "Strength: %&tmp_expr_char%(.+)"; // Strength: ❁149
			endif;
			
			#return_index = indexof(&use_out_vars[],,"CRIT_CHANCE");
			if(#return_index != -1);
				&tmp_expr_char                = char("9763");
				&match_names[%#return_index%] = "!D-j";
				&match_exprs[%#return_index%] = "Crit Chance: %&tmp_expr_char%(.+)"; // Crit Chance: ☣64
			endif;
			
			#return_index  = indexof(&use_out_vars[],,"CRIT_DAMAGE");
			if(#return_index != -1);
				&tmp_expr_char                = char("9760");
				&match_names[%#return_index%] = "!D-k";
				&match_exprs[%#return_index%] = "Crit Damage: %&tmp_expr_char%(.+)"; // Crit Damage: ☠130
			endif;
			
			#return_index  = indexof(&use_out_vars[],,"ATTACK_SPEED");
			if(#return_index != -1);
				&tmp_expr_char                = char("9876");
				&match_names[%#return_index%] = "!D-l";
				&match_exprs[%#return_index%] = "Attack Speed: %&tmp_expr_char%(.+)"; // Attack Speed: ⚔0
			endif;
		endif;
		
		foreach("players");
			#line_index = indexof(&match_names[],,%PLAYERNAME%);
			if(#line_index != -1);
				matched[%#line_index%] = true;
				&line_text             = strip(%PLAYERDISPLAYNAME%);
				&line_text             = trim(%&line_text%);
				ifmatches(%&line_text%,%&match_exprs[%#line_index%]%,&capture_group,1);
					&return_array[%#line_index%] = %&capture_group%;
					#non_matched_var_index       = indexof(matched[],,false);
					if(#non_matched_var_index == -1);
						break;
					endif;
				endif;
			endif;
		next;
		
		#return_len = arraysize(&return_array[]);
		if(#return_len == 0);
			&return_array[] = -1;
		endif;
		return(&return_array[]);
	endfunction;
	
	// Attempts to read the Scoreboard (foreach("teams") ... prefix + suffix ... next) to find the Player's location on Hypixel
		// Params:
		//      None
		//
		// Returns one of the following strings: 'LOBBY', 'SKYBLOCK', or 'OTHER'. 'OTHER' indicates that the function
		// was not able to determine which area the Player is located in.
	function getHypixelGamemodeFromScoreboard();
		&return_string = "OTHER";
		
		// Setup indicator strings
		if(true);
			&match_expr[] = "Games in this lobby are"; // Only shown in Prototype Lobby Servers
			&match_area[] = "LOBBY";
			
			&match_expr[] = "^Achievements: .+$"; // Only shown in Hypixel Main Lobby Servers
			&match_area[] = "LOBBY";
			
			&match_expr[] = "^Purse: [0-9,.]+"; // Only shown in SkyBlock Servers
			&match_area[] = "SKYBLOCK";
			
			&match_expr[] = "^Bits: [0-9,.]+"; // Only shown in SkyBlock Servers
			&match_area[] = "SKYBLOCK";
		endif;
		
		foreach("teams");
			&joint_team = strip("%TEAMPREFIX%%TEAMSUFFIX%");
			&joint_team = trim(%&joint_team%);
			&joint_team = regexreplace(&joint_team,"^\s*","");
			foreach(&match_expr[],&match_expr,#mei);
				ifmatches(%&joint_team%,%&match_expr%);
					&return_string = %&match_area[%#mei%]%;
					break;
				endif;
			next;
		next;
		
		return(%&return_string%);
	endfunction;
	
	// Attempts to read the SkyBlock Area from the /wtfmap command + chatfilter.
		// Params:
		//      {number} [#timeout_sec=30]  Max amount of seconds to wait for Chat Filter to read the wtfmap output.
		//                                  Set to -1 to disable timeout.
		//      {number} [#wait_ticks=60]   Amount of ticks to wait between attempts to issue the command.
		//
		// Returns the String returned from the Command (i.e. "SkyBlock Dynamic"), or "-1" if cannot be found/timed out.
	function getSkyblockAreaFromWTFMAP(#timeout_sec=30,#wait_ticks=30);
		debug              = true;
		&script_debug_name = "&3getSkyBlockAreaFromWTFMAP&7";
		
		@cannot_use_wtfmap = false;
		@&wtfmap           = "";
		#start_time        = %TIMESTAMP%;
		do_timeout         = #timeout_sec != -1;
		&return_string     = "-1";
		do;
			func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
			if(%func_timeout%);
				break;
			endif;
				
			debug_log(%debug%,%&script_debug_name%,"echoing '/wtfmap'...");
			echo("/wtfmap");
			do(%#wait_ticks%);
				wait("1t");
				got_response   = ((%@&wtfmap% != "") || (%@cannot_use_wtfmap%));
			until(%got_response%);
			if((%got_response%) && (%@&wtfmap% != ""));
				&return_string = %@&wtfmap%;
				break;
			endif;
		until((%got_response%) || (%func_timeout%));
		return(%&return_string%);
	endfunction;
	
	// Attempts to read the Scoreboard to find the Player's AREA on Hypixel SkyBlock (i.e. 'Private Island', 'Hub', 'Bank', etc).
		// Params:
		//      None
		//
		// Returns the string found on the Scoreboard following the Gem Character, or "-1" if not able to be parsed.
	function getScoreboardSkyBlockArea();
		&return_string = -1;
		foreach("teams");
			&joint_team = strip("%TEAMPREFIX%%TEAMSUFFIX%");
			&joint_team = trim(%&joint_team%);
			&joint_team = regexreplace(&joint_team,"^\s*","");
			ifmatches(%&joint_team%,"\u23E3 (.+)",&found_area,1);
				&return_string = %&found_area%;
			endif;
		next;
		return(%&return_string%);
	endfunction;
	
	// Checks if the Player is in Limbo by reading the Dimension, as well as checking to see if there are any signs at the sign positions
	// where they normally are in Limbo.
		// Params:
		//      None
		//
		// Returns a boolean indicating whether or not the Player is in Limbo.
	function isInLimbo();
		if((%YPOS% > 35) || (%DIMENSION% != "END"));
			return(False);
		endif;
		
		#limbo_x = -20;
		#limbo_y = 32;
		#limbo_z = 21;
		
		if((%XPOS% == #limbo_x) && (%YPOS% == #limbo_y) && (%ZPOS% == #limbo_z));
			return(True);
		endif;
		
		&armor_vars[] = split(", ","ITEM, BOOTSID, LEGGINGSID, CHESTPLATEID, HELMID");
		all_air       = true;
		foreach(&armor_vars[],&armor_var);
			&armor_val = "%%&armor_var%%";
			if(%&armor_val% != "air");
				all_air = false;
				break;
			endif;
		next;
		if((%SLOTSFULL% == 0) && (%all_air%));
			return(True);
		endif;
		
		#sign_x   = -21;
		#sign_y[] = split(", ","31, 32, 33");
		#sign_z[] = split(", ","20, 21, 22");
		foreach(#sign_y[],#sign_y);
			foreach(#sign_z[],#sign_z);
				&block_id = getid(%#sign_x%,%#sign_y%,%#sign_z%);
				if(&block_id == "wall_sign");
					in_limbo = true;
					break;
				endif;
			next;
		next;
	endfunction;
	
	// Gets the current Gamemode / Gametype that the Player is in by reading the Scoreboard, etc.
	// Params:
	//      None
	//
	// Returns one of: 'LOBBY', 'LIMBO', 'SKYBLOCK', or 'OTHER'.
	function getHypixelGamemode();
		if(true);
			do(3);
				// Check to see if we can read the Gamemode from the 9th Hotbar Slot.
				if(true);
					#static_hb_end = 44;
					&found_item    = getslotiteminv(%#static_hb_end%,,#found_stack,#found_data,&found_nbt);
					&found_nbt     = strip(%&found_nbt%);
					&found_name    = getItemName(%&found_nbt%,%&found_item%);
					
					&known_names[] = split(", ","Lobby Selector (Right Click), SkyBlock Menu (Right Click)");
					&known_areas[] = split(", ","LOBBY, SKYBLOCK");
					#known_index   = indexof(&known_names[],,%&found_name%);
					if(%#known_index% != -1);
						&return_string = %&known_areas[%#known_index%]%;
						break;
					endif;
				endif;
				
				// Cant find the Gamemode from the 9th Hotbar Slot, have to read additional Data. Check to see if we can find any Data from the Playerlist.
				&skyblock_area = getSkyBlockPlayerListInfo("AREA");
				if(%&skyblock_area% != "-1");
					&return_string = "SKYBLOCK";
					break;
				endif;
				
				// Try to read the location from the Scoreboard.
				&scoreboard_location = getHypixelGamemodeFromScoreboard();
				if(%&scoreboard_location% != "OTHER");
					&return_string = %&scoreboard_location%;
					break;
				endif;
				
				// Check if we are in Limbo as a last resort
				in_limbo = isInLimbo();
				if(%in_limbo%);
					&return_string = "LIMBO";
					break;
				endif;
				
				wait("1000ms");
			loop;
		endif;
		
		if(%&return_string% != "");
			return(%&return_string%);
		endif;
		return("OTHER");
	endfunction;
	
	// Gets the SkyBlock Server Type that we are currently connected to. Returns SKYBLOCK_HUB, SKYBLOCK_HOME, or OTHER. OTHER is only returned if
	// the Function cannot determine whether it is on a SkyBlock Server, or if it is not on a SkyBlock Server.
		// Params:
		//      None
		//
		// Returns one of the following strings: 'SKYBLOCK_HUB', 'SKYBLOCK_HOME', 'OTHER'. 'OTHER' is returned if none of the functions return any
		// parseable values.
	function getSkyBlockArea();
		&playerlist_area = getSkyBlockPlayerListInfo("AREA");
		if(%&playerlist_area% == "-1");
			&scoreboard_area = getScoreboardSkyBlockArea();
			if(%&scoreboard_area% == "-1");
				&wtfmap_area = getSkyBlockAreaFromWTFMAP();
				if(%&wtfmap_area% == "SkyBlock Hub");
					return("SKYBLOCK_HUB");
				elseif(%&wtfmap_area% == "SkyBlock Dynamic");
					return("SKYBLOCK_HOME");
				endif;
				return("OTHER");
			elseif(%&playerlist_area% == "Your Island");
				return("SKYBLOCK_HOME");
			else;
				return("SKYBLOCK_HUB"); 
			endif;
		elseif(%&playerlist_area% == "Private Island");
			return("SKYBLOCK_HOME");
		else;
			return("SKYBLOCK_HUB");
		endif;
	endfunction;
	
	// Given an Entity Name expression (and optionally the Entity Type and/or Range), uses the Entities Iterator to find them and return their position.
		// Params:
		//      {string} <&entity_expr>         A regular expression to use in the iterator filter
		//      {string} [&entity_type]         Optional entity type to use in the iterator filter
		//      {string} [&entity_range]        Optional max range to use in the iterator filter
		//      {boolean} [return_float=false]  If set to true, will return the entity's XPOSF, YPOSF, ZPOSF instead of integers.
		//
		// Returns an Array where element 0 = XPOS[F], 1 = YPOS[F], 2 = ZPOS[F]. Will return a string array no matter what,
		// if cannot find entity the first value of this array will be an empty string.
	function getEntityPos(&entity_expr,&entity_type="",&entity_range="",return_float=false);
		&filter_terms[] = "name:%&entity_expr%";
		if(%&entity_type% != "");
			&filter_terms[] = "type:%&entity_expr%";
		endif;
		&filter_terms = join(",",&filter_terms[]);
		&filter_terms = "filter:{%&filter_terms%}"
		if(%&entity_range% != "");
			&filter_terms = "%&filter_terms%,range:%&entity_range%";
		endif;
		
		foreach("entities(%&filter_terms%)");
			if(%return_float%);
				&out_arr[] = %ENTITYXPOSF%;
				&out_arr[] = %ENTITYYPOSF%;
				&out_arr[] = %ENTITYZPOSF%;
			else;
				&out_arr[] = %ENTITYXPOS%;
				&out_arr[] = %ENTITYYPOS%;
				&out_arr[] = %ENTITYZPOS%;
			endif;
			found = true;
			break;
		next;
		
		if(!%found%);
			&out_arr[0] = "";
		endif;
		return(&out_arr[]);
	endfunction;
	
	// Returns the amount of coins in the purse, rounded to the nearest integer.
		// Params: None
		// Returns: Integer amount of Coins in the purse (returns -1 if cannot find Purse Coins).
	function getPurse();
		&return_integer = -1;
		foreach("teams");
			&scoreboard_line = strip("%TEAMPREFIX%%TEAMSUFFIX%");
			ifmatches(%&scoreboard_line%,"(?:Purse|Piggy): ([0-9,]+)",&coins,1);
				&return_integer := regexreplace(&coins,"\D","");
				break;
			endif;
		next;
		return(%&return_integer%);
	endfunction;
	
	// Proxy for a call to `getPurse`.
		// Params: None
		// Returns: Integer amount of Coins in the purse (returns -1 if cannot find Purse Coins).
	function getPurseCoins();
		&return_integer = getPurse();
		return(%&return_integer%);
	endfunction;
	
	// Determines whether the current SkyBlock Profile is a Solo or a Coop type Profile.
		// Params: None
		// Returns: {string} ENUM: COOP, SOLO, ERROR
	function getProfileType();
		// Check if we can answer our question by checking the Scoreboard.
		if(true);
			&bank_balances = getSkyBlockPlayerListInfo("BANK");
			if(%&bank_balances% != "-1");
				&split_array[] = split("/",%&bank_balances%);
				#split_array   = arraysize(&split_array[]);
				if(%#split_array% == 1);
					return("SOLO");
				elseif(%#split_array% == 2);
					return("COOP");
				endif;
			endif;
		endif;
		
		// If we could not answer our question by checking the Scoreboard, try API.
		if(true);
			&active_profile_req[]   = getActiveProfile();
			active_profile_success := %&active_profile_req[0]%;
			if(%active_profile_success%);
				&profile_members         = jsonget("members",%&active_profile_req[1]%);
				&profile_members_uuids[] = getjsonkeys(%&profile_members%);
				#profile_members_uuids   = arraysize(&profile_members_uuids[]);
				if(%#profile_members_uuids% == 1);
					return("SOLO");
				elseif(%#profile_members_uuids% > 1);
					return("COOP");
				endif;
			endif;
		endif;
		
		// If we are still bass-ackwards and out of luck, what the fuck else can we do? Try Slothpixel!
		if(true);
			// Try to get the Active Profile ID first.
			if(true);
				&active_profile_id[]    = getActiveProfileID();
				active_profile_success := %&active_profile_id[0]%;
			endif;
			
			&player_joint_uuid     = %UUID%;
			&player_joint_uuid     = regexreplace(&player_joint_uuid,"-","");
			&slothpixel_profiles[] = slothpixelGetSkyBlockProfiles();
			slothpixel_success    := %&slothpixel_profiles[0]%;
			if(%slothpixel_success%);
				#slothpixel_profiles = arraylength(&slothpixel_profiles[]);
				for(#i,1,%#slothpixel_profiles%);
					&slothpixel_profile = %&slothpixel_profiles[%#i%]%;
					&profile_id         = jsonget("id",%&slothpixel_profile%);
					if((%active_profile_success%) && (%&profile_id% == %&active_profile_id[1]%));
						&active_profile = %&slothpixel_profile%;
						break;
					elseif(!%active_profile_success%);
						&profile_last_save = jsonget("members.%&player_joint_uuid%.last_save",%&slothpixel_profile%);
						if(%&best_save% == "");
							&best_save      = %&profile_last_save%;
							&active_profile = %&slothpixel_profile%;
						else;
							&save_diff = eval("%&profile_last_save% - %&best_save%"); // if profile_last_save bigger (more recent), number will not be negative
							ifnotmatches(%&save_diff%,"-");
								&best_save      = %&profile_last_save%;
								&active_profile = %&slothpixel_profile%;
							endif;
						endif;
					endif;
				next;
				
				if(%&active_profile% != "");
					&profile_members   = jsonget("members",%&active_profile%);
					&profile_members[] = getjsonkeys(%&profile_members%);
					#profile_members   = arraysize(&profile_members[]);
					if(%#profile_members% == 1);
						return("SOLO");
					elseif(%#profile_members% >= 2);
						return("COOP");
					endif;
				endif;
			endif;
		endif;
		
		return("ERROR");
	endfunction;
	
	// Checks if the Collection for the specified Search Term is unlocked. Calls getItemInfoSB with the Search Term to check if the Item has a Collection,
	// and if it does, uses gui/index.txt:remoteGUI to open up the specified Collection to check if the current Profile has unlocked the necessary level/has
	// enough of the specified Collection items to have unlocked the specified item.
		// Params:
			// {string}	<&search_term>   	The Display Name or SBID of the Item to search for.
			// {number}	[#timeout_sec=60]	Amount of seconds to attempt function execution for before terminating. If set to -1, will not terminate self ever.
			//         	                 	If function times out, will return False.
			//
		// Returns a boolean indicating whether or not the Item's Collection is unlocked. If the Item does not have a Collection, then it will always return True.
		// If the Item does not exist (getItemInfo returns -1), then it will always return False.
	function isItemCollectionUnlocked(&search_term,#timeout_sec=60);
		debug = true;
		&script_debug_name = "&6isItemCollectionUnlocked"
		// Get the Item Data
		if(true);
			do_timeout   = #timeout_sec != -1;
			#start_time  = %TIMESTAMP%;
			
			&item_data[]        = getItemInfoSB("%&search_term%",true);
			&found_name         = %&item_data[0]%;
			&found_sbid         = %&item_data[1]%;
			&found_mcid         = %&item_data[2]%;
			#found_data        := %&item_data[3]%;
			#found_sell        := %&item_data[4]%;
			#found_stack       := %&item_data[5]%;
			&found_tier         = %&item_data[6]%;
			&found_category     = %&item_data[7]%;
			found_bazaar       := %&item_data[8]%;
			has_collection     := %&item_data[9]%;
			&collection_name    = %&item_data[10]%;
			&collection_cmdname = %&item_data[11]%;
			&collection_sbid    = %&item_data[12]%;
			#collection_tier   := %&item_data[13]%;
			#collection_amt    := %&item_data[14]%;
			
			if(%&found_name% == "-1");
				return(False);
			elseif(!%has_collection%);
				return(True);
			endif;
			
			// Check if we can answer this question by checking the cached value of the Collection count
			if(true);
				&profile_id[] = getActiveProfile();
				profile_okay := %&profile_id[0]%;
				if(%profile_okay%);
					&profile_json    = %&profile_id[1]%;
					&profile_id      = jsonget("profile_id",%&profile_json%);
					
					// Check if we have already cached the value.
					if(true);
						&original_search_term = "%&profile_id%: %&collection_cmdname%";
						#search_index         = indexof(@&cached_profile_collection_terms[],,%&original_search_term%);
						if(%#search_index% != -1);
							#cached_amt = %@#cached_profile_collection_amounts[%#cached_index%]%;
							if(%#cached_amt% >= %#collection_amt%);
								return(True);
							endif;
						endif;
					endif;
					
					// If we have not cached the value, check if any members of this Coop have the 'unlocked_coll_tiers'
					// property in their "members.<uuid>" JSON Object. If they do, then we can use that to cache rough data
					// regarding the amount of items collected for each collection.
					if(true);
						&profile_members   = jsonget("members",%&profile_json%);
						&profile_members[] = getjsonkeys(%&profile_members%);
						foreach(&profile_members[],&member_uuid,#mui);
							&unlocked_collections = jsonget("members.%&member_uuid%.unlocked_coll_tiers",%&profile_json%);
							ifnotmatches(%&unlocked_collections%,"^ERROR_");
								&unlocked_collections[] = getjsonasarray(%&unlocked_collections%);
								foreach(@&sb_datamap_collection_jsons[],&sb_datamap_collection_json,#sdcji);
									&coll_cmdname  = jsonget("cmdName",%&sb_datamap_collection_json%);
									&coll_tiers    = jsonget("tiers",%&sb_datamap_collection_json%);
									&coll_tiers[]  = getjsonasarray(%&coll_tiers%);
									#coll_max_tier = arraylength(&coll_tiers[]);
									for(#check_tier,%#coll_max_tier%,1);
										&check_string = "%&coll_cmdname%_%#check_tier%";
										#check_index  = indexof(&unlocked_collections[],,%&check_string%);
										if(%#check_index% != -1);
											#min_amount   = jsonget("amountRequired",%&coll_tiers[%#check_tier%]%);
											&input_string = "%&profile_id%: %&coll_cmdname%";
											#input_index  = indexof(@&cached_profile_collection_terms[],,%&input_string%);
											if(%#input_index% != -1);
												#cached_amount = %@#cached_profile_collection_amounts[%#input_index%]%;
												if(%#min_amount% > %#cached_amount%);
													@#cached_profile_collection_amounts[%#input_index%] = %#min_amount%;
												endif;
											else;
												@&cached_profile_collection_terms[]   = %&input_string%;
												@#cached_profile_collection_amounts[] = %#min_amount%;
											endif;
											
											if((&input_string% == %&original_search_term%) && (%#min_amount% >= %#collection_amt%));
												return_boolean = true;
											endif;
											break;
										endif;
									next;
								next;
								
								break;
							endif;
						next;
						
						// Return early after updating our cached collections if we found a hit in the cache for this Item.
						if(%return_boolean%);
							return(True);
						endif;
					endif;
				endif;
			endif;
			
			// We could not answer this question by checking the cached value of the Collection count, so we are
			// going to have to answer it manually by entering the necessary Collection.
			if(true);
				&gui_string = "COLLECTIONS_%&collection_cmdname%";
				debug_log(%debug%,%&script_debug_name%,"Attempting to open with gui_string: %&gui_string%");
				do;
					func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
					if(%func_timeout%);
						break;
					elseif(%do_timeout%);
						#remaining_sec = %#timeout_sec% - (%TIMESTAMP% - %#start_time%);
					else;
						#remaining_sec = -1;
					endif;
					
					in_remote_gui = remoteGUI(%&gui_string%,20,%#remaining_sec%);
					if(%in_remote_gui%);
						#collection_slot = 4;
						&collection_item = getslotitemnbt(%#collection_slot%,,#collection_stack,#collection_data,&collection_nbt);
						&collection_nbt  = strip(%&collection_nbt%);
						ifmatches(%&collection_nbt%,"Total Collected: ([0-9,]+)",&collection_collected,1);
							#collection_collected := regexreplace(&collection_collected,",","");
							answer_found           = true;
							localGUI("NONE");
							break;
						endif;
					else;
						debug_error(%debug%,%&script_debug_name%,"Encountered an error during remoteGUI calls, exiting early.");
						break;
					endif;
				until((%answer_found%) || (%func_timeout%));
			endif;
			
			// If we found our answer, cache it.
			if(%answer_found%);
				&search_cache_string = "%&profile_id%: %&collection_cmdname%";
				#search_cache_index  = indexof(@&cached_profile_collection_terms[],,%&search_cache_string%);
				if(%#search_cache_index% != -1);
					@#cached_profile_collection_amounts[%#search_cache_index%] = %#collection_collected%;
				else;
					@&cached_profile_collection_terms[]   = %&input_string%;
					@#cached_profile_collection_amounts[] = %#collection_collected%;
				endif;
				
				if(%#collection_collected% >= %#collection_amt%);
					return(True);
				endif;
			endif;
			return(False);
		endif;
	endfunction;
	
	// Detects the Blocks surrounding the Player, then based off the environmental data that it detects, decides which direction the Player should be facing
	// in order to discard (throw items out of the Inventory without the Items being re-added into the Inventory afterwards) Items.
		// Params: None
		// Returns an Array:
			// 0 {number} #discard_yaw  	The Yaw value the Player should be looking at in order to Discard Items with the highest likelihood of success
			// 1 {number} #discard_pitch	The Pitch value the Player should be looking at in order to Discard Items with the highest likelihood of success
		// Example:
			// #discard_angles[] = getClearDiscardAngle();
			// #discard_yaw      = %#discard_angles[0]%;
			// #discard_pitch    = %#discard_angles[1]%;
	function getClearDiscardAngle();
		debug                = true;
		&script_debug_name   = "&9getClearDiscardAngle&7";
		&check_curr_axes[]   = split(", ","X, Z");
		&check_oppo_axes[]   = split(", ","Z, X");
		#check_offsets[]     = split(", ","1, 2, 3");
		#check_multipliers[] = split(", ","1, -1");
		#final_calc_x        = %XPOS%;
		#final_calc_y        = %YPOS% + 1;
		#final_calc_z        = %ZPOS%;
		#check_pos_y         = %#final_calc_y%;
		#best_air_loop       = 0;
		foreach(&check_curr_axes[],&check_curr_axis,#cca);
			&check_oppo_axis = %&check_oppo_axes[%#cca%]%;
			foreach(#check_multipliers[],#check_multiplier,#cm);
				#curr_air_loop = 0;
				foreach(#check_offsets[],#check_offset,#co);
					#check_curr_axis := "%%&check_curr_axis%POS%";
					#check_oppo_axis := "%%&check_oppo_axis%POS%";
					#check_curr_axis  = %#check_curr_axis% + (%#check_offset% * %#check_multiplier%);
					
					if(%&check_curr_axis% == "X");
						#check_pos_x = %#check_curr_axis%;
						#check_pos_z = %#check_oppo_axis%;
					else;
						#check_pos_x = %#check_oppo_axis%;
						#check_pos_z = %#check_curr_axis%;
					endif;
					
					&check_pos_id = xgetid(%#check_pos_x%,%#check_pos_y%,%#check_pos_z%);
					if(%&check_pos_id% == "air");
						inc(#curr_air_loop);
						if(%#curr_air_loop% > %#best_air_loop%);
							#best_air_loop = %#curr_air_loop%;
							#final_calc_x  = %#check_pos_x%;
							#final_calc_z  = %#check_pos_z%;
						endif;
					else;
						break;
					endif;
				next;
			next;
		next;
		
		calcyawpitch(%#final_calc_x%,%#final_calc_y%,%#final_calc_z%,#calc_yaw,#calc_dist,#calc_pitch);
		return(%#calc_yaw%,%#calc_pitch%);
	endfunction;
	
	// Given a Search Term (an entry from: sb_datamap_item_names, sb_datamap_item_sbids, or it's Index), looks up the Search Term in the aforementioned Arrays
	// until it finds the Index for the Item.
		// Params:
			// {string} <&search_term>	The Search Term to Search for. Should be the Index, SBID, or Default Display Name.
			//
		// Returns the Index where the Item can be found in the sb_datamap_item_ Arrays, or -1 if it could not be found.
	function getDatamapItemIndex(&search_term);
		#return_number   = -1;
		&search_arrays[] = split(", ","names, sbids");
		&search_prefix   = "@&sb_datamap_item_";
		foreach(&search_arrays[],&search_array_suffix,#sasi);
			&search_array = "%&search_prefix%%&search_array_suffix%[]";
			#search_index = indexof(%&search_array%,,%&search_term%);
			if(%#search_index% != -1);
				#return_number = %#search_index%;
				break;
			endif;
		next;
		if(%#return_number% == -1);
			is_number = isStringNumber(%&search_term%);
			if(%is_number%);
				#index_number             = stringToNumber(%&search_term%);
				#sb_datamap_item_names_sz = arraysize(@&sb_datamap_item_names[]);
				#sb_datamap_item_names_sz = %#sb_datamap_item_names_sz% -1;
				if((%#index_number% >= 0) && (%#index_number% <= %#sb_datamap_item_names_sz%));
					#return_number = %#index_number%;
				endif;
			endif;
		endif;
		return(%#return_number%);
	endfunction;
	
	// Gets the Current Server ID.
		// REQUIRES CHATFILTER EXPRESSIONS:
			//	elseifmatches(%CHATCLEAN%,"^You are currently (?:connected to server|in) (.+)$",&current_server_id);
			//		@&current_server_id = ucase(%&current_server_id%);
			//		if(%debug%);
			//			log("&7%&script_debug_name%&7: Updated '&e@&&current_server_id&7' to '&d%@&current_server_id%&7'.");
			//		endif;
			//	elseifmatches(%CHATCLEAN%,"^Unknown command. Type \"/help\" for help.$");
			//		@chatfilter_unknown_cmd = true;
		// Params:
			// {number} [#wait_ticks=20] 	Amount of Ticks to wait between actions
			// {number} [#timeout_sec=30]	Maximum amount of Seconds the Function can execute for before timing out and returning ERROR_TIMEOUT.
		// Returns the Server ID, or an Error String ENUM:
			// ERROR_TIMEOUT	Function timed out
			// ERROR_UNKNOWN	Function failed for an unknown reason
			// ERROR_COMMAND	Function failed because Command was not available on our Server somehow
	function getServerID(#wait_ticks=20,#timeout_sec=30);
		// Setup Function Variables
		if(true);
			debug              = true;
			&script_debug_name = "&9getServerID&7";
			#start_time        = %TIMESTAMP%;
			do_timeout         = %#timeout_sec% > 0;
			&enum_timeout      = "ERROR_TIMEOUT";
			&enum_unknown      = "ERROR_UNKNOWN";
			&enum_command      = "ERROR_COMMAND";
		endif;
		
		// 1. Check to see if we can grab the Server ID from the Tablist and/or checking to see if we are in Limbo.
		if(true);
			// 1a. Check the Tablist
			if(true);
				debug_log(%debug%,%&script_debug_name%,"Trying to get Server ID from SkyBlock Tablist...");
				&server_id = getSkyBlockPlayerListInfo("SERVER");
				&server_id = ucase(%&server_id%);
				debug_log(%debug%,%&script_debug_name%,"Returned Server ID is '&d%&server_id%&7'.");
				if((%&server_id% != "") && (%&server_id% != "-1"));
					@&current_server_id = %&server_id%;
					debug_log(%debug%,%&script_debug_name%,"Got a valid Server ID from the Tab List: '&d%&server_id%&7'. Returning it.");
					return(%&server_id%);
				endif;
				debug_log(%debug%,%&script_debug_name%,"Did not get a valid Server ID from the Tab List. Checking if we are in Limbo...");
			endif;
			
			// 1b. Check if we are in Limbo
			if(true);
				&current_gamemode = getHypixelGamemode();
				if(%&current_gamemode% == "LIMBO");
					debug_log(%debug%,%&script_debug_name%,"We are in Limbo. Returning '&dLIMBO&7'.");
					@&current_server_id = "LIMBO";
					return("LIMBO");
				endif;
				debug_log(%debug%,%&script_debug_name%,"We are not in Limbo. Trying /whereami Command...");
			endif;
		endif;
		
		// 2. Loop command '/whereami' until we find out what Server we are on, or we encounter an Error we cannot recover from.
		if(true);
			unset(@&current_server_id);
			unset(@chatfilter_unknown_cmd);
			#waited_ticks = 0;
			do;
				// 1. Check for Function Timeout
				if(%do_timeout%);
					func_timeout = hasTimeExceeded(%#start_time%,%#timeout_sec%,%do_timeout%);
					if(%func_timeout%);
						debug_error(%debug%,%&script_debug_name%,"Function has timed out");
						&return_string = %&enum_timeout%;
						break;
					endif;
				endif;
				
				// 2. Check if we have a Server ID, or if we are on a Server where this Command is not available somehow.
				if((%message_sent%) && ((%@&current_server_id% != "") || (%@chatfilter_unknown_cmd%)));
					if(%@&current_server_id% != "");
						debug_log(%debug%,%&script_debug_name%,"Got a valid Current Server ID: '&d%@&current_server_id%&7'.");
						&return_string = %@&current_server_id%;
					elseif(%@chatfilter_unknown_cmd%);
						debug_error(%debug%,%&script_debug_name%,"Somehow, we cannot use the Command &4/whereami&c on whichever Server we are on.");
						&return_string = %&enum_command%;
					endif;
					break;
				endif;
				
				// 3. Check to see if we can send the Chat Command
				do_command = canDoInteraction(%#waited_ticks%,%#wait_ticks%);
				if(%do_command%);
					echo("/whereami");
					message_sent = true;
				endif;
				
				inc(#waited_ticks);
				wait("1t");
			until(%&return_string% != "");
		endif;
		
		debug_log(%debug%,%&script_debug_name%,"Returning: '&d%&return_string%&7'.");
		return(%&return_string%);
	endfunction;